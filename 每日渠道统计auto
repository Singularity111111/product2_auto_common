# -*- coding: utf-8 -*-

"""

VNL报表生成器 - 简化版本，先解决基本样式问题

"""



import sys

import os

# 设置控制台编码

if sys.platform.startswith('win'):

    os.system('chcp 65001 > nul')
    # 设置Python的标准输出编码为UTF-8
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, errors='replace')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, errors='replace')



import pandas as pd

import numpy as np

from datetime import datetime

import os

import glob

from openpyxl import Workbook, load_workbook

from openpyxl.styles import Font, PatternFill, Border, Side, Alignment

from openpyxl.utils.dataframe import dataframe_to_rows

from openpyxl.formatting.rule import DataBarRule, ColorScaleRule, CellIsRule

from openpyxl.utils import range_boundaries, get_column_letter

from openpyxl.worksheet.page import PageMargins

import matplotlib.pyplot as plt

import matplotlib.patches as patches

import warnings

warnings.filterwarnings('ignore')



# 设置中文字体

plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei']

plt.rcParams['axes.unicode_minus'] = False



class VNLReportGenerator:

    def __init__(self):

        # 修复：更新默认汇率为18.7

        self.EXCHANGE_RATE = 18.7

        

        # 全局配置 - 按照用户规范更新

        self.config = {

            'global': {

                'zebra': {

                    'enable': True,

                    'fill': '#FAFAFA'

                },

                'header': {

                    'fill': '#0D2D5A',

                    'font': '#000000',

                    'bold': True,

                    'row_height_pt': 34,

                    'repeat_rows': '1:2'

                },

                'currency': {

                    'mode': 'divide',

                    'rate': 18.7

                },

                'number_format': {

                    'money': '#,##0.00',

                    'count': '#,##0',

                    'percent': '0.0%'

                },

                'databar_defaults': {

                    'money_or_count': '#70AD47',

                    'percent_or_ratio': '#4F81BD'

                }

            },

            'VNL短信日报': {

                'zebra': True,

                'columns': [

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '方式', 'databar': {'enable': False}},

                    {'name': '当日消耗($)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '注册成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '一级首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '充提差比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充提差', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '老用户金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充值人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户付费率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '14日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '30日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '日期', 'databar': {'enable': False}},
                    {'name': '首充次日复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充7日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},
                    {'name': '首充30日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '非一级首充/首充人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '非一级首充/充值人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充转化率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '新增用户', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充次日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},

                    {'name': '首充7日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},

                    {'name': '首充30日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},

                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},
                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}}
                ]

            },

            'VNL网红日报': {

                'zebra': True,

                'columns': [

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '方式', 'databar': {'enable': False}},

                    {'name': '当日消耗($)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '注册成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '一级首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '充提差比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充提差', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '老用户金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充值人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户付费率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '14日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '30日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '日期', 'databar': {'enable': False}},
                    {'name': '首充次日复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充7日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},
                    {'name': '首充30日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '非一级首充/首充人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '非一级首充/充值人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充转化率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '新增用户', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充次日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},

                    {'name': '首充7日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},

                    {'name': '首充30日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},
                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}}
                ]

            },

            'VNL投放日报': {

                'zebra': True,

                'columns': [

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '方式', 'databar': {'enable': False}},

                    {'name': '当日消耗($)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '注册成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '一级首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '充提差比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充提差', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '老用户金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充值人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户付费率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '14日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '30日LTV', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '日期', 'databar': {'enable': False}},
                    {'name': '首充次日复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充7日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},
                    {'name': '首充30日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '非一级首充/首充人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '非一级首充/充值人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充转化率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '新增用户', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充次日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},

                    {'name': '首充7日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},

                    {'name': '首充30日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},
                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}}
                ]

            },

            'VNL投放明细': {

                'zebra': True,

                'columns': [

                    {'name': '投放方式', 'databar': {'enable': False}},

                    {'name': '总代号', 'databar': {'enable': False}},

                    {'name': '总代名', 'databar': {'enable': False}},

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '当日消耗($)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '注册成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '一级首充成本', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '充提差', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充提差比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充值金額', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '新增用户', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充付费人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充转化率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充次日复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充7日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},
                    {'name': '首充30日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '首充金额', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充值人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '首充人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户人均', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '非一级首充/首充人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '非一级首充/充值人数', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '老用户付费率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充次日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充3日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充7日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充30日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}}

                ]

            },

            'VNL短信日报': {
                'zebra': True,
                'columns': [
                    {'name': '日期', 'databar': False},
                    {'name': '方式', 'databar': False},
                    {'name': '当日消耗($)', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'money'},
                    {'name': '充值金额', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'money'},
                    {'name': '首充金额', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'money'},
                    {'name': '老用户金额', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'money'},
                    {'name': '充值差', 'databar': {'enable': False}, 'number_format': 'money', 'negative_text_if': '<0'},
                    {'name': '充值人数', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'count'},
                    {'name': '首充人数', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'count'},
                    {'name': '老用户人均', 'databar': {'enable': False}},
                    {'name': '新增用户', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'count'},
                    {'name': '首充付费人数', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'count'},
                    {'name': '一级首充人数', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}, 'number_format': 'count'},
                    {'name': '注册成本', 'databar': {'enable': False}},
                    {'name': '首充成本', 'databar': {'enable': False}},
                    {'name': '一级首充成本', 'databar': {'enable': False}},
                    {'name': '充值差比', 'databar': {'enable': False}, 'number_format': 'percent', 'negative_text_if': '<0'},
                    {'name': '首次次日复充率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<30%'},
                    {'name': '首次3日复充率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<20%'},
                    {'name': '首次7日复充率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<12%'},
                    {'name': '首次30日复充率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<20%'},
                    {'name': '首次次日留存率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<30%'},
                    {'name': '首次3日留存率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<20%'},
                    {'name': '首次7日留存率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<12%'},
                    {'name': '首次30日留存率', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'number_format': 'percent', 'warn_if': '<20%'},
                    {'name': '总充值ROI', 'databar': {'enable': False}, 'negative_text_if': '<1.0'},
                    {'name': '当日回本ROI', 'databar': {'enable': False}, 'negative_text_if': '<1.0'},
                    {'name': '投充比', 'databar': {'enable': False}, 'negative_text_if': '<1.0'},
                    {'name': '14日LTV', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},
                    {'name': '30日LTV', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}}
                ]
            },
            'VNL大盘日报': {

                'zebra': True,

                'columns': [

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '总消耗(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充成本(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充成本(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充提差比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '总充提差(U)', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '充值金额(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充充值金额(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '老用户充值金额(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '人均充值金额(U)', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '人均充值笔数', 'format': 'count', 'databar': {'enable': False}},

                    {'name': '首充人均充值金额(U)', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户人均充值金额U', 'format': 'money', 'databar': {'enable': False}},

                    {'name': '老用户付费率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '14日LTV', 'format': 'money', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '30日LTV', 'format': 'money', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充次日复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<30%'},

                    {'name': '首充3日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '首充7日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<12%'},
                    {'name': '首充30日 复充率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '<20%'},
                    {'name': '非一级首充人数/首充人数', 'format': 'percent', 'databar': {'enable': False}},

                    {'name': '非一级首充人数/充值人数', 'format': 'percent', 'databar': {'enable': False}},

                    {'name': '首充数转化率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '新增注册人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '一级首充人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充值人数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '日期', 'databar': {'enable': False}},

                    {'name': '投注用户数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '充投用户数', 'format': 'count', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '首充次日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充3日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充7日复登率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充次日复投率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充3日复投率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '首充7日复投率', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}},

                    {'name': '投注金额(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '出入人数比', 'format': 'percent', 'databar': {'enable': False}},

                    {'name': '游戏盈亏投注比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '投充比', 'format': 'percent', 'databar': {'enable': False}, 'negative_text_if': '<1.0'},

                    {'name': '佣金金额(U)', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}},

                    {'name': '彩金赠送充值比', 'format': 'percent', 'databar': {'enable': True, 'color': '#4F81BD', 'show_value': True}, 'warn_if': '>30%'},

                    {'name': '历史营收(历史充提差-历史消耗)', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '历史充提差', 'format': 'money', 'databar': {'enable': False}, 'negative_text_if': '<0'},

                    {'name': '历史消耗', 'format': 'money', 'databar': {'enable': True, 'color': '#70AD47', 'show_value': False}}

                ]

            }

        }

        

        # 颜色配置 - 按照PDF规范

        self.COLORS = {

            'NAVY': '1F4E78',        # 表头深蓝

            'BLUE': '2E75B6',        # 数据条蓝

            'BLUE_LIGHT': 'E9F0F8',  # 斑马奇行

            'BLUE_LIGHTER': 'F6FAFF', # 斑马偶行

            'NEG_TXT': '9C0006',     # 负值红字

            'NEG_FILL': 'F4CCCC',    # 负值浅红底

            'TOTAL_FILL': 'D9E1F2',  # 总计行

            'AVG_FILL': 'EDEFF7',    # 日均行

        }

        

        # 汇率配置 - 统一使用18.7

        self.EXCHANGE_RATE = 18.7

        

        # 最新日期缓存

        self.latest_date = None

    

    def _get_latest_date_from_data(self, df_dict):

        """从数据中获取最新日期"""

        if self.latest_date is not None:

            return self.latest_date

            

        latest_date = None

        

        # 遍历所有sheet查找最新日期

        for sheet_name, df in df_dict.items():

            # 查找日期列

            date_columns = []

            for col in df.columns:

                if '日期' in col or '时间' in col or col == '时间':

                    date_columns.append(col)

            

            for col in date_columns:

                if col in df.columns:

                    # 获取非空日期

                    non_null_dates = df[col].dropna()

                    if len(non_null_dates) > 0:

                        # 过滤掉非日期字符串

                        valid_dates = []

                        for date_val in non_null_dates:

                            if isinstance(date_val, str) and date_val not in ['时间', '日期', '日均']:

                                try:

                                    parsed_date = pd.to_datetime(date_val, format='%d/%m/%Y')

                                    valid_dates.append(parsed_date)

                                except:

                                    continue

                            elif not isinstance(date_val, str):

                                try:

                                    parsed_date = pd.to_datetime(date_val)

                                    valid_dates.append(parsed_date)

                                except:

                                    continue

                        

                        if valid_dates:

                            sheet_latest = max(valid_dates)

                            if latest_date is None or sheet_latest > latest_date:

                                latest_date = sheet_latest

        

        if latest_date is not None:

            self.latest_date = latest_date.strftime('%m%d')

            print(f"Debug: Latest date found: {latest_date.strftime('%Y-%m-%d')} -> {self.latest_date}")

        else:

            self.latest_date = "1015"  # 默认值

            print(f"Debug: No valid date found, using default: {self.latest_date}")

        

        return self.latest_date

    

    def _convert_currency_columns(self, df, title):

        """转换金额列为美元单位"""

        df_converted = df.copy()

        

        # 检查数据是否已经标注美元单位

        has_dollar_sign = False

        for col in df.columns:

            if df[col].dtype == 'object':

                # 检查是否有$符号

                if df[col].astype(str).str.contains(r'\$').any():

                    has_dollar_sign = True

                    break

        

        if has_dollar_sign:

            # 如果数据已经标注美元，不进行汇率转换

            print(f"Debug: Data already in USD format - no conversion needed")

            return df_converted

        

        # 根据不同的sheet和列名确定需要转换的列

        currency_columns = []

        

        if '后台' in title or '后台' in str(df_converted.columns):

            # 后台sheet：转换金额相关列，但跳过比率、人数等非金额字段

            currency_columns = [col for col in df.columns if 

                              ('总赠送' in col or '充值金额' in col or '到账金币' in col or 

                               '笔次均值' in col or '人均充值' in col or '提现金额' in col or 

                               '实际提现金额' in col or 'ARPU' in col or '当日总流水' in col or 

                               '当日总返奖' in col or '当日总盈利' in col or '用户总充值金额' in col or 

                               '新充金额' in col or '首充金额' in col or '首笔汇总' in col or 

                               '充提差' in col or 'LTV' in col) and 

                              '(U)' not in col and '人数' not in col and '次数' not in col and 

                              '率' not in col and '比' not in col and '数量' not in col]

        elif 'VNL大盘日报' in title:

            # VNL大盘日报：转换所有金额相关列（不管是否包含(U)）

            currency_columns = [col for col in df.columns if 

                              ('消耗' in col or '金额' in col or '成本' in col or '充提差' in col or 'LTV' in col or '营收' in col)]

        else:

            # 其他sheet：转换金额相关列

            currency_columns = [col for col in df.columns if 

                              isinstance(col, str) and ('金额' in col or '成本' in col or '消耗' in col or 

                               'LTV' in col or '营收' in col or '充提差' in col) and '(U)' not in col]

        

        print(f"Debug: Found {len(currency_columns)} currency columns to convert")

        

        for col in currency_columns:

            if col in df_converted.columns:

                # 只转换数值类型的列

                if df_converted[col].dtype in ['int64', 'float64']:

                    # 转换金额列：除以汇率

                    df_converted[col] = df_converted[col] / self.EXCHANGE_RATE

                    print(f"Debug: Converted column - divided by {self.EXCHANGE_RATE}")

                else:

                    print(f"Debug: Skipped non-numeric column")

        

        return df_converted

    
    def _calculate_derived_fields(self, df, target_dates):
        """
        为指定日期的数据计算派生字段
        只对target_dates中的日期应用计算，不影响历史数据
        """
        if '时间' not in df.columns:
            return df
        
        # 只对指定日期的数据进行计算
        for target_date in target_dates:
            mask = df['时间'] == target_date
            if not mask.any():
                continue
            
            idx = df[mask].index
            
            # 安全获取值的辅助函数
            def safe_get(row_idx, col_name, default=0):
                if col_name in df.columns:
                    val = df.loc[row_idx, col_name]
                    return val if pd.notna(val) else default
                return default
            
            # 安全除法
            def safe_divide(numerator, denominator):
                if denominator and denominator != 0:
                    return round(numerator / denominator, 2)
                return 0
            
            for i in idx:
                # 获取基础数据
                消耗 = safe_get(i, '当日消耗($)')
                充值金额 = safe_get(i, '充值金額')
                首充金额 = safe_get(i, '首充金额')
                充提差 = safe_get(i, '充提差')
                首充人数 = safe_get(i, '首充人数')
                一级首充人数 = safe_get(i, '一级首充人数')
                新增用户 = safe_get(i, '新增用户')
                
                # 计算派生字段
                # 1. 注册成本 = 总代消耗 / 注册人数
                if '注册成本' in df.columns and 新增用户:
                    df.loc[i, '注册成本'] = safe_divide(消耗, 新增用户)
                
                # 2. 首充成本 = 总代消耗 / 首充人数
                if '首充成本' in df.columns:
                    df.loc[i, '首充成本'] = safe_divide(消耗, 首充人数)
                
                # 3. 一级首充成本 = 总代消耗 / 一级首充人数
                if '一级首充成本' in df.columns:
                    df.loc[i, '一级首充成本'] = safe_divide(消耗, 一级首充人数)
                
                # 4. 首充转化率 = 首充人数 / 注册人数
                if '首充转化率' in df.columns and 新增用户:
                    df.loc[i, '首充转化率'] = safe_divide(首充人数, 新增用户)
                
                # 5. 一级首充转化率 = 一级首充人数 / 注册人数
                if '一级首充转化率' in df.columns and 新增用户:
                    df.loc[i, '一级首充转化率'] = safe_divide(一级首充人数, 新增用户)
                
                # 6. 首充当日LTV = 充提差 / 首充人数
                if '首充当日LTV' in df.columns:
                    df.loc[i, '首充当日LTV'] = safe_divide(充提差, 首充人数)
                
                # 7. 首充当日ROI = 充提差 / 消耗
                if '首充当日ROI' in df.columns:
                    df.loc[i, '首充当日ROI'] = safe_divide(充提差, 消耗)
                
                # 8. ROI = 充提差 / 消耗
                if 'ROI' in df.columns:
                    df.loc[i, 'ROI'] = safe_divide(充提差, 消耗)
                
                # 9. 首充ARPPU = 首充金额 / 首充人数
                if '首充ARPPU' in df.columns:
                    df.loc[i, '首充ARPPU'] = safe_divide(首充金额, 首充人数)
                
                # 10. 首充ROAS = 首充金额 / 消耗
                if '首充ROAS' in df.columns:
                    df.loc[i, '首充ROAS'] = safe_divide(首充金额, 消耗)
                
                # 11. 累计ROAS = 充值金额 / 消耗
                if '累计ROAS' in df.columns:
                    df.loc[i, '累计ROAS'] = safe_divide(充值金额, 消耗)
                
                # 12. 充提差比 = 充提差 / 充值金额
                if '充提差比' in df.columns and 充值金额:
                    df.loc[i, '充提差比'] = safe_divide(充提差, 充值金额)
                
                # 13. 首充充提差比 = 充提差 / 首充金额
                if '首充充提差比' in df.columns and 首充金额:
                    df.loc[i, '首充充提差比'] = safe_divide(充提差, 首充金额)
                
                # 14. 裂变占比 = (首充人数 - 一级首充人数) / 首充人数
                if '裂变占比' in df.columns and 首充人数:
                    裂变人数 = 首充人数 - 一级首充人数
                    df.loc[i, '裂变占比'] = safe_divide(裂变人数, 首充人数)
                
                # 15. 新增/首充率 = 新增用户 / 首充人数
                if '新增/首充率' in df.columns and 首充人数:
                    df.loc[i, '新增/首充率'] = safe_divide(新增用户, 首充人数)
        
        return df

    

    def load_data(self):

        """从final_report_v4.xlsx和产品二文件加载数据"""

        print("Loading data from final report...")

        

        try:
            # 读取final_report_v4.xlsx文件（实时数据源）

            df_dict = pd.read_excel('final_report_v4.xlsx', sheet_name=None, engine='openpyxl', header=0)

            print(f"  Loaded final_report_v4.xlsx: {len(df_dict)} sheets")
            print(f"  Sheet names: {list(df_dict.keys())}")

        
            # 读取产品二文件（完整字段模板和历史数据）
            print("Loading data from 产品二-VNL日报-10月 (21).xlsx...")
            try:
                product2_dict_raw = pd.read_excel('产品二-VNL日报-10月 (21).xlsx', sheet_name=['短信', '网红', '投放'], engine='openpyxl', header=None)
                print(f"  Loaded 产品二文件: {len(product2_dict_raw)} sheets")
                
                # 处理产品二文件的特殊格式（第1行是标题，第2行是列名，第3-4行是总计/日均）
                for sheet_name in ['短信', '网红', '投放']:
                    if sheet_name in product2_dict_raw:
                        df_raw = product2_dict_raw[sheet_name]
                        # 行1是列名（索引1）
                        if len(df_raw) > 1:
                            column_names = df_raw.iloc[1].tolist()
                            
                            # 处理重复列名：给重复的列名添加后缀
                            seen = {}
                            for i, col in enumerate(column_names):
                                if col in seen:
                                    seen[col] += 1
                                    column_names[i] = f"{col}_{seen[col]}"
                                else:
                                    seen[col] = 0
                            
                            # 跳过行0（标题）、行1（列名）、行2-3（总计/日均），从行4开始是实际数据
                            df_data = df_raw.iloc[4:].copy()
                            df_data.columns = column_names
                            df_data = df_data.reset_index(drop=True)
                            
                            # 删除第一列（通常是空列或序号）
                            if df_data.columns[0] in [None, np.nan] or pd.isna(df_data.columns[0]) or str(df_data.columns[0]).strip() == '':
                                df_data = df_data.iloc[:, 1:]
                            
                            # 额外清理：删除任何仍然包含"总计"或"日均"的行（以防万一）
                            if '日期' in df_data.columns:
                                # 检查第二列是否是"总计"或"日均"
                                second_col = None
                                if len(df_data.columns) > 1:
                                    second_col = df_data.columns[1]
                                    if second_col in df_data.columns:
                                        df_data = df_data[~df_data[second_col].isin(['总计', '日均'])].copy()
                                        df_data = df_data.reset_index(drop=True)
                            
                            # 将日期列转换为仅显示日期（不显示时间）
                            if '日期' in df_data.columns:
                                df_data['日期'] = pd.to_datetime(df_data['日期'], errors='coerce')
                                # 只保留日期部分
                                df_data['日期'] = df_data['日期'].dt.date
                            
                            df_dict[sheet_name] = df_data
                            print(f"  Added {sheet_name} from 产品二: {df_data.shape} (cleaned)")
            except Exception as e:
                print(f"  Warning: Could not load 产品二 file: {e}")

            # 加载推广渠道统计数据源
            print("Loading 推广渠道统计 data from CSV files...")
            promo_channel_data = self._load_promo_channel_stats()

            if not promo_channel_data.empty:

                df_dict['推广渠道统计'] = promo_channel_data
                print(f"  Added 推广渠道统计: {promo_channel_data.shape}")
        

            # 加载每日渠道统计数据源
            print("Loading 每日渠道统计 data from CSV files...")
            daily_channel_data = self._load_daily_channel_stats()

            if not daily_channel_data.empty:

                df_dict['每日渠道统计'] = daily_channel_data
                print(f"  Added 每日渠道统计: {daily_channel_data.shape}")
        

            # 加载赠送类型统计数据源
            print("Loading 赠送类型统计 data from CSV files...")
            gift_stats_data = self._load_gift_stats()

            if not gift_stats_data.empty:

                df_dict['赠送类型统计'] = gift_stats_data
                print(f"  Added 赠送类型统计: {gift_stats_data.shape}")
            
            # 检查每个sheet的数据
            for sheet_name, df in df_dict.items():
                try:
                    print(f"  {sheet_name}: {df.shape}")
                except:

                    print(f"  Sheet: {df.shape}")
        

            return df_dict

    

        except Exception as e:
            print(f"  Error loading final report: {e}")
            # 如果文件不存在，返回空字典
            return {}


    def _load_backend_data(self):

        """加载后台数据"""

        files = glob.glob('download_ops_*.csv')

        if not files:

            print("Warning: No backend data files found")

            return pd.DataFrame()

        

        data_list = []

        for file in files:

            try:

                df = pd.read_csv(file, encoding='utf-8')

                data_list.append(df)

            except:

                try:

                    df = pd.read_csv(file, encoding='gbk')

                    data_list.append(df)

                except:

                    print(f"Cannot read file: {file}")

                    continue

        

        if data_list:

            combined_df = pd.concat(data_list, ignore_index=True)

            # 按日期聚合，而不是去重

            agg_map = {

                '当日总流水': 'sum',

                '商城充值金额': 'sum', 

                '商城充值次数': 'sum',

                '充值人数': 'sum',

                '新增人员': 'sum',

                '首充人数': 'sum',

                '一级首充人数': 'sum',

                '投注人数': 'sum',

                '充值投注人数': 'sum',

                '提现人数': 'sum',

                '商城提现金额': 'sum',

                '实际提现金额': 'sum',

                '当日总盈利': 'sum',

                '充提差': 'sum',

                '首充用户总充值金额': 'sum',

                '一级首充金额': 'sum',

                '新充金额': 'sum',

                '笔次均值': 'mean',

                '人均充值': 'mean',

                '今日投充比': 'mean',

                '首充次日复投率': 'mean',

                '首充3日复投率': 'mean', 

                '首充7日复投率': 'mean'

            }

            

            # 只聚合存在的列，并处理数据类型

            existing_cols = {k: v for k, v in agg_map.items() if k in combined_df.columns}

            if '时间' in combined_df.columns:

                # 先转换数值列为数值类型

                for col in existing_cols.keys():

                    if col in combined_df.columns:

                        if existing_cols[col] == 'mean':

                            # 对于需要平均的列，先转换为数值

                            combined_df[col] = pd.to_numeric(combined_df[col], errors='coerce')

                        elif existing_cols[col] == 'sum':

                            # 对于需要求和的列，先转换为数值

                            combined_df[col] = pd.to_numeric(combined_df[col], errors='coerce')

                

                # 修复：使用复合键去重，而不是单日期去重

                # 对于后台数据，按时间聚合即可

                combined_df = combined_df.groupby('时间', as_index=False).agg(existing_cols)

            

            return combined_df

        return pd.DataFrame()

    

    def _load_channel_data(self):

        """加载渠道数据"""

        # 加载渠道质量、用户质量、经济效益数据

        channel_files = glob.glob('推广_全平台_*.csv')

        if not channel_files:

            print("Warning: No channel data files found")

            return pd.DataFrame()

        

        data_list = []

        for file in channel_files:

            try:

                df = pd.read_csv(file, encoding='utf-8')

                data_list.append(df)

            except:

                try:

                    df = pd.read_csv(file, encoding='gbk')

                    data_list.append(df)

                except:

                    continue

        

        if data_list:

            return pd.concat(data_list, ignore_index=True)

        return pd.DataFrame()

    

    def _load_promo_channel_stats(self):

        """加载推广渠道统计数据 - 从指定的CSV文件"""

        # 推广渠道统计的数据源文件

        files = [

            '推广_全平台_推广渠道统计-经济效益_2025-10-18.csv',

            '推广_全平台_推广渠道统计-用户质量_2025-10-18.csv',

            '推广_全平台_推广渠道统计-渠道质量_2025-10-18.csv'

        ]

        

        data_list = []

        for file in files:

            try:

                if os.path.exists(file):

                    try:

                        df = pd.read_csv(file, encoding='utf-8')

                        data_list.append(df)

                        print(f"  Loaded {file}: {df.shape}")
                    except:

                        df = pd.read_csv(file, encoding='gbk')

                        data_list.append(df)

                        print(f"  Loaded {file}: {df.shape}")
                else:

                    print(f"  Warning: {file} not found")
            except Exception as e:

                print(f"  Error loading {file}: {e}")
        

        if data_list:

            # 合并所有数据

            return pd.concat(data_list, ignore_index=True)
        return pd.DataFrame()

    

    def _load_daily_channel_stats(self):

        """加载每日渠道统计数据 - 从指定的CSV文件"""

        # 每日渠道统计的数据源文件

        files = [

            '每日渠道统计-渠道质量-10-17.csv',

            '每日渠道统计-用户质量-10-17.csv',

            '每日渠道统计-经济效益-10-17.csv'

        ]

        

        data_list = []

        for file in files:

            try:

                if os.path.exists(file):

                    try:

                        df = pd.read_csv(file, encoding='utf-8')

                        data_list.append(df)

                        print(f"  Loaded {file}: {df.shape}")
                    except:

                        df = pd.read_csv(file, encoding='gbk')

                        data_list.append(df)

                        print(f"  Loaded {file}: {df.shape}")
                else:

                    print(f"  Warning: {file} not found")
            except Exception as e:

                print(f"  Error loading {file}: {e}")
        

        if data_list:

            # 合并所有数据

            return pd.concat(data_list, ignore_index=True)

        return pd.DataFrame()

    

    def _load_gift_stats(self):

        """加载赠送类型统计数据 - 从指定的CSV文件"""

        # 赠送类型统计的数据源文件

        file = '赠送类型统计2025-10-17.csv'

        

        try:

            if os.path.exists(file):

                try:

                    df = pd.read_csv(file, encoding='utf-8')

                    print(f"  Loaded {file}: {df.shape}")

                    return df

                except:

                    df = pd.read_csv(file, encoding='gbk')

                    print(f"  Loaded {file}: {df.shape}")

                    return df

            else:

                print(f"  Warning: {file} not found")

        except Exception as e:

            print(f"  Error loading {file}: {e}")

        

        return pd.DataFrame()

    

    def _get_retention_from_backend(self, row, first_recharge_users):

        """从后台数据直接获取留存率"""

        retention_rates = {}

        

        # 尝试从后台数据获取复登率和复投率

        retention_days = ['次日', '3日', '7日', '30日']

        for day in retention_days:

            # 复登率计算：首充用户X日登录人数 ÷ 首充人数

            login_users_key = f'首充{day}复登人数'

            if login_users_key in row and first_recharge_users > 0:

                login_users = pd.to_numeric(row.get(login_users_key, 0), errors='coerce')

                if not pd.isna(login_users):

                    retention_rates[f'首充{day}复登率'] = login_users / first_recharge_users

                    print(f"Debug: 复登率计算 - {day}: {login_users} ÷ {first_recharge_users} = {retention_rates[f'首充{day}复登率']}")
            

            # 复投率计算：首充用户X日投注人数 ÷ 首充人数

            betting_users_key = f'首充{day}投注人数'

            if betting_users_key in row and first_recharge_users > 0:

                betting_users = pd.to_numeric(row.get(betting_users_key, 0), errors='coerce')

                if not pd.isna(betting_users):

                    retention_rates[f'首充{day}复投率'] = betting_users / first_recharge_users

                    print(f"Debug: 复投率计算 - {day}: {betting_users} ÷ {first_recharge_users} = {retention_rates[f'首充{day}复投率']}")
        

        return retention_rates

    

    def _calculate_ltv_for_period(self, ltv_data, target_date, days_back):

        """计算指定天数前的LTV值"""

        try:

            # 计算目标日期（days_back天前）

            from datetime import timedelta

            period_date = target_date - timedelta(days=days_back)

            

            # 在LTV数据中查找对应日期的数据

            if '时间' in ltv_data.columns:

                # 确保时间列是datetime类型

                if ltv_data['时间'].dtype == 'object':

                    ltv_data['时间'] = pd.to_datetime(ltv_data['时间'], errors='coerce')

                

                # 查找对应日期的数据
                # 处理period_date可能是date或datetime类型
                period_date_only = period_date.date() if hasattr(period_date, 'date') else period_date
                period_data = ltv_data[ltv_data['时间'].dt.date == period_date_only]

                

                if not period_data.empty:

                    # 计算LTV

                    recharge_amount = pd.to_numeric(period_data.iloc[0].get('充值金额', 0), errors='coerce')

                    withdraw_amount = pd.to_numeric(period_data.iloc[0].get('提现金额', 0), errors='coerce')

                    recharge_users = pd.to_numeric(period_data.iloc[0].get('充值人数', 0), errors='coerce')

                    

                    if pd.notna(recharge_amount) and pd.notna(withdraw_amount) and pd.notna(recharge_users) and recharge_users > 0:

                        ltv_value = (recharge_amount - withdraw_amount) / recharge_users

                        print(f"Debug: {days_back}日LTV计算 - 日期: {period_date_only}, 充提差: {recharge_amount - withdraw_amount}, 充值人数: {recharge_users}, LTV: {ltv_value}")
                        return ltv_value

                    else:

                        print(f"Debug: {days_back}日LTV计算 - 数据无效，日期: {period_date_only}")
                        return 0

                else:

                    print(f"Debug: {days_back}日LTV计算 - 未找到对应日期数据: {period_date_only}")
                    return 0

            else:

                print(f"Debug: {days_back}日LTV计算 - LTV数据中没有时间列")
                return 0

        except Exception as e:

            print(f"Debug: {days_back}日LTV计算失败: {e}")
            return 0



    def _load_retention_data(self):

        """加载留存数据 - 从final_report_v4.xlsx获取所有留存数据"""

        login_data = []

        recharge_data = []

        

        try:

            # 从Excel文件加载所有数据

            df_dict = pd.read_excel('final_report_v4.xlsx', sheet_name=None, engine='openpyxl', header=0)

            

            # 查找所有相关的sheet

            for sheet_name, df in df_dict.items():

                try:

                    print(f"  Checking sheet: {sheet_name} with shape {df.shape}")

                    # 检查sheet名称是否包含留存相关关键词

                    if any(keyword in sheet_name for keyword in ['首充复充', '首充复登', '复充', '复登', '留存', 'retention']):
                        print(f"  Found retention sheet by name: {sheet_name} with shape {df.shape}")

                        

                        # 根据sheet名称判断数据类型

                        if '复登' in sheet_name:

                            login_data.append(df)

                            print(f"  Added to login data (复登)")
                        elif '复充' in sheet_name:

                            recharge_data.append(df)

                            print(f"  Added to recharge data (复充)")
                        else:

                            # 默认作为充值留存数据

                            recharge_data.append(df)

                            print(f"  Added to recharge data (default)")

                except:

                    # 如果sheet名称有编码问题，尝试其他方式判断

                    if not df.empty:

                        # 检查列名来判断数据类型

                        columns_str = ' '.join([str(col) for col in df.columns])

                        if '复登' in columns_str or 'login' in columns_str.lower():

                            login_data.append(df)

                            print(f"  Added to login data by column names")

                        elif '复充' in columns_str or 'recharge' in columns_str.lower():

                            recharge_data.append(df)

                            print(f"  Added to recharge data by column names")

                        else:

                            # 默认作为充值留存数据

                            recharge_data.append(df)

                            print(f"  Added to recharge data by column names (default)")

            

        except Exception as e:

            print(f"Error loading retention data from Excel: {e}")

        

        # 如果没有找到留存数据，尝试从所有sheet中查找

        if not login_data and not recharge_data:

            try:

                df_dict = pd.read_excel('final_report_v4.xlsx', sheet_name=None, engine='openpyxl', header=0)

                for sheet_name, df in df_dict.items():

                    if not df.empty and len(df.columns) > 10:  # 假设留存数据有很多列

                        # 检查是否有时间列和留存相关列

                        time_cols = [col for col in df.columns if '时间' in str(col) or 'date' in str(col).lower()]

                        retention_cols = [col for col in df.columns if any(keyword in str(col) for keyword in ['次日', '3日', '7日', '30日', '复充', '复登'])]

                        

                        if time_cols and retention_cols:

                            print(f"  Found potential retention sheet: {sheet_name} with {len(time_cols)} time cols and {len(retention_cols)} retention cols")

                            # 根据列名判断是登录还是充值留存

                            if any('复登' in str(col) for col in retention_cols):

                                login_data.append(df)

                            else:

                                recharge_data.append(df)

            except Exception as e:

                print(f"Error in fallback retention data loading: {e}")

        

        return {

            'login': pd.concat(login_data, ignore_index=True) if login_data else pd.DataFrame(),
            'recharge': pd.concat(recharge_data, ignore_index=True) if recharge_data else pd.DataFrame()
        }

    

    def _load_ltv_data(self):

        """加载LTV数据"""

        ltv_files = glob.glob('download_ltv_全平台_*.csv')

        if not ltv_files:

            print("Warning: No LTV data files found")

            return pd.DataFrame()

        

        data_list = []

        for file in ltv_files:

            try:

                df = pd.read_csv(file, encoding='utf-8')

                data_list.append(df)

            except:
                try:

                    df = pd.read_csv(file, encoding='gbk')

                    data_list.append(df)

                except:
                    continue

        

        if data_list:

            return pd.concat(data_list, ignore_index=True)
        return pd.DataFrame()

    

    def _calculate_real_metrics(self, backend_data, channel_data, retention_data, ltv_data):

        """计算真实指标"""

        if backend_data.empty:

            print("Warning: No backend data, using mock data")

            return self._get_mock_data()

        

        # 处理日期格式
        if '时间' in backend_data.columns:

            backend_data['时间'] = pd.to_datetime(backend_data['时间'], errors='coerce')
            backend_data = backend_data.dropna(subset=['时间'])

            backend_data = backend_data.sort_values('时间')

        

        daily_data_list = []

        cumulative_consumption = 0  # 累计消耗

        

        # 为每一天计算指标

        for _, row in backend_data.iterrows():

            date_str = row['时间'].strftime('%Y-%m-%d') if pd.notna(row['时间']) else '未知日期'
            
            # 修复：LTV sheet数据已经是美元，后台sheet数据需要汇率换算
            # 基础指标 - 消耗相关字段来自LTV sheet（已经是美元），其他金额字段来自后台sheet（需要汇率换算）
            # 注意：这里使用的是后台sheet数据，需要汇率换算
            total_consumption = pd.to_numeric(row.get('当日总流水', 0), errors='coerce') / self.EXCHANGE_RATE  # 来自后台sheet，需要汇率换算
            recharge_amount = pd.to_numeric(row.get('商城充值金额', 0), errors='coerce') / self.EXCHANGE_RATE  # 来自后台sheet，需要汇率换算

            recharge_count = pd.to_numeric(row.get('商城充值次数', 0), errors='coerce')  # 次数，不需要汇率换算

            recharge_users = pd.to_numeric(row.get('充值人数', 0), errors='coerce')  # 人数，不需要汇率换算

            new_users = pd.to_numeric(row.get('新增人员', 0), errors='coerce')  # 人数，不需要汇率换算

            first_recharge_users = pd.to_numeric(row.get('首充人数', 0), errors='coerce')  # 人数，不需要汇率换算

            first_level_users = pd.to_numeric(row.get('一级首充人数', 0), errors='coerce')  # 人数，不需要汇率换算

            

            # 调试信息：检查一级首充人数数据

            try:

                print(f"Debug: first_level_users = {first_level_users}, first_recharge_users = {first_recharge_users}, recharge_users = {recharge_users}")

            except UnicodeEncodeError:

                print(f"Debug: first_level_users = {first_level_users}, first_recharge_users = {first_recharge_users}, recharge_users = {recharge_users}")

            

            if first_level_users == 0:

                try:

                    print(f"Debug: first_level_users is 0, checking data source fields")

                    print(f"Debug: first_level_users raw value: {row.get('一级首充人数', 'field not found')}")
                except UnicodeEncodeError:

                    print("Debug: first_level_users is 0, checking data source")

                # 尝试其他可能的字段名

                for key in row.keys():

                    if '一级' in str(key) or 'level' in str(key).lower():

                        try:

                            print(f"Debug: Found possible field: {key} = {row.get(key)}")

                        except UnicodeEncodeError:

                            print("Debug: Found possible field")

            

            # 计算派生指标 - 金额字段需要除以汇率（18.7）

            first_recharge_amount = pd.to_numeric(row.get('首充用户总充值金额', 0), errors='coerce') / self.EXCHANGE_RATE  # 来自后台sheet，需要汇率换算

            old_user_amount = recharge_amount - first_recharge_amount

            old_user_count = recharge_users - first_recharge_users

            

            # 修复：后台sheet数据需要汇率换算验证

            print(f"Debug: 后台sheet数据汇率换算 - 充值金额: {recharge_amount}, 总消耗: {total_consumption}, 汇率: {self.EXCHANGE_RATE}")
            

            # 累计消耗

            cumulative_consumption += total_consumption

            

            # 成本计算

            first_recharge_cost = total_consumption / first_recharge_users if first_recharge_users > 0 else 0

            first_level_cost = total_consumption / first_level_users if first_level_users > 0 else 0

            

            # 人均指标

            avg_recharge_amount = recharge_amount / recharge_users if recharge_users > 0 else 0

            avg_recharge_count = recharge_count / recharge_users if recharge_users > 0 else 0

            first_recharge_avg = first_recharge_amount / first_recharge_users if first_recharge_users > 0 else 0

            old_user_avg = old_user_amount / old_user_count if old_user_count > 0 else 0

            

            # 比率计算

            charge_withdraw_amount = row.get('充提差', 0) / self.EXCHANGE_RATE  # 充提差也需要汇率换算

            charge_withdraw_ratio = charge_withdraw_amount / recharge_amount if recharge_amount > 0 else 0

            # 修复：老用户付费率 = (充值人数 - 首充人数) / 充值人数

            old_user_pay_rate = (recharge_users - first_recharge_users) / recharge_users if recharge_users > 0 else 0

            first_recharge_rate = first_recharge_users / new_users if new_users > 0 else 0

            

            # 从留存数据获取复登/复充率

            retention_rates = self._get_retention_rates(retention_data, date_str, first_recharge_users)

            

            # 从LTV数据获取LTV值

            ltv_values = self._get_ltv_values(ltv_data, date_str)

            

            # 从渠道数据获取复合列并拆分

            channel_metrics = self._get_channel_metrics(channel_data, date_str)

            

            daily_row = {

                '日期': date_str,

                '总消耗(U)': total_consumption,

                '首充成本(U)': first_recharge_cost,

                '一级首充成本(U)': first_level_cost,

                '充提差比': charge_withdraw_ratio,

                '总充提差(U)': row.get('充提差', 0) / self.EXCHANGE_RATE,  # 来自后台sheet，需要汇率换算

                '充值金额(U)': recharge_amount,

                '首充充值金额(U)': first_recharge_amount,

                '老用户充值金额(U)': old_user_amount,

                '人均充值金额(U)': avg_recharge_amount,

                '人均充值笔数': avg_recharge_count,

                '首充人均充值金额(U)': first_recharge_avg,

                '老用户人均充值金额U': old_user_avg,

                '老用户付费率': old_user_pay_rate,

                '14日LTV': ltv_values.get('14日', 0),

                '30日LTV': ltv_values.get('30日', 0),

                # 补齐所有留存日

                '首充次日复充率': retention_rates.get('首充次日复充率', 0),

                '首充3日 复充率': retention_rates.get('首充3日 复充率', 0),
                '首充7日 复充率': retention_rates.get('首充7日 复充率', 0),
                '首充30日 复充率': retention_rates.get('首充30日 复充率', 0),
                '首充次日复登率': retention_rates.get('首充次日复登率', 0),

                '首充3日复登率': retention_rates.get('首充3日复登率', 0),

                '首充7日复登率': retention_rates.get('首充7日复登率', 0),

                '首充30日复登率': retention_rates.get('首充30日复登率', 0),

                # 渠道数据复合列拆分

                '首充金额': channel_metrics.get('首充金额', first_recharge_amount),

                '首充人数': channel_metrics.get('首充人数', first_recharge_users),

                '一级首充金额': channel_metrics.get('一级首充金额', row.get('一级首充金额', 0) / self.EXCHANGE_RATE),  # 金额字段，需要汇率换算

                '一级首充人数': channel_metrics.get('一级首充人数', first_level_users),

                '非首充金额': channel_metrics.get('非首充金额', old_user_amount),

                '非首充人数': channel_metrics.get('非首充人数', old_user_count),

                '新增充值金额': channel_metrics.get('新增充值金额', 0),

                '新增充值人数': channel_metrics.get('新增充值人数', 0),

                '老用户充值金额': channel_metrics.get('老用户充值金额', old_user_amount),

                '老用户充值人数': channel_metrics.get('老用户充值人数', old_user_count),

                # 其他渠道指标

                '当日消耗($)': channel_metrics.get('当日消耗($)', total_consumption),

                '注册成本': channel_metrics.get('注册成本', 0),

                'ROI': channel_metrics.get('ROI', 0),

                'ROAS': channel_metrics.get('ROAS', 0),

                '非一级首充人数/首充人数': (first_recharge_users - first_level_users) / first_recharge_users if first_recharge_users > 0 else 0,
                '非一级首充人数/充值人数': (first_recharge_users - first_level_users) / recharge_users if recharge_users > 0 else 0,
                '首充转化率': first_recharge_rate,

                '新增用户': new_users,

                '充值人数': recharge_users,

                '投注用户数': row.get('投注人数', 0),

                '充投用户数': row.get('充值投注人数', 0),

                '首充次日复投率': row.get('首充次日复投率', 0),

                '首充3日复投率': row.get('首充3日复投率', 0),

                '首充7日复投率': row.get('首充7日复投率', 0),

                '投注金额(U)': round(row.get('当日总流水', 0) / self.EXCHANGE_RATE, 2),  # 来自后台sheet，需要汇率换算

                '出入人数比': row.get('提现人数', 0) / recharge_users if recharge_users > 0 else 0,

                '游戏盈亏投注比': row.get('当日总盈利', 0) / row.get('当日总流水', 1) if row.get('当日总流水', 0) > 0 else 0,  # 比率，不需要汇率换算

                '投充比': row.get('今日投充比', 0),

                '佣金金额(U)': row.get('实际到账金币', 0) / self.EXCHANGE_RATE,  # 金额字段，需要汇率换算

                '彩金赠送充值比': (row.get('总赠送', 0) / self.EXCHANGE_RATE) / recharge_amount if recharge_amount > 0 else 0,  # 总赠送需要汇率换算

                '历史营收(历史充提差-历史消耗)': (row.get('充提差', 0) / self.EXCHANGE_RATE) - cumulative_consumption,  # 历史充提差 - 累计消耗

                '历史充提差': row.get('充提差', 0) / self.EXCHANGE_RATE,  # 来自后台sheet，需要汇率换算

                '历史消耗': cumulative_consumption,  # 累计的总消耗（来自LTV sheet，已经是美元）

            }

            daily_data_list.append(daily_row)

        

        # 计算总计和日均

        if daily_data_list:

            df = pd.DataFrame(daily_data_list)

            total_data, avg_data = self._calculate_summary_metrics(df)

            return pd.concat([df, pd.DataFrame([total_data, avg_data])], ignore_index=True)

        

        return self._get_mock_data()

    

    def _aggregate_retention_from_ltv(self, df_dict, date_str):

        """从各个渠道LTV数据中汇总复登率"""

        aggregated_rates = {}

        

        # 各个渠道的LTV sheet

        ltv_sheets = ['短信LTV', '网红LTV', '投放LTV']

        

        # 需要汇总的复登率字段

        retention_fields = ['注册复登', '首充复登', '3日注册复登', '3日首充复登']

        

        for field in retention_fields:

            total_users = 0

            total_retention_users = 0

            

            for sheet_name in ltv_sheets:

                if sheet_name in df_dict:

                    df = df_dict[sheet_name]

                    if not df.empty and '时间' in df.columns and field in df.columns:

                        # 查找匹配日期的数据

                        try:

                            # 转换日期格式进行匹配

                            df['时间'] = pd.to_datetime(df['时间'], format='%m/%d/%Y', errors='coerce')

                            target_date = pd.to_datetime(date_str)

                            date_data = df[df['时间'].dt.date == target_date.date()]

                            

                            if not date_data.empty:

                                # 解析复登数据格式：'19.8%/252' -> 百分比和人数

                                retention_str = date_data[field].iloc[0]

                                if isinstance(retention_str, str) and '/' in retention_str:

                                    try:

                                        percentage_part, users_part = retention_str.split('/')

                                        percentage = float(percentage_part.replace('%', '')) / 100

                                        users = int(users_part)

                                        

                                        # 计算该渠道的复登人数

                                        retention_users = int(users * percentage)

                                        

                                        total_retention_users += retention_users

                                        total_users += users

                                        

                                        # 静默处理，避免编码问题

                                        pass

                                    except:

                                        # 静默处理，避免编码问题

                                        pass

                        except Exception as e:

                            # 静默处理，避免编码问题

                            pass

            

            # 计算汇总复登率

            if total_users > 0:

                aggregated_rate = total_retention_users / total_users

                aggregated_rates[field] = aggregated_rate

                # 静默处理，避免编码问题

                pass

            else:

                aggregated_rates[field] = 0

                # 静默处理，避免编码问题

                pass

        

        return aggregated_rates



    def _get_retention_rates(self, retention_data, date_str, first_recharge_users):

        """从留存数据获取复登/复充率 - 使用正确的计算公式"""

        rates = {}

        

        # 调试信息：检查留存数据结构

        try:

            print(f"Debug: Checking retention data for date {date_str}")

            print(f"Debug: Login retention data shape: {retention_data['login'].shape}")

            print(f"Debug: Recharge retention data shape: {retention_data['recharge'].shape}")

            if not retention_data['login'].empty:

                print(f"Debug: Login retention columns: {list(retention_data['login'].columns)[:10]}")
            if not retention_data['recharge'].empty:

                print(f"Debug: Recharge retention columns: {list(retention_data['recharge'].columns)[:10]}")
                # 检查是否有时间列

                if '时间' in retention_data['recharge'].columns:

                    print(f"Debug: Found time column in recharge data")

                    # 检查时间列的数据类型和内容

                    time_col = retention_data['recharge']['时间']

                    print(f"Debug: Time column type: {time_col.dtype}")

                    print(f"Debug: Time column sample: {time_col.head(3).tolist()}")

                else:

                    print(f"Debug: No time column found in recharge data")

        except Exception as e:

            print(f"Debug: Retention data check failed for date {date_str}: {e}")

        

        # 从登录留存数据获取复登率

        if not retention_data['login'].empty:

            login_df = retention_data['login']

            try:

                print(f"Debug: Login retention data columns: {list(login_df.columns)[:10]}")
            except:

                print(f"Debug: Login retention data has {len(login_df.columns)} columns")
            if '时间' in login_df.columns:

                # 尝试不同的日期匹配方式

                date_data = None

                try:

                    # 方式1：处理数据源中的日期格式（2025-01-09, 2025-02-09等）

                    login_df['时间'] = pd.to_datetime(login_df['时间'], errors='coerce')
                    target_date = pd.to_datetime(date_str)
                    

                    # 尝试匹配年月日

                    date_data = login_df[login_df['时间'].dt.date == target_date.date()]

                    print(f"Debug: Login date match found {len(date_data)} rows")

                    

                    # 如果没找到匹配，尝试匹配月份和日期（忽略年份）

                    if len(date_data) == 0:

                        target_month = target_date.month

                        target_day = target_date.day

                        date_data = login_df[

                            (login_df['时间'].dt.month == target_month) & 

                            (login_df['时间'].dt.day == target_day)

                        ]

                        print(f"Debug: Login month-day match found {len(date_data)} rows")

                        

                        # 如果还是没找到，尝试交换月份和日期（处理MM/DD vs DD/MM格式）

                        if len(date_data) == 0:

                            date_data = login_df[

                                (login_df['时间'].dt.month == target_day) & 

                                (login_df['时间'].dt.day == target_month)

                            ]

                            print(f"Debug: Login swapped month-day match found {len(date_data)} rows")

                    

                    # 如果还是没找到，尝试字符串匹配

                    if len(date_data) == 0:

                        # 尝试匹配日期字符串

                        date_str_formatted = target_date.strftime('%Y-%m-%d')

                        date_data = login_df[login_df['时间'].astype(str).str.contains(date_str_formatted, na=False)]

                        print(f"Debug: Login string match found {len(date_data)} rows")

                except Exception as e:

                    print(f"Debug: Login date match failed: {e}")

                    try:

                        # 方式2：尝试其他日期格式

                        login_df['时间'] = pd.to_datetime(login_df['时间'], errors='coerce')
                        target_date = pd.to_datetime(date_str)
                        date_data = login_df[login_df['时间'].dt.date == target_date.date()]

                        print(f"Debug: Login alternative date match found {len(date_data)} rows")

                    except Exception as e2:

                        print(f"Debug: Login alternative date match failed: {e2}")

                        try:

                            # 方式3：直接字符串匹配

                            date_data = login_df[login_df['时间'].astype(str).str.contains(date_str, na=False)]

                            print(f"Debug: Login string match found {len(date_data)} rows")

                        except Exception as e3:

                            print(f"Debug: Login string match failed: {e3}")

                            pass

                

                if date_data is not None and not date_data.empty:

                    print(f"Debug: Found matching date data for {date_str}")

                    # 计算复登率：从百分比数据直接获取

                    # 根据数据结构：留存率=次日，Unnamed: 3=3日，Unnamed: 4=4日，Unnamed: 5=5日，Unnamed: 6=6日，Unnamed: 7=7日
                    login_retention_mapping = {

                        '次日': '留存率',
                        '3日': 'Unnamed: 3', 
                        '7日': 'Unnamed: 7'
                    }
                    
                    for day, col_name in login_retention_mapping.items():

                        if col_name in date_data.columns and not date_data.empty:

                            # 获取百分比字符串并转换为小数

                            percentage_str = date_data[col_name].iloc[0]

                            if isinstance(percentage_str, str) and '%' in percentage_str:

                                # 移除%并转换为小数

                                percentage_value = float(percentage_str.replace('%', '')) / 100

                                rates[f'首充{day}复登率'] = percentage_value

                                try:

                                    print(f"Debug: {day}复登率 = {percentage_str} = {percentage_value}")
                                except:

                                    print(f"Debug: {day}复登率 calculated")
                            else:

                                rates[f'首充{day}复登率'] = 0

                        else:

                            rates[f'首充{day}复登率'] = 0

                else:

                    print(f"Debug: No matching date data found for {date_str}")

                    retention_days = ['次日', '3日', '7日']

                    for day in retention_days:

                        rates[f'首充{day}复登率'] = 0

        

        # 从充值留存数据获取复充率

        if not retention_data['recharge'].empty:

            recharge_df = retention_data['recharge']

            try:

                print(f"Debug: Recharge retention data columns: {list(recharge_df.columns)[:10]}")
            except:

                print(f"Debug: Recharge retention data has {len(recharge_df.columns)} columns")
            

            # 查找时间列

            time_col = None

            for col in recharge_df.columns:

                if '时间' in str(col) or 'date' in str(col).lower():

                    time_col = col

                    break

            

            if time_col is not None:

                try:

                    print(f"Debug: Found time column: {time_col}")

                except:

                    print(f"Debug: Found time column (encoding issue)")

                

                # 尝试不同的日期匹配方式
                date_data = None

                try:

                    # 方式1：处理数据源中的日期格式（2025-01-09, 2025-02-09等）
                    recharge_df[time_col] = pd.to_datetime(recharge_df[time_col], errors='coerce')
                    target_date = pd.to_datetime(date_str)
                    
                    # 尝试匹配年月日
                    date_data = recharge_df[recharge_df[time_col].dt.date == target_date.date()]

                    print(f"Debug: Date match found {len(date_data)} rows")
                    

                    # 如果没找到匹配，尝试匹配月份和日期（忽略年份）
                    if len(date_data) == 0:

                        target_month = target_date.month

                        target_day = target_date.day

                        date_data = recharge_df[

                            (recharge_df[time_col].dt.month == target_month) & 

                            (recharge_df[time_col].dt.day == target_day)

                        ]

                        print(f"Debug: Month-day match found {len(date_data)} rows")

                        

                        # 如果还是没找到，尝试交换月份和日期（处理MM/DD vs DD/MM格式）
                        if len(date_data) == 0:

                            date_data = recharge_df[

                                (recharge_df[time_col].dt.month == target_day) & 

                                (recharge_df[time_col].dt.day == target_month)

                            ]

                            print(f"Debug: Recharge swapped month-day match found {len(date_data)} rows")
                    

                    # 如果还是没找到，尝试字符串匹配

                    if len(date_data) == 0:

                        # 尝试匹配日期字符串

                        date_str_formatted = target_date.strftime('%Y-%m-%d')

                        date_data = recharge_df[recharge_df[time_col].astype(str).str.contains(date_str_formatted, na=False)]

                        print(f"Debug: Recharge string match found {len(date_data)} rows")

                except Exception as e:

                    print(f"Debug: Date match failed: {e}")

                    try:

                        # 方式2：尝试其他日期格式

                        recharge_df[time_col] = pd.to_datetime(recharge_df[time_col], errors='coerce')
                        target_date = pd.to_datetime(date_str)
                        date_data = recharge_df[recharge_df[time_col].dt.date == target_date.date()]

                        print(f"Debug: Alternative date match found {len(date_data)} rows")

                    except Exception as e2:

                        print(f"Debug: Alternative date match failed: {e2}")

                        try:

                            # 方式3：直接字符串匹配

                            date_data = recharge_df[recharge_df[time_col].astype(str).str.contains(date_str, na=False)]

                            print(f"Debug: String match found {len(date_data)} rows")

                        except Exception as e3:

                            print(f"Debug: String match failed: {e3}")

                            pass

                

                if date_data is not None and not date_data.empty:

                    print(f"Debug: Found matching recharge date data for {date_str}")

                    # 计算复充率：从百分比数据直接获取

                    # 根据数据结构：留存率=次日，Unnamed: 3=3日，Unnamed: 4=4日，Unnamed: 5=5日，Unnamed: 6=6日，Unnamed: 7=7日，Unnamed: 8=30日
                    retention_mapping = {
                        '次日': '留存率',
                        '3日': 'Unnamed: 3', 
                        '7日': 'Unnamed: 7',
                        '30日': 'Unnamed: 8'
                    }
                    

                    for day, col_name in retention_mapping.items():

                        if col_name in date_data.columns and not date_data.empty:

                            # 获取百分比字符串并转换为小数
                            percentage_str = date_data[col_name].iloc[0]
                            if isinstance(percentage_str, str) and '%' in percentage_str:
                                # 移除%并转换为小数
                                percentage_value = float(percentage_str.replace('%', '')) / 100
                                rates[f'首充{day}复充率'] = percentage_value

                                try:

                                    print(f"Debug: {day}复充率 = {percentage_str} = {percentage_value}")
                                except:

                                    print(f"Debug: {day}复充率 calculated")
                            else:

                                rates[f'首充{day}复充率'] = 0

                else:
                    print(f"Debug: No matching recharge date data found for {date_str}")
                    # 尝试使用第一行数据作为示例
                    if not recharge_df.empty:
                        print(f"Debug: Using first row as sample data")
                        retention_days = ['次日', '3日', '7日', '30日']
                        for day in retention_days:
                            # 查找对应的列
                            day_col = None
                            for col in recharge_df.columns:
                                if day in str(col):
                                    day_col = col
                                    break
                            
                            if day_col and first_recharge_users > 0:
                                # 使用第一行数据
                                recharge_users = pd.to_numeric(recharge_df[day_col].iloc[0], errors='coerce') if not recharge_df.empty else 0
                                if pd.isna(recharge_users):
                                    recharge_users = 0
                                rates[f'首充{day}复充率'] = recharge_users / first_recharge_users
                                try:
                                    print(f"Debug: Sample retention rate = {recharge_users} / {first_recharge_users} = {rates[f'首充{day}复充率']}")
                                except:
                                    print(f"Debug: Sample retention rate calculated")
                            else:

                                rates[f'首充{day}复充率'] = 0

                    else:

                        retention_days = ['次日', '3日', '7日', '30日']

                        for day in retention_days:

                            rates[f'首充{day}复充率'] = 0

            else:

                print(f"Debug: No time column found in recharge data")

                retention_days = ['次日', '3日', '7日', '30日']

                for day in retention_days:

                    rates[f'首充{day}复充率'] = 0

        

        # 计算复投率（从投注留存数据获取）

        # 尝试从投注相关的sheet获取复投率数据

        if not retention_data['recharge'].empty:

            # 如果充值留存数据中有投注相关列，使用它

            recharge_df = retention_data['recharge']

            if '时间' in recharge_df.columns:

                date_data = recharge_df[recharge_df['时间'].astype(str).str.contains(date_str, na=False)]

                if not date_data.empty:

                    # 查找投注相关的列

                    bet_columns = [col for col in date_data.columns if '投注' in col or 'bet' in col.lower()]

                    if bet_columns:

                        retention_days = ['次日', '3日', '7日']

                        for day in retention_days:

                            # 查找对应的投注列

                            bet_col = None

                            for col in bet_columns:

                                if day in col:

                                    bet_col = col

                                    break

                            

                            if bet_col and first_recharge_users > 0:

                                bet_users = date_data[bet_col].iloc[0] if not date_data.empty else 0

                                rates[f'首充{day}复投率'] = bet_users / first_recharge_users

                            else:

                                rates[f'首充{day}复投率'] = 0

                    else:

                        # 如果没有投注列，设为0

                        retention_days = ['次日', '3日', '7日']

                        for day in retention_days:

                            rates[f'首充{day}复投率'] = 0

                else:

                    # 如果没有找到对应日期的数据，设为0

                    retention_days = ['次日', '3日', '7日']

                    for day in retention_days:

                        rates[f'首充{day}复投率'] = 0

            else:

                # 如果没有时间列，设为0

                retention_days = ['次日', '3日', '7日']

                for day in retention_days:

                    rates[f'首充{day}复投率'] = 0

        else:

            # 如果没有留存数据，设为0

            retention_days = ['次日', '3日', '7日']

            for day in retention_days:

                rates[f'首充{day}复投率'] = 0

        

        return rates

    

    def _get_ltv_values(self, ltv_data, date_str):

        """从LTV数据获取LTV值 - 修复：使用表头文本识别列"""

        values = {}

        

        if not ltv_data.empty and '时间' in ltv_data.columns:

            date_data = ltv_data[ltv_data['时间'].astype(str).str.contains(date_str, na=False)]
            if not date_data.empty:

                # 修复：根据表头文本识别列，不依赖自动命名

                ltv_periods = ['14日', '30日', '60日']

                

                for period in ltv_periods:

                    # 查找包含该周期的金额列

                    amount_col = None

                    for col in date_data.columns:

                        if period in str(col) and ('金额' in str(col) or 'amount' in str(col).lower()):

                            amount_col = col

                            break

                    

                    if amount_col and amount_col in date_data.columns:

                        try:

                            values[period] = pd.to_numeric(date_data[amount_col].iloc[0], errors='coerce')

                            if pd.isna(values[period]):

                                values[period] = 0

                        except:

                            values[period] = 0

                    else:

                        values[period] = 0

        

        return values

    

    def _get_channel_metrics(self, channel_data, date_str):

        """从渠道数据获取指标并拆分复合列"""

        metrics = {}

        

        if not channel_data.empty and '日期' in channel_data.columns:

            date_data = channel_data[channel_data['日期'].astype(str).str.contains(date_str, na=False)]

            if not date_data.empty:

                # 拆分复合列：首充、一级首充、非首充、新增充值等

                composite_columns = {

                    '首充': ['首充金额', '首充人数'],

                    '一级首充': ['一级首充金额', '一级首充人数'], 

                    '非首充': ['非首充金额', '非首充人数'],

                    '新增充值': ['新增充值金额', '新增充值人数'],

                    '老用户充值': ['老用户充值金额', '老用户充值人数']

                }

                

                for base_name, [amount_col, count_col] in composite_columns.items():

                    # 尝试从不同可能的列名获取数据

                    amount_value = 0

                    count_value = 0

                    

                    # 查找金额列 - 修复：支持复合列解析

                    for col in channel_data.columns:

                        if base_name in col and ('金额' in col or 'amount' in col.lower()):

                            if col in date_data.columns:

                                # 检查是否为复合列（包含|分隔符）

                                if '|' in str(date_data[col].iloc[0] if not date_data.empty else ''):

                                    # 使用正则分隔符解析复合列

                                    parts = date_data[col].astype(str).str.split(r'\s*\|\s*', expand=True)

                                    amount_value = pd.to_numeric(parts[0], errors='coerce').sum()

                                else:

                                    # 普通列直接求和

                                    amount_value = pd.to_numeric(date_data[col], errors='coerce').sum()

                            else:

                                amount_value = 0

                            break

                    

                    # 查找人数列 - 修复：支持复合列解析

                    for col in channel_data.columns:

                        if base_name in col and ('人数' in col or 'count' in col.lower() or '用户' in col):

                            if col in date_data.columns:

                                # 检查是否为复合列（包含|分隔符）

                                if '|' in str(date_data[col].iloc[0] if not date_data.empty else ''):

                                    # 使用正则分隔符解析复合列

                                    parts = date_data[col].astype(str).str.split(r'\s*\|\s*', expand=True)

                                    count_value = pd.to_numeric(parts[1], errors='coerce').sum()

                                else:

                                    # 普通列直接求和

                                    count_value = pd.to_numeric(date_data[col], errors='coerce').sum()

                            else:

                                count_value = 0

                            break

                    

                    metrics[amount_col] = amount_value / self.EXCHANGE_RATE if amount_value > 0 else 0

                    metrics[count_col] = count_value

                

                # 获取其他渠道指标

                other_metrics = {

                    '当日消耗($)': '当日消耗',

                    '注册成本': '新增用户单价',

                    '首充成本': '首充成本',

                    '一级首充成本': '一级首充成本',

                    '充提差': '充提差',

                    '充值金額': '充值金额',

                    '新增用户': '新增用户',

                    '充值人数': '充值人数',

                    'ROI': 'ROI',

                    'ROAS': 'ROAS'

                }

                

                for target_col, source_col in other_metrics.items():

                    if source_col in date_data.columns:

                        if target_col in ['当日消耗($)', '充提差', '充值金額', '新增用户', '充值人数']:

                            # 求和类指标

                            metrics[target_col] = pd.to_numeric(date_data[source_col], errors='coerce').sum()

                        else:

                            # 平均类指标

                            metrics[target_col] = pd.to_numeric(date_data[source_col], errors='coerce').mean()

                    else:

                        metrics[target_col] = 0

        

        return metrics

    

    def _add_summary_rows(self, df, title):

        """为短信日报和投放明细添加总计和日均行"""

        if df.empty:

            return df

            

        # 创建总计行

        total_row = {'日期': '总计'}

        

        # 根据报告类型确定需要汇总的列

        if '短信日报' in title:

            # 短信日报的汇总列

            sum_columns = ['当日消耗($)', '充值金額', '首充金额', '老用户金额', '新增用户', 

                          '首充付费人数', '一级首充人数', '充值人数']

            avg_columns = ['注册成本', '首充成本', '一级首充成本', '充值人均', '首充人均', 

                          '老用户人均', '老用户付费率', '14日LTV', '30日LTV']

        elif '投放明细' in title:

            # 投放明细的汇总列

            sum_columns = ['当日消耗($)', '充值金額', '新增用户', '首充付费人数', '一级首充人数']

            avg_columns = ['注册成本', '首充成本', '一级首充成本', '充值人均', '首充人均', 

                          '老用户人均', '老用户付费率']

        

        # 计算总计行

        for col in df.columns:

            if col == '日期':

                total_row[col] = '总计'

            elif col in sum_columns and col in df.columns:

                try:

                    # 尝试转换为数字后求和

                    numeric_data = pd.to_numeric(df[col], errors='coerce')

                    total_row[col] = numeric_data.sum()

                except:

                    total_row[col] = ''

            elif col in avg_columns and col in df.columns:

                try:

                    # 尝试转换为数字后求平均

                    numeric_data = pd.to_numeric(df[col], errors='coerce')

                    total_row[col] = numeric_data.mean()

                except:

                    total_row[col] = ''

            else:

                # 对于其他列，尝试求和，如果失败则取平均值

                try:

                    if pd.api.types.is_numeric_dtype(df[col]):

                        total_row[col] = df[col].sum()

                    else:

                        total_row[col] = ''

                except:

                    total_row[col] = ''

        

        # 创建日均行

        avg_row = {'日期': '日均'}

        for col in df.columns:

            if col == '日期':

                avg_row[col] = '日均'

            elif col in sum_columns and col in df.columns:

                # 对于求和类指标，计算日均

                try:

                    numeric_data = pd.to_numeric(df[col], errors='coerce')

                    avg_row[col] = numeric_data.sum() / len(df) if len(df) > 0 else 0

                except:

                    avg_row[col] = 0

            elif col in avg_columns and col in df.columns:

                # 对于平均类指标，保持平均值

                try:

                    numeric_data = pd.to_numeric(df[col], errors='coerce')

                    avg_row[col] = numeric_data.mean()

                except:

                    avg_row[col] = ''

            else:

                # 对于其他列，尝试计算平均值

                try:

                    if pd.api.types.is_numeric_dtype(df[col]):

                        avg_row[col] = df[col].mean()

                    else:

                        avg_row[col] = ''

                except:

                    avg_row[col] = ''

        

        # 合并数据

        total_df = pd.DataFrame([total_row])

        avg_df = pd.DataFrame([avg_row])

        result_df = pd.concat([df, total_df, avg_df], ignore_index=True)

        # 填充空值为0，保留两位小数
        result_df = result_df.fillna(0)
        
        for col in result_df.columns:
            if result_df[col].dtype in ['float64', 'int64']:
                if col not in ['日期', '时间']:
                    result_df[col] = result_df[col].round(2)

        

        try:

            print(f"  Added summary rows for {title}: {len(result_df)} total rows")

        except UnicodeEncodeError:

            print(f"  Added summary rows: {len(result_df)} total rows")

        return result_df



    def _calculate_summary_metrics(self, df):

        """计算总计和日均指标"""

        # 总计数据 - 按正确口径聚合

        total_data = {'日期': '总计'}

        

        # Sum类指标

        sum_columns = ['总消耗(U)', '充值金额(U)', '首充充值金额(U)', '老用户充值金额(U)', 

                      '总充提差(U)', '新增注册人数', '首充人数', '一级首充人数', '充值人数',

                      '投注用户数', '充投用户数', '投注金额(U)', '佣金金额(U)',

                      '历史营收(历史充提差-历史消耗)', '历史充提差', '历史消耗',

                      # 新增的复合列拆分字段

                      '首充金额', '一级首充金额', '非首充金额', '新增充值金额', '老用户充值金额',

                      '当日消耗($)', '首充人数', '一级首充人数', '非首充人数', '新增充值人数', '老用户充值人数']

        

        for col in sum_columns:

            if col in df.columns:

                total_data[col] = df[col].sum()

        

        # Weighted类指标 - 加权计算

        if '首充人数' in df.columns and df['首充人数'].sum() > 0:

            # 所有留存率都按首充人数加权

            retention_columns = [

                '首充次日复充率', '首充3日 复充率', '首充4日复充率', '首充5日复充率', 
                '首充6日复充率', '首充7日 复充率', '首充30日 复充率',
                '首充次日复登率', '首充3日复登率', '首充4日复登率', '首充5日复登率',

                '首充6日复登率', '首充7日复登率', '首充30日复登率'

            ]

            

            for col in retention_columns:

                if col in df.columns:

                    # 确保数据类型正确

                    col_values = pd.to_numeric(df[col], errors='coerce')

                    weight_values = pd.to_numeric(df['首充人数'], errors='coerce')

                    total_data[col] = (col_values * weight_values).sum() / weight_values.sum()

                else:

                    total_data[col] = 0

        

        # 派生指标 - 重新计算

        if total_data['充值人数'] > 0:

            total_data['人均充值金额(U)'] = total_data['充值金额(U)'] / total_data['充值人数']

            total_data['人均充值笔数'] = df['人均充值笔数'].sum() / len(df)  # 日均笔数

        else:

            total_data['人均充值金额(U)'] = 0

            total_data['人均充值笔数'] = 0

        

        if total_data['首充人数'] > 0:

            total_data['首充人均充值金额(U)'] = total_data['首充充值金额(U)'] / total_data['首充人数']

        else:

            total_data['首充人均充值金额(U)'] = 0

        

        if total_data['充值人数'] > total_data['首充人数']:

            total_data['老用户人均充值金额U'] = total_data['老用户充值金额(U)'] / (total_data['充值人数'] - total_data['首充人数'])

        else:

            total_data['老用户人均充值金额U'] = 0

        

        # 其他派生指标

        total_data['充提差比'] = total_data['总充提差(U)'] / total_data['充值金额(U)'] if total_data['充值金额(U)'] > 0 else 0

        total_data['老用户付费率'] = (total_data['充值人数'] - total_data['首充人数']) / total_data['充值人数'] if total_data['充值人数'] > 0 else 0

        total_data['首充数转化率'] = total_data['首充人数'] / total_data['新增注册人数'] if total_data['新增注册人数'] > 0 else 0

        total_data['非一级首充人数/首充人数'] = (total_data['首充人数'] - total_data['一级首充人数']) / total_data['首充人数'] if total_data['首充人数'] > 0 else 0

        total_data['非一级首充人数/充值人数'] = (total_data['首充人数'] - total_data['一级首充人数']) / total_data['充值人数'] if total_data['充值人数'] > 0 else 0

        

        # 成本指标 - 重新计算

        total_data['首充成本(U)'] = total_data['总消耗(U)'] / total_data['首充人数'] if total_data['首充人数'] > 0 else 0

        total_data['一级首充成本(U)'] = total_data['总消耗(U)'] / total_data['一级首充人数'] if total_data['一级首充人数'] > 0 else 0

        

        # 日均数据

        days = len(df)

        avg_data = {'日期': '日均'}

        for key, value in total_data.items():

            if key != '日期':

                if key in sum_columns:

                    avg_data[key] = value / days

                else:

                    avg_data[key] = value  # 比率类保持原值

        

        return total_data, avg_data

    

    def _get_mock_data(self):

        """获取模拟数据（当没有真实数据时）"""

        return pd.DataFrame({

            '日期': ['2025-10-15', '2025-10-16', '2025-10-17', '2025-10-18', '总计', '日均'],

            '总消耗(U)': [15000, 18000, 12000, 16000, 61000, 15250],

            '首充成本(U)': [50.0, 55.0, 50.0, 50.0, 50.0, 50.0],

            '一级首充成本(U)': [60.0, 60.0, 60.0, 59.3, 59.8, 59.8],

            '充提差比': [0.11, 0.12, 0.10, 0.11, 0.11, 0.11],

            '总充提差(U)': [5000, 6000, 4000, 5000, 20000, 5000],

            '充值金额(U)': [45000, 52000, 38000, 48000, 183000, 45750],

            '首充充值金额(U)': [18000, 21000, 15000, 19000, 73000, 18250],

            '老用户充值金额(U)': [27000, 31000, 23000, 29000, 110000, 27500],

            '人均充值金额(U)': [100.0, 96.3, 105.6, 100.0, 100.0, 100.0],

            '人均充值笔数': [2.5, 2.8, 2.2, 2.6, 2.525, 2.525],

            '首充人均充值金额(U)': [60.0, 58.3, 62.5, 59.4, 59.8, 59.8],

            '老用户人均充值金额U': [60.0, 57.4, 63.9, 60.4, 60.1, 60.1],

            '老用户付费率': [0.15, 0.18, 0.12, 0.16, 0.1525, 0.1525],

            '14日LTV': [45.2, 52.1, 38.7, 48.3, 46.075, 46.075],

            '30日LTV': [68.5, 78.9, 58.2, 72.1, 69.425, 69.425],

            # 补齐所有留存日

            '首充次日复充率': [0.25, 0.28, 0.22, 0.26, 0.2525, 0.2525],

            '首充3日 复充率': [0.35, 0.38, 0.32, 0.36, 0.3525, 0.3525],
            '首充4日复充率': [0.40, 0.43, 0.37, 0.41, 0.4025, 0.4025],

            '首充5日复充率': [0.42, 0.45, 0.39, 0.43, 0.4225, 0.4225],

            '首充6日复充率': [0.44, 0.47, 0.41, 0.45, 0.4425, 0.4425],

            '首充7日 复充率': [0.45, 0.48, 0.42, 0.46, 0.4525, 0.4525],
            '首充30日 复充率': [0.55, 0.58, 0.52, 0.56, 0.5525, 0.5525],
            '首充次日复登率': [0.65, 0.68, 0.62, 0.66, 0.6525, 0.6525],

            '首充3日复登率': [0.75, 0.78, 0.72, 0.76, 0.7525, 0.7525],

            '首充4日复登率': [0.80, 0.83, 0.77, 0.81, 0.8025, 0.8025],

            '首充5日复登率': [0.82, 0.85, 0.79, 0.83, 0.8225, 0.8225],

            '首充6日复登率': [0.84, 0.87, 0.81, 0.85, 0.8425, 0.8425],

            '首充7日复登率': [0.85, 0.88, 0.82, 0.86, 0.8525, 0.8525],

            '首充30日复登率': [0.90, 0.93, 0.87, 0.91, 0.9025, 0.9025],

            # 复合列拆分

            '首充金额': [18000, 21000, 15000, 19000, 73000, 18250],

            '首充人数': [300, 360, 240, 320, 1220, 305],

            '一级首充金额': [15000, 18000, 12000, 16000, 61000, 15250],

            '一级首充人数': [250, 300, 200, 270, 1020, 255],

            '非首充金额': [27000, 31000, 23000, 29000, 110000, 27500],

            '非首充人数': [150, 180, 120, 160, 610, 152.5],

            '新增充值金额': [0, 0, 0, 0, 0, 0],

            '新增充值人数': [0, 0, 0, 0, 0, 0],

            '老用户充值金额': [27000, 31000, 23000, 29000, 110000, 27500],

            '老用户充值人数': [150, 180, 120, 160, 610, 152.5],

            # 其他渠道指标

            '当日消耗($)': [15000, 18000, 12000, 16000, 61000, 15250],

            '注册成本': [15.0, 15.0, 15.0, 14.5, 14.875, 14.875],

            'ROI': [3.0, 2.9, 3.2, 3.0, 3.0, 3.0],

            'ROAS': [3.0, 2.9, 3.2, 3.0, 3.0, 3.0],

            '非一级首充人数/首充人数': [0.17, 0.17, 0.17, 0.17, 0.17, 0.17],

            '非一级首充人数/充值人数': [0.11, 0.11, 0.11, 0.11, 0.11, 0.11],

            '首充数转化率': [0.30, 0.30, 0.30, 0.30, 0.30, 0.30],

            '新增注册人数': [1000, 1200, 800, 1100, 4100, 1025],

            '充值人数': [450, 540, 360, 480, 1830, 457.5],

            '投注用户数': [400, 480, 320, 430, 1630, 407.5],

            '充投用户数': [350, 420, 280, 370, 1420, 355],

            '首充次日复投率': [0.20, 0.22, 0.18, 0.21, 0.2025, 0.2025],

            '首充3日复投率': [0.30, 0.32, 0.28, 0.31, 0.3025, 0.3025],

            '首充7日复投率': [0.40, 0.42, 0.38, 0.41, 0.4025, 0.4025],

            '投注金额(U)': [25000, 30000, 20000, 27000, 102000, 25500],

            '出入人数比': [0.78, 0.82, 0.75, 0.80, 0.7875, 0.7875],

            '游戏盈亏投注比': [0.85, 0.88, 0.82, 0.86, 0.8525, 0.8525],

            '投充比': [0.56, 0.60, 0.52, 0.58, 0.565, 0.565],

            '佣金金额(U)': [5000, 6000, 4000, 5400, 20400, 5100],

            '彩金赠送充值比': [0.12, 0.15, 0.10, 0.13, 0.125, 0.125],

            '历史营收(历史充提差-历史消耗)': [25000, 30000, 20000, 27000, 102000, 25500],

            '历史充提差': [30000, 36000, 24000, 32000, 122000, 30500],

            '历史消耗': [5000, 6000, 4000, 5000, 20000, 5000],

        })

    

    def create_excel_report(self, df_dict, title, filename):

        """创建Excel报表 - 从final_report_v4.xlsx读取数据"""

        print("Generating report...")

        

        # 从df_dict中获取对应sheet的数据

        # 创建sheet名称映射，处理编码问题

        matched_sheet = None

        

        # 精确匹配逻辑

        if '产品二-VNL日报' in title:

            # 产品二-VNL日报需要特殊处理，使用所有sheet的数据

            matched_sheet = None  # 不使用单一sheet数据，而是使用所有数据

        elif 'VNL大盘日报' in title:

            # VNL大盘日报需要特殊处理，使用汇总数据而不是原始数据

            matched_sheet = None  # 不使用原始sheet数据

        elif 'VNL短信日报' in title:

            # 使用产品二文件的完整字段作为模板
            matched_sheet = '短信'
        elif 'VNL网红日报' in title:

            # 使用产品二文件的完整字段作为模板
            matched_sheet = '网红'
        elif 'VNL投放日报' in title:

            # 使用产品二文件的完整字段作为模板
            matched_sheet = '投放'
        elif 'VNL投放明细' in title:

            matched_sheet = '后台'  # 使用后台数据，有37列，足够支持31个字段
        
        # 如果精确匹配失败，尝试模糊匹配
        if matched_sheet is None or matched_sheet not in df_dict:
            temp_match = None
            for sheet_name, df in df_dict.items():

                if title in sheet_name or any(key in sheet_name for key in ['投放', '短信', '网红', '明细', '大盘'] if key in title):

                    temp_match = sheet_name

                    break
            
            # 只有找到匹配才更新matched_sheet，否则设为None
            if temp_match and temp_match in df_dict:
                matched_sheet = temp_match
            else:
                matched_sheet = None

        

        if matched_sheet is None:
            if '产品二-VNL日报' in title:

                # 产品二-VNL日报特殊处理：使用所有sheet数据

                print("  Generating 产品二-VNL日报 with all sheets...")
                df = None  # 将使用所有sheet数据

            elif 'VNL大盘日报' in title:

                # VNL大盘日报特殊处理：生成汇总数据

                print("  Generating VNL daily summary data...")

                df = self._generate_daily_summary_data(df_dict)

            else:

                print(f"  Warning: Sheet not found in final report")

                return

        else:

            df = df_dict[matched_sheet].copy()
            
            print(f"  读取sheet: {matched_sheet}, 原始行数: {len(df)}, 列数: {len(df.columns)}")
            
            # 对于网红/短信/投放日报，处理逻辑不同
            if any(x in title for x in ['网红日报', '短信日报', '投放日报']):
                print(f"  检测到日报类型: {title}")
                
                # 检查是否来自产品二文件（完整字段）还是LTV文件（需要聚合）
                if matched_sheet in ['短信', '网红', '投放']:
                    # 来自产品二文件，数据已经在load_data中被清理过了
                    print(f"  使用产品二文件的完整字段数据")
                    
                    # 找到日期列并统一为'时间'
                    date_col = None
                    for col in df.columns:
                        if '日期' in str(col) or '时间' in str(col):
                            date_col = col
                            break
                    
                    if date_col and date_col != '时间':
                        df = df.rename(columns={date_col: '时间'})
                    
                    # 转换日期并过滤有效数据
                    if '时间' in df.columns:
                        df['时间'] = pd.to_datetime(df['时间'], errors='coerce')
                        df = df[df['时间'].notna()].copy()
                        print(f"  处理后数据: {len(df)}行, {len(df.columns)}列")
                        
                        # ===== 补充19-20号数据（如果数据为空）=====
                        max_date = df['时间'].max()
                        print(f"  产品二数据最后日期: {max_date}")
                        
                        if pd.notna(max_date):
                            target_dates = [pd.Timestamp(2025, 10, 19), pd.Timestamp(2025, 10, 20)]
                            
                            # 检查这些日期的数据是否为空（所有数值列都是0或NaN）
                            empty_dates = []
                            for target_date in target_dates:
                                date_rows = df[df['时间'] == target_date]
                                if len(date_rows) > 0:
                                    try:
                                        # 检查所有数值列是否都为空或0
                                        numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns.tolist()
                                        # 过滤掉时间列（但保留所有数值列，即使列名不是字符串）
                                        numeric_cols_filtered = []
                                        for c in numeric_cols:
                                            # 跳过时间列
                                            if isinstance(c, str) and c == '时间':
                                                continue
                                            # 保留其他所有数值列（包括列名是np.float64的）
                                            numeric_cols_filtered.append(c)
                                        
                                        if len(numeric_cols_filtered) > 0:
                                            try:
                                                row_data = date_rows[numeric_cols_filtered].iloc[0]
                                                # 如果所有数值都是NaN或0，认为是空数据
                                                non_zero_count = ((row_data.notna()) & (row_data != 0)).sum()
                                                if non_zero_count == 0:
                                                    empty_dates.append(target_date)
                                                    print(f"  检测到{target_date.strftime('%Y-%m-%d')}的数据为空")
                                            except Exception as col_err:
                                                # 如果有列名问题，使用另一种方法检查（只检查数值类型的列）
                                                is_empty = True
                                                row = date_rows.iloc[0]
                                                for col in df.columns:
                                                    if col == '时间':
                                                        continue
                                                    # 只检查数值类型的列
                                                    if df[col].dtype not in ['float64', 'int64']:
                                                        continue
                                                    val = row[col]
                                                    if pd.notna(val) and val != 0:
                                                        is_empty = False
                                                        break
                                                if is_empty:
                                                    empty_dates.append(target_date)
                                                    print(f"  检测到{target_date.strftime('%Y-%m-%d')}的数据为空")
                                    except Exception as e:
                                        print(f"  检查{target_date.strftime('%Y-%m-%d')}数据时出错: {e}")
                            
                            missing_dates = empty_dates
                            
                            if missing_dates:
                                print(f"  将从每日渠道统计补充以下日期的数据: {[d.strftime('%Y-%m-%d') for d in missing_dates]}")
                                
                                # 先删除这些空数据行
                                df = df[~df['时间'].isin(missing_dates)].copy()
                                print(f"  删除空数据行后: {len(df)}行")
                                
                                # 从df_dict获取每日渠道统计数据
                                print(f"  DEBUG: df_dict中的sheet: {list(df_dict.keys())}")
                                print(f"  DEBUG: '每日渠道统计' in df_dict = {'每日渠道统计' in df_dict}")
                                
                                if '每日渠道统计' in df_dict:
                                    daily_stats = df_dict['每日渠道统计'].copy()
                                    print(f"  每日渠道统计数据: {daily_stats.shape}")
                                    
                                    # 按投放方式分类数据
                                    placement_type = None
                                    if '短信日报' in title:
                                        placement_type = '短信'
                                    elif '网红日报' in title:
                                        placement_type = '网红'
                                    elif '投放日报' in title:
                                        placement_type = '投放'
                                    
                                    print(f"  确定的投放类型: {placement_type}")
                                    
                                    # 使用'方式'列而不是'投放方式'列
                                    filter_col = '方式' if '方式' in daily_stats.columns else '投放方式'
                                    print(f"  使用过滤列: {filter_col}")
                                    
                                    if placement_type and filter_col in daily_stats.columns:
                                        # 过滤对应方式的数据
                                        filtered_stats = daily_stats[daily_stats[filter_col] == placement_type].copy()
                                        print(f"  使用'{filter_col}'列过滤，找到{len(filtered_stats)}行{placement_type}数据")
                                        
                                        # 确保时间列是datetime类型（支持'日期'或'时间'列）
                                        time_col_name = None
                                        if '日期' in filtered_stats.columns:
                                            time_col_name = '日期'
                                        elif '时间' in filtered_stats.columns:
                                            time_col_name = '时间'
                                        
                                        if time_col_name:
                                            filtered_stats[time_col_name] = pd.to_datetime(filtered_stats[time_col_name], errors='coerce', dayfirst=True)
                                            # 过滤需要补充的日期
                                            filtered_stats = filtered_stats[filtered_stats[time_col_name].isin(missing_dates)].copy()
                                            
                                            # 如果时间列名不是'时间'，重命名为'时间'以匹配产品二数据
                                            if time_col_name != '时间':
                                                filtered_stats = filtered_stats.rename(columns={time_col_name: '时间'})
                                            
                                            if len(filtered_stats) > 0:
                                                print(f"  从每日渠道统计找到{len(filtered_stats)}行{placement_type}数据")
                                                
                                                # 按日期聚合（因为每日渠道统计中同一天可能有多行）
                                                # 获取所有数值列（不过滤列名类型）
                                                numeric_cols_set = set(filtered_stats.select_dtypes(include=['float64', 'int64']).columns.tolist())
                                                
                                                agg_dict = {}
                                                for col in filtered_stats.columns:
                                                    if col == '时间':
                                                        continue
                                                    elif col in numeric_cols_set:
                                                        # 所有数值列都用sum聚合
                                                        agg_dict[col] = 'sum'
                                                    else:
                                                        # 非数值列用first
                                                        agg_dict[col] = 'first'
                                                
                                                if agg_dict:
                                                    filtered_stats = filtered_stats.groupby('时间', as_index=False).agg(agg_dict)
                                                    print(f"  按日期聚合后: {len(filtered_stats)}行")
                                                
                                                # 仅保留与产品二数据相同的列
                                                common_cols = [col for col in df.columns if col in filtered_stats.columns]
                                                
                                                if common_cols:
                                                    print(f"  匹配到{len(common_cols)}个公共列")
                                                    # 只保留匹配的列
                                                    filtered_stats_subset = filtered_stats[common_cols].copy()
                                                    
                                                    # 将产品二缺失的列用0填充
                                                    for col in df.columns:
                                                        if col not in filtered_stats_subset.columns:
                                                            filtered_stats_subset[col] = 0
                                                    
                                                    # 按产品二的列顺序重排
                                                    filtered_stats_subset = filtered_stats_subset[df.columns]
                                                    
                                                    # 合并数据（用真实数据替换空行）
                                                    df = pd.concat([df, filtered_stats_subset], ignore_index=True)
                                                    df = df.sort_values('时间').reset_index(drop=True)
                                                    
                                                    print(f"  ✅ 补充后数据: {len(df)}行, {len(df.columns)}列")
                                                    
                                                    # 对补充的数据应用公式计算派生字段
                                                    print(f"  开始计算派生字段...")
                                                    df = self._calculate_derived_fields(df, missing_dates)
                                                    print(f"  派生字段计算完成")
                                                else:
                                                    print(f"  ⚠️ 警告：没有找到匹配的列")
                                            else:
                                                    print(f"  ⚠️ 警告：每日渠道统计中没有找到{placement_type}在这些日期的数据")
                                        else:
                                            print(f"  ⚠️ 警告：每日渠道统计中没有找到时间/日期列")
                                    else:
                                        if not placement_type:
                                            print(f"  ⚠️ 警告：无法确定投放方式类型")
                                        elif filter_col not in daily_stats.columns:
                                            print(f"  ⚠️ 警告：每日渠道统计中没有'{filter_col}'列")
                                else:
                                    print(f"  ⚠️ 警告：未找到每日渠道统计数据")
                    else:
                        print(f"  警告：未找到时间/日期列")
                        print(f"  列名: {list(df.columns)[:10]}")
                    
                elif '时间' in df.columns:
                    # 来自LTV文件，需要聚合
                    print(f"  使用LTV数据，需要按日期聚合")
                    # 转换日期
                    df['时间'] = pd.to_datetime(df['时间'], errors='coerce')
                    
                    # 跳过第一行（可能是标题）
                    if len(df) > 0 and pd.isna(df.iloc[0]['时间']):
                        df = df.iloc[1:].copy()
                    
                    # 过滤有效日期
                    df = df[df['时间'].notna()].copy()
                    
                    # 清理美元符号并转换数值列
                    for col in df.columns:
                        if col != '时间' and df[col].dtype == 'object':
                            # 尝试清理美元符号和逗号
                            df[col] = df[col].astype(str).str.replace('$', '').str.replace(',', '')
                            # 转换为数值
                            df[col] = pd.to_numeric(df[col], errors='ignore')
                    
                    # 按日期聚合
                    agg_dict = {}
                    for col in df.columns:
                        if col == '时间':
                            continue
                        elif df[col].dtype in ['float64', 'int64']:
                            agg_dict[col] = 'sum'
                        else:
                            agg_dict[col] = 'first'
                    
                    if agg_dict:
                        before_agg = len(df)
                        df = df.groupby('时间', as_index=False).agg(agg_dict)
                        print(f"  按日期聚合: {before_agg}行 -> {len(df)}行")

            

            # 为短信日报和投放明细添加总计和日均行

            if any(x in title for x in ['短信日报', '投放明细']):

                df = self._add_summary_rows(df, title)

        

        if '产品二-VNL日报' in title:

            # 产品二-VNL日报特殊处理：创建包含所有sheet的Excel文件

            print("  Creating 产品二-VNL日报 with all sheets...")
            self._create_product2_vnl_report(df_dict, filename)

        else:

            print(f"Debug: Creating page, data rows: {len(df)}")

            

            wb = Workbook()

            

            # 1. 创建数据计算版（完整数据）

            ws_data = wb.active

            ws_data.title = f"{title}_数据"

            self._create_data_sheet(ws_data, df, title)

            

            # 2. 创建打印版（优化布局）

            ws_print = wb.create_sheet(f"{title}_打印")
            self._create_print_sheet(ws_print, df, title)

            

            # 3. 保存文件 - 添加错误处理

            try:

                wb.save(filename)

                print(f"✅ 成功保存: {filename}")
            except PermissionError:

                # 如果文件被占用，尝试重命名保存

                import os

                base_name = os.path.splitext(filename)[0]

                extension = os.path.splitext(filename)[1]

                counter = 1

                new_filename = f"{base_name}_备份{counter}{extension}"

                

                while os.path.exists(new_filename):

                    counter += 1

                    new_filename = f"{base_name}_备份{counter}{extension}"

                

                wb.save(new_filename)

                print(f"⚠️ 原文件被占用，已保存为: {new_filename}")
            except Exception as e:

                print(f"❌ 保存文件失败: {filename}, 错误: {e}")
        

        # 修复：生成PDF前生成Excel检查排版

        self._validate_excel_before_pdf(filename, title)

    

    def _create_product2_vnl_report(self, df_dict, filename):

        """创建产品二-VNL日报 - 包含所有sheet"""

        print("  Creating 产品二-VNL日报 with all sheets...")
        

        try:

            # 创建新的工作簿

            wb = Workbook()

            

            # 删除默认的sheet

            wb.remove(wb.active)

            

            # 为每个sheet创建对应的工作表

            for sheet_name, df in df_dict.items():

                if not df.empty:

                    # 创建新的工作表

                    ws = wb.create_sheet(sheet_name)
                    

                    # 写入数据

                    for r_idx, row in enumerate(df.itertuples(index=False), 1):

                        for c_idx, value in enumerate(row, 1):

                            ws.cell(row=r_idx, column=c_idx, value=value)

                    

                    # 设置表头样式

                    if len(df) > 0:

                        for col in range(1, len(df.columns) + 1):

                            cell = ws.cell(row=1, column=col)

                            cell.font = Font(bold=True)

                            cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")

                    

                    print(f"    Created sheet '{sheet_name}' with {len(df)} rows")
            

            # 保存文件

            wb.save(filename)

            print(f"  产品二-VNL日报 saved successfully: {filename}")
            

        except Exception as e:

            print(f"  Error creating 产品二-VNL日报: {e}")
    

    def _validate_excel_before_pdf(self, filename, title):

        """生成PDF前生成Excel检查排版 - 验证数据正确性"""

        print("  Validating Excel before PDF generation...")

        

        try:

            # 读取刚生成的Excel文件

            wb = load_workbook(filename)

            

            # 检查数据计算版

            if f"{title}_数据" in wb.sheetnames:

                ws_data = wb[f"{title}_数据"]

                print(f"    Data sheet validation:")

                print(f"      - Rows: {ws_data.max_row}")

                print(f"      - Columns: {ws_data.max_column}")

                

                # 检查关键列的数据

                for row in range(5, min(ws_data.max_row + 1, 10)):  # 检查前几行

                    for col in range(1, min(ws_data.max_column + 1, 6)):  # 检查前几列

                        cell = ws_data.cell(row=row, column=col)

                        if cell.value is not None:

                            # print(f"        Row {row}, Col {col}: {cell.value} (Format: {cell.number_format})")

                            pass

            

            # 检查打印版

            if f"{title}_打印" in wb.sheetnames:
                ws_print = wb[f"{title}_打印"]
                print(f"    Print sheet validation:")

                print(f"      - Rows: {ws_print.max_row}")

                print(f"      - Columns: {ws_print.max_column}")

                

                # 检查列宽设置

                for col in range(1, min(ws_print.max_column + 1, 6)):

                    col_letter = chr(64 + col)

                    width = ws_print.column_dimensions[col_letter].width

                    print(f"        Column {col_letter}: Width {width}")

            

            print(f"    Excel validation completed for {title}")
            

        except Exception as e:

            print(f"    Warning: Excel validation failed: {e}")

        

        # 检查汇率换算是否正确

        self._validate_exchange_rate_conversion(filename, title)

    

    def _validate_exchange_rate_conversion(self, filename, title):

        """验证汇率换算是否正确"""

        print("    Validating exchange rate conversion...")

        

        try:

            wb = load_workbook(filename)

            

            # 检查数据计算版的关键列

            if f"{title}_数据" in wb.sheetnames:

                ws_data = wb[f"{title}_数据"]

                

                # 查找关键列
                for row in range(1, min(ws_data.max_row + 1, 6)):
                    for col in range(1, min(ws_data.max_column + 1, 10)):
                        cell = ws_data.cell(row=row, column=col)
                        if cell.value and isinstance(cell.value, str):
                            if '总消耗' in cell.value or '充值金额' in cell.value:
                                # 检查下一行的数值
                                next_cell = ws_data.cell(row=row+1, column=col)
                                if next_cell.value and isinstance(next_cell.value, (int, float)):
                                    if '总消耗' in cell.value:
                                        # 总消耗来自LTV sheet，已经是美元，数值可能较大
                                        if next_cell.value > 50000:  # 总消耗可能较大
                                            print(f"      Warning: Very large value {next_cell.value} in {cell.value} - check if this is correct")
                                        else:
                                            print(f"      OK: Value {next_cell.value} in {cell.value} - LTV sheet data appears correct")
                                    elif '充值金额' in cell.value:
                                        # 充值金额来自后台sheet，需要汇率换算，数值可能较大（几千到几万）
                                        if next_cell.value > 100000:  # 如果数值非常大，可能汇率换算未生效
                                            print(f"      Warning: Very large value {next_cell.value} in {cell.value} - check exchange rate conversion")
                                        else:
                                            print(f"      OK: Value {next_cell.value} in {cell.value} - exchange rate conversion appears correct")
            

        except Exception as e:

            print(f"    Warning: Exchange rate validation failed: {e}")

    

    def _create_data_sheet(self, ws, df, title):

        """创建数据计算版 - 完整数据，用于计算"""

        # 应用模板格式设置

        self._apply_template_formatting(ws, title)

        
        # 添加抬头区（所有报表都需要标题）
        self._add_header_section(ws, title)

        

        # 写入数据

        start_row = 4

        

        # 添加分组横条（如果需要）

        if any(x in title for x in ['短信日报', '网红日报', '投放日报']):

            self._add_group_header(ws, title, start_row, len(df.columns))

            start_row += 1

        

        # VNL大盘日报的数据已经经过汇率转换，不需要再次转换

        if '大盘日报' in title:

            # 直接使用已经转换过的数据

            df_to_use = df

        else:

            # 其他报表需要进行汇率转换

            df_to_use = self._convert_currency_columns(df, title)

        
        # 格式化数据：两位小数和零填充
        df_to_use = df_to_use.copy()
        
        # 1. 将NaN替换为0（但不替换日期列）
        for col in df_to_use.columns:
            if col not in ['日期', '时间']:
                df_to_use[col] = df_to_use[col].fillna(0)
            else:
                # 保留日期/时间列的NaN
                pass
        
        # 1.5 确保日期列格式为仅日期（不显示时间）
        if '日期' in df_to_use.columns:
            # 如果日期列是datetime对象，转换为date
            if df_to_use['日期'].dtype == 'object':
                # 可能已经是date或str格式
                try:
                    df_to_use['日期'] = pd.to_datetime(df_to_use['日期'], errors='coerce').dt.date
                except:
                    pass
            else:
                # 是datetime64格式
                df_to_use['日期'] = df_to_use['日期'].dt.date
            
            # 转换为字符串，以便Excel正确显示
            df_to_use['日期'] = df_to_use['日期'].astype(str)
        
        # 2. 对数值列保留两位小数
        for col in df_to_use.columns:
            if df_to_use[col].dtype in ['float64', 'int64']:
                # 跳过日期和时间列
                if col not in ['日期', '时间']:
                    df_to_use[col] = df_to_use[col].round(2)
        
        for r in dataframe_to_rows(df_to_use, index=False, header=True):
            ws.append(r)
        

        # 设置样式

        self._format_header(ws, start_row, len(df_to_use.columns))

        self._format_data(ws, df_to_use, start_row)

        self._apply_zebra_striping(ws, df, start_row)

        self._apply_data_bars(ws, df, start_row)

        self._format_special_rows(ws, df, start_row)

        self._apply_alternating_colors(ws, len(df))

    

    def _create_print_sheet(self, ws, df, title):

        """创建打印版 - 重新设计为简报页，分区显示"""

        # 格式化数据：两位小数和零填充
        df = df.copy()
        df = df.fillna(0)
        
        # 对数值列保留两位小数
        for col in df.columns:
            if df[col].dtype in ['float64', 'int64']:
                if col not in ['日期', '时间']:
                    df[col] = df[col].round(2)

        # 应用模板格式设置

        self._apply_template_formatting(ws, title)

        

        # 1. 添加抬头区

        self._add_header_section(ws, title)

        

        # 2. 创建简报页布局 - 分区显示，每页≤15列

        self._create_brief_report_layout(ws, df, title)

        

        # 3. 设置简报页样式

        self._setup_brief_report_styles(ws, df, title)

        

        # 4. 设置页面布局

        self._setup_print_page_layout(ws)

    

    def _create_brief_report_layout(self, ws, df, title):

        """创建简报页布局 - 分区显示，每页≤15列"""

        start_row = 4

        

        # 根据报表类型创建不同的简报页布局

        if '大盘日报' in title:

            self._create_daily_summary_brief_layout(ws, df, start_row)

        elif any(x in title for x in ['短信日报', '网红日报', '投放日报']):

            self._create_channel_daily_brief_layout(ws, df, start_row)

        elif '投放明细' in title:

            self._create_detail_brief_layout(ws, df, start_row)

        else:

            # 默认简报布局

            self._create_default_brief_layout(ws, df, start_row)

    

    def _create_daily_summary_brief_layout(self, ws, df, start_row):

        """VNL大盘日报简报页布局 - 修复：简化布局，确保表头正确显示"""

        # 修复：简化布局，直接写入所有数据，确保表头正确显示

        print(f"Debug: Creating VNL daily summary brief page, data rows: {len(df)}")

        

        # 写入表头

        for col_idx, col_name in enumerate(df.columns, 1):

            cell = ws.cell(row=start_row, column=col_idx)

            cell.value = col_name

            cell.font = Font(name='Microsoft YaHei', size=10, bold=True, color='FFFFFF')

            cell.fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

            cell.alignment = Alignment(horizontal='center', vertical='center', wrapText=True)

        

        # 写入数据

        for row_idx, (_, row) in enumerate(df.iterrows(), start=start_row + 1):

            for col_idx, col_name in enumerate(df.columns, 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                cell.value = row[col_name]

                cell.font = Font(name='Microsoft YaHei', size=9)

                cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _create_channel_daily_brief_layout(self, ws, df, start_row):

        """渠道日报简报页布局 - 修复：简化布局，确保表头正确显示"""

        # 修复：简化布局，直接写入所有数据，确保表头正确显示

        print(f"Debug: Creating channel daily brief page, data rows: {len(df)}")

        

        # 写入表头

        for col_idx, col_name in enumerate(df.columns, 1):

            cell = ws.cell(row=start_row, column=col_idx)

            cell.value = col_name

            cell.font = Font(name='Microsoft YaHei', size=10, bold=True, color='FFFFFF')

            cell.fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

            cell.alignment = Alignment(horizontal='center', vertical='center', wrapText=True)

        

        # 写入数据

        for row_idx, (_, row) in enumerate(df.iterrows(), start=start_row + 1):

            for col_idx, col_name in enumerate(df.columns, 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                cell.value = row[col_name]

                cell.font = Font(name='Microsoft YaHei', size=9)

                cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _create_detail_brief_layout(self, ws, df, start_row):

        """投放明细简报页布局 - 修复：简化布局，确保表头正确显示"""

        # 修复：简化布局，直接写入所有数据，确保表头正确显示

        print(f"Debug: Creating campaign detail brief page, data rows: {len(df)}")

        

        # 写入表头

        for col_idx, col_name in enumerate(df.columns, 1):

            cell = ws.cell(row=start_row, column=col_idx)

            cell.value = col_name

            cell.font = Font(name='Microsoft YaHei', size=10, bold=True, color='FFFFFF')

            cell.fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

            cell.alignment = Alignment(horizontal='center', vertical='center', wrapText=True)

        

        # 写入数据

        for row_idx, (_, row) in enumerate(df.iterrows(), start=start_row + 1):

            for col_idx, col_name in enumerate(df.columns, 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                cell.value = row[col_name]

                cell.font = Font(name='Microsoft YaHei', size=9)

                cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _create_default_brief_layout(self, ws, df, start_row):

        """默认简报布局"""

        # 写入所有数据

        for r in dataframe_to_rows(df, index=False, header=True):

            ws.append(r)

        

    def _create_section_layout(self, ws, df, start_row, section_title, columns):

        """创建分区布局 - 修复：确保表头正确显示"""

        if not columns:

            return

        

        # 创建分区标题

        ws.merge_cells(f'A{start_row}:{chr(64 + len(columns))}{start_row}')

        cell = ws[f'A{start_row}']

        cell.value = section_title

        cell.fill = PatternFill(start_color='F2F4F7', end_color='F2F4F7', fill_type='solid')

        cell.font = Font(name='Microsoft YaHei', size=11, bold=True)

        cell.alignment = Alignment(horizontal='center', vertical='center')

        

        # 修复：写入列标题 - 确保表头正确显示

        for col_idx, col_name in enumerate(columns, 1):

            cell = ws.cell(row=start_row + 1, column=col_idx)

            cell.value = col_name

            cell.font = Font(name='Microsoft YaHei', size=10, bold=True)

            cell.alignment = Alignment(horizontal='center', vertical='center', wrapText=True)

            # 修复：设置表头背景色

            cell.fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

            cell.font = Font(name='Microsoft YaHei', size=10, bold=True, color='FFFFFF')

        

        # 写入数据

        for row_idx, (_, row) in enumerate(df.iterrows(), start=start_row + 2):

            for col_idx, col_name in enumerate(columns, 1):

                if col_name in row:

                    cell = ws.cell(row=row_idx, column=col_idx)

                    cell.value = row[col_name]

                    cell.font = Font(name='Microsoft YaHei', size=9)

                    cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _setup_brief_report_styles(self, ws, df, title):

        """设置简报页样式 - 基于配置的可视化样式"""

        # 获取报表配置

        report_config = self._get_report_config(title)

        

        # 设置字体和字号

        self._setup_brief_fonts(ws)

        

        # 设置列宽和行高

        self._setup_brief_dimensions(ws, df)

        

        # 设置数字格式

        self._setup_brief_number_formats(ws, df)

        

        # 设置可视化样式

        self._setup_brief_visual_styles(ws, df, report_config)

        

        # 设置冻结窗格

        self._setup_brief_freeze_panes(ws)



    def _get_report_config(self, title):

        """获取报表配置"""

        # 根据标题匹配配置

        if '大盘日报' in title:

            return self.config.get('VNL大盘日报', {})

        elif '短信日报' in title:

            return self.config.get('VNL短信日报', {})

        elif '网红日报' in title:

            return self.config.get('VNL网红日报', {})

        elif '投放日报' in title:

            return self.config.get('VNL投放日报', {})

        elif '投放明细' in title:

            return self.config.get('VNL投放明细', {})

        else:

            return {}

    

    def _setup_brief_fonts(self, ws):

        """设置简报页字体 - 统一Microsoft YaHei"""

        # 表头字体

        header_font = Font(name='Microsoft YaHei', size=11, bold=True)

        # 正文字体

        body_font = Font(name='Microsoft YaHei', size=9)

        

        # 应用字体到所有单元格

        for row in ws.iter_rows():

            for cell in row:

                if cell.row == 1:  # 标题行

                    cell.font = Font(name='Microsoft YaHei', size=16, bold=True)

                elif cell.row <= 3:  # 表头行

                    cell.font = header_font

                else:  # 数据行

                    cell.font = body_font

    

    def _setup_brief_dimensions(self, ws, df):

        """设置简报页列宽和行高 - 修复：处理列名超过Z的情况"""

        # 设置列宽

        for col in range(1, min(ws.max_column + 1, 27)):  # 限制在A-Z范围内

            col_letter = chr(64 + col)

            header_cell = ws.cell(row=1, column=col)

            header_text = str(header_cell.value or '').lower()

            

            if '日期' in header_text or '总代' in header_text or '渠道' in header_text:

                ws.column_dimensions[col_letter].width = 20  # 维度列

            elif '金额' in header_text or '消耗' in header_text or '成本' in header_text:

                ws.column_dimensions[col_letter].width = 12  # 金额列

            elif '人数' in header_text or '用户' in header_text:

                ws.column_dimensions[col_letter].width = 10  # 人数列

            elif '率' in header_text or '比' in header_text or 'ROI' in header_text:

                ws.column_dimensions[col_letter].width = 10  # 比率列

            else:

                ws.column_dimensions[col_letter].width = 12  # 默认列宽

        

        # 设置行高

        for row in range(1, ws.max_row + 1):

            if row == 1:  # 标题行

                ws.row_dimensions[row].height = 28

            elif row <= 3:  # 表头行

                ws.row_dimensions[row].height = 24

            else:  # 数据行

                ws.row_dimensions[row].height = 18

    

    def _setup_brief_number_formats(self, ws, df):

        """设置简报页数字格式 - 统一格式，避免长小数"""

        for row in range(4, ws.max_row + 1):

            for col in range(1, ws.max_column + 1):

                cell = ws.cell(row=row, column=col)

                header_cell = ws.cell(row=1, column=col)

                header_text = str(header_cell.value or '').lower()

                

                # 修复：统一数字格式，严禁10位以上小数

                if '金额' in header_text or '消耗' in header_text or '成本' in header_text or '(U)' in header_text:

                    cell.number_format = '#,##0.00'  # 货币：千分位+2位小数

                elif '率' in header_text or '比' in header_text or 'ROI' in header_text:

                    cell.number_format = '0.0%'  # 百分比：1位小数

                elif '人数' in header_text or '用户' in header_text:

                    cell.number_format = '#,##0'  # 人数：千分位整数

                else:

                    cell.number_format = 'General'

                

                # 修复：处理空值，避免nan/None导致显示异常

                if cell.value is not None:

                    if pd.isna(cell.value) or str(cell.value).lower() in ['nan', 'none']:

                        cell.value = ''

                    elif isinstance(cell.value, str) and ('%' in cell.value or ',' in cell.value):

                        # 处理百分比和千分位字符串

                        try:

                            if '%' in cell.value:

                                cell.value = float(cell.value.replace('%', '')) / 100

                            elif ',' in cell.value:

                                cell.value = float(cell.value.replace(',', ''))

                        except:

                            cell.value = 0

    

    def _setup_brief_visual_styles(self, ws, df, report_config):

        """设置简报页可视化样式 - 基于配置的问题显眼化"""

        # 1. 交替底色（Zebra）

        if report_config.get('zebra', True):

            self._apply_brief_alternating_colors(ws, df)

        

        # 2. 基于配置的列样式

        self._apply_config_based_styles(ws, df, report_config)

    

    def _apply_config_based_styles(self, ws, df, report_config):

        """基于配置应用样式 - 修复：限制列数范围"""

        columns_config = report_config.get('columns', [])

        

        # 修复：限制列数范围，避免超过Z列

        max_cols = min(len(df.columns), 26)

        for col_idx, col_name in enumerate(df.columns[:max_cols], 1):

            # 查找列配置

            col_config = None

            for config in columns_config:

                if config.get('name') == col_name:

                    col_config = config

                    break

            

            if not col_config:

                continue

            

            # 应用数字格式

            self._apply_column_number_format(ws, df, col_idx, col_config)

            

            # 应用数据条

            self._apply_column_databar(ws, df, col_idx, col_config)

            

            # 应用负值红字

            self._apply_column_negative_text(ws, df, col_idx, col_config)

            

            # 应用阈值警告

            self._apply_column_threshold_warning(ws, df, col_idx, col_config)

    

    def _apply_column_number_format(self, ws, df, col_idx, col_config):

        """应用列数字格式 - 按照用户规范更新"""

        format_type = col_config.get('format')

        if not format_type:

            return

        

        # 获取格式

        format_map = {

            'money': self.config['global']['number_format']['money'],

            'count': self.config['global']['number_format']['count'],

            'percent': self.config['global']['number_format']['percent']

        }

        

        excel_format = format_map.get(format_type, 'General')

        

        # 应用到数据行

        for row in range(4, 4 + len(df)):

            cell = ws.cell(row=row, column=col_idx)

            cell.number_format = excel_format

    

    def _apply_column_databar(self, ws, df, col_idx, col_config):

        """应用列数据条 - 修复：限制列数范围，排除总计和日均行"""

        databar_config = col_config.get('databar')

        if not databar_config or not databar_config.get('enable'):

            return

        

        # 修复：限制列数范围，避免超过Z列

        if col_idx > 26:

            return

        

        try:

            from openpyxl.formatting.rule import DataBarRule

            

            color = databar_config.get('color', '#70AD47')

            show_value = databar_config.get('show_value', False)

            

            # 计算数据范围，排除总计和日均行

            data_rows = []

            for i, row in df.iterrows():

                if row.iloc[0] not in ['总计', '日均']:  # 排除总计和日均行

                    data_rows.append(i + 4)  # +4是因为数据从第4行开始

            

            if not data_rows:

                return

                

            col_letter = chr(64 + col_idx)

            # 只对非总计/日均行应用数据条

            start_row = min(data_rows)

            end_row = max(data_rows)

            data_range = f"{col_letter}{start_row}:{col_letter}{end_row}"

            

            data_bar = DataBarRule(

                start_type='min',

                end_type='max',

                color=color,

                showValue=show_value

            )

            ws.conditional_formatting.add(data_range, data_bar)

        except:

            pass

    

    def _apply_column_negative_text(self, ws, df, col_idx, col_config):

        """应用列负值红字"""

        negative_condition = col_config.get('negative_text_if')

        if not negative_condition:

            return

        

        # 解析条件

        if negative_condition == '<0':

            threshold = 0

        elif negative_condition == '<1.0':

            threshold = 1.0

        else:

            return

        

        # 应用条件格式

        for row in range(4, 4 + len(df)):

            cell = ws.cell(row=row, column=col_idx)

            if isinstance(cell.value, (int, float)) and cell.value < threshold:

                cell.font = Font(name='Microsoft YaHei', size=9, color='FF0000')

    

    def _apply_column_threshold_warning(self, ws, df, col_idx, col_config):

        """应用列阈值警告"""

        warn_condition = col_config.get('warn_if')

        if not warn_condition:

            return

        

        # 解析警告条件

        if warn_condition.startswith('<'):

            threshold = float(warn_condition[1:].replace('%', '')) / 100

            operator = '<'

        elif warn_condition.startswith('>'):

            threshold = float(warn_condition[1:].replace('%', '')) / 100

            operator = '>'

        else:

            return

        

        # 应用警告底色

        for row in range(4, 4 + len(df)):

            cell = ws.cell(row=row, column=col_idx)

            if isinstance(cell.value, (int, float)):

                if operator == '<' and cell.value < threshold:

                    cell.fill = PatternFill(start_color='FFE6E6', end_color='FFE6E6', fill_type='solid')

                elif operator == '>' and cell.value > threshold:

                    cell.fill = PatternFill(start_color='FFE6E6', end_color='FFE6E6', fill_type='solid')

    

    def _apply_brief_alternating_colors(self, ws, df):

        """应用简报页交替底色 - 浅灰隔行"""

        alt_fill = PatternFill(start_color='FAFAFA', end_color='FAFAFA', fill_type='solid')

        

        # 从数据行开始应用交替底色

        for row in range(4, 4 + len(df)):

            if row % 2 == 0:  # 偶数行

                for col in range(1, ws.max_column + 1):

                    cell = ws.cell(row=row, column=col)

                    cell.fill = alt_fill

    

    def _apply_brief_negative_values(self, ws, df):

        """应用简报页负值红字"""

        negative_columns = ['总充提差(U)', '充提差比', '当日回本ROI', '总充值ROI']

        

        for row in range(4, 4 + len(df)):

            for col in range(1, ws.max_column + 1):

                cell = ws.cell(row=row, column=col)

                header_cell = ws.cell(row=1, column=col)

                header_text = str(header_cell.value or '')

                

                if any(col_name in header_text for col_name in negative_columns):

                    if isinstance(cell.value, (int, float)) and cell.value < 0:

                        cell.font = Font(name='Microsoft YaHei', size=9, color='FF0000')

    

    def _apply_brief_data_bars(self, ws, df):

        """应用简报页数据条 - 仅用于图形专用列"""

        # 规模型（金额/人数）：柔和绿 #70AD47

        scale_columns = ['总消耗(U)', '充值金额(U)', '首充人数', '充值人数', '当日消耗($)', '充值金额', '首充金额']

        

        # 比率型（留存/复充）：柔和蓝 #4F81BD

        ratio_columns = ['首充次日复充率', '首充3日 复充率', '首充7日 复充率', '首充30日 复充率']
        

        for col in range(1, ws.max_column + 1):

            header_cell = ws.cell(row=1, column=col)

            header_text = str(header_cell.value or '')

            

            if any(col_name in header_text for col_name in scale_columns):

                # 规模型数据条

                self._add_data_bar_to_column(ws, col, len(df), '#70AD47')

            elif any(col_name in header_text for col_name in ratio_columns):

                # 比率型数据条

                self._add_data_bar_to_column(ws, col, len(df), '#4F81BD')

    

    def _add_data_bar_to_column(self, ws, col, data_rows, color):

        """为指定列添加数据条"""

        try:

            from openpyxl.formatting.rule import DataBarRule

            

            data_range = f"{chr(64 + col)}4:{chr(64 + col)}{3 + data_rows}"

            data_bar = DataBarRule(

                start_type='min',

                end_type='max',

                color=color,

                showValue=False  # 仅显示条，隐藏数值

            )

            ws.conditional_formatting.add(data_range, data_bar)

        except:

            pass  # 如果数据条添加失败，继续执行

    

    def _apply_template_formatting(self, ws, title):

        """根据模板规格应用格式设置"""

        # 基础页面设置

        ws.sheet_view.showGridLines = False

        ws.sheet_view.zoomScale = 55

        

        # 根据报表类型设置不同的打印参数

        if '大盘日报' in title:

            # 日报：portrait，scale=20，fitToHeight=0，paperSize=1

            ws.page_setup.orientation = 'portrait'

            ws.page_setup.scale = 20

            ws.page_setup.fitToHeight = 0

            ws.page_setup.paperSize = 1

            # 页边距（英寸）

            ws.page_margins.left = 0.7087

            ws.page_margins.right = 0.7087

            ws.page_margins.top = 0.7480

            ws.page_margins.bottom = 0.7480

            ws.page_margins.header = 0.3150

            ws.page_margins.footer = 0.3150

        else:

            # 其他报表：landscape，不同缩放比例

            ws.page_setup.orientation = 'landscape'

            ws.page_setup.paperSize = 9

            if '短信' in title:

                ws.page_setup.scale = 25

            elif '网红' in title:

                ws.page_setup.scale = 22

            elif '投放' in title:

                ws.page_setup.scale = 28

            elif '投放明细' in title:

                ws.page_setup.orientation = 'portrait'

                ws.page_setup.scale = 19

            # 页边距（英寸）

            ws.page_margins.left = 0.75

            ws.page_margins.right = 0.75

            ws.page_margins.top = 1.00

            ws.page_margins.bottom = 1.00

            ws.page_margins.header = 0.50

            ws.page_margins.footer = 0.50

        

        # 设置列宽

        self._apply_column_widths(ws, title)

        

        # 设置行高

        self._apply_row_heights(ws, title)

    

    def _load_format_config(self, title):

        """加载格式配置文件"""

        format_files = {

            '大盘日报': '日报_样式与数据_完整文本清单.txt',

            '短信': '短信_样式与数据_完整文本清单.txt',

            '网红': '网红_样式与数据_完整文本清单.txt',

            '投放': '投放_样式与数据_完整文本清单.txt',

            '投放明细': '投放明细_样式与数据_完整文本清单.txt'

        }

        

        # 根据标题确定使用哪个格式文件

        format_file = None

        for key, file in format_files.items():

            if key in title:

                format_file = file

                break

        

        if not format_file:

            return None

            

        try:

            with open(format_file, 'r', encoding='utf-8') as f:

                content = f.read()

            return self._parse_format_config(content)

        except Exception as e:

            print(f"Error loading format config: {e}")

            return None

    

    def _parse_format_config(self, content):

        """解析格式配置内容"""

        config = {

            'properties': {},

            'column_widths': {},

            'row_heights': {},

            'cell_data': {}

        }

        

        lines = content.split('\n')

        current_section = None

        

        for line in lines:

            line = line.strip()

            if not line or line.startswith('#'):

                continue

                

            if line.startswith('## Properties'):

                current_section = 'properties'

                continue

            elif line.startswith('## Column Widths'):

                current_section = 'column_widths'

                continue

            elif line.startswith('## Row Heights'):

                current_section = 'row_heights'

                continue

            elif line.startswith('## Cell Data'):

                current_section = 'cell_data'

                continue

            

            if current_section == 'properties':

                if ':' in line:

                    key, value = line.split(':', 1)

                    config['properties'][key.strip()] = value.strip()

            elif current_section == 'column_widths':

                if '=' in line:

                    # 解析列宽: A(1) = 4.62962962962963

                    parts = line.split('=')

                    if len(parts) == 2:

                        col_part = parts[0].strip()

                        width = float(parts[1].strip())

                        # 提取列字母

                        if '(' in col_part:

                            col_letter = col_part.split('(')[0]

                            config['column_widths'][col_letter] = width

            elif current_section == 'row_heights':

                if '=' in line:

                    # 解析行高: Row 1 = None

                    parts = line.split('=')

                    if len(parts) == 2:

                        row_part = parts[0].strip()

                        height = parts[1].strip()

                        if height != 'None':

                            row_num = int(row_part.split()[1])

                            config['row_heights'][row_num] = float(height)

        

        return config

    

    def _apply_column_widths(self, ws, title):

        """设置列宽：A-Z(1-26列)=12ch，AA-AN(27-40列)=13ch"""

        # 设置A-Z列（1-26列）宽度为12

        for i in range(1, 27):

            col_letter = get_column_letter(i)

            ws.column_dimensions[col_letter].width = 12.0

        

        # 设置AA-AN列（27-40列）宽度为13

        for i in range(27, 41):

            col_letter = get_column_letter(i)

            ws.column_dimensions[col_letter].width = 13.0

    

    def _apply_row_heights(self, ws, title):

        """设置表头行高：行1=28pt，行2-3=24pt，行4-12=18pt"""

        # 行1 = 28.00pt

        ws.row_dimensions[1].height = 28.0

        

        # 行2-3 = 24.00pt

        ws.row_dimensions[2].height = 24.0

        ws.row_dimensions[3].height = 24.0

        

        # 行4-12 = 18.00pt

        for row in range(4, 13):

            ws.row_dimensions[row].height = 18.0

    

    def _apply_template_styles(self, ws, title):

        """应用模板样式（字体、颜色、填充等）"""

        # 主题色定义

        theme_blue = '002060'  # theme:1 深蓝

        theme_gray = 'E3E3E3'  # 浅灰

        

        # 表头样式

        header_font = Font(name='微软雅黑', size=11, bold=True, color='000000')

        header_fill = PatternFill(start_color=theme_blue, end_color=theme_blue, fill_type='solid')

        

        # 数据区样式

        data_font = Font(name='等线', size=11, color='000000')

        

        # 应用样式到表头

        for row in ws.iter_rows(min_row=1, max_row=3):

            for cell in row:

                cell.font = header_font

                cell.fill = header_fill

                cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)

        

        # 应用样式到数据区

        for row in ws.iter_rows(min_row=4):

            for cell in row:

                cell.font = data_font

                cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _apply_brief_threshold_colors(self, ws, df):

        """应用简报页阈值色块 - 快速发现异常"""

        # 留存/复充：低于阈值（如 次日<30% / 7日<10%）→ 底色浅红

        retention_columns = ['首充次日复充率', '首充3日 复充率', '首充7日 复充率', '首充30日 复充率']
        

        # ROI/投充比：低于 1.0 → 底色浅红

        roi_columns = ['ROI', '投充比', '总充值ROI', '当日回本ROI']

        

        for row in range(4, 4 + len(df)):

            for col in range(1, ws.max_column + 1):

                cell = ws.cell(row=row, column=col)

                header_cell = ws.cell(row=1, column=col)

                header_text = str(header_cell.value or '')

                

                if any(col_name in header_text for col_name in retention_columns):

                    # 留存率阈值检查

                    if isinstance(cell.value, (int, float)) and cell.value < 0.1:  # 10%

                        cell.fill = PatternFill(start_color='FFE6E6', end_color='FFE6E6', fill_type='solid')

                elif any(col_name in header_text for col_name in roi_columns):

                    # ROI阈值检查

                    if isinstance(cell.value, (int, float)) and cell.value < 1.0:

                        cell.fill = PatternFill(start_color='FFE6E6', end_color='FFE6E6', fill_type='solid')

    

    def _setup_brief_freeze_panes(self, ws):

        """设置简报页冻结窗格 - 冻结第一行与第一列"""

        ws.freeze_panes = 'B2'  # 冻结第一行和第一列

    

    def _create_optimized_print_layout(self, ws, df, title):

        """创建优化的打印布局 - 分页显示，避免拥挤"""

        start_row = 4

        

        # 修复：打印导出前DataFrame的columns，确保写入顺序一致

        print(f"Debug: DataFrame columns: {list(df.columns)}")

        print(f"Debug: DataFrame shape: {df.shape}")

        

        # 根据报表类型创建不同的打印布局

        if '大盘日报' in title:

            self._create_daily_summary_print_layout(ws, df, start_row)

        elif any(x in title for x in ['短信日报', '网红日报', '投放日报']):

            self._create_channel_daily_print_layout(ws, df, start_row)

        elif '投放明细' in title:

            self._create_detail_print_layout(ws, df, start_row)

        else:

            # 默认布局

            self._create_default_print_layout(ws, df, start_row)

    

    def _create_daily_summary_print_layout(self, ws, df, start_row):

        """VNL大盘日报打印布局 - 分页显示核心KPI"""

        # 第一页：核心KPI（10-15列）

        core_columns = [

            '日期', '总消耗(U)', '充值金额(U)', '新增注册人数', '首充人数', '充值人数',

            '首充次日复充率', '首充3日 复充率', '首充7日 复充率', '首充30日 复充率',
            '人均充值金额(U)', '人均充值笔数', '首充成本(U)', '一级首充成本(U)', 'ROI'

        ]

        

        # 筛选存在的列

        existing_core_columns = [col for col in core_columns if col in df.columns]

        core_df = df[existing_core_columns]

        

        # 修复：清除旧表头区域，避免Excel模板表头残留

        self._clear_old_headers(ws, start_row, len(existing_core_columns))

        

        # 修复：确保写入顺序与DataFrame columns严格一致

        print(f"Debug: Writing column order: {list(core_df.columns)}")

        

        # 写入核心KPI数据

        for r in dataframe_to_rows(core_df, index=False, header=True):

            ws.append(r)

        

        # 设置核心KPI样式

        self._setup_core_kpi_styles(ws, core_df, start_row)

    

    def _clear_old_headers(self, ws, start_row, num_cols):

        """清除旧表头区域，避免Excel模板表头残留"""

        # 清除表头区域

        for row in range(start_row, start_row + 3):  # 清除3行表头区域

            for col in range(1, num_cols + 1):

                cell = ws.cell(row=row, column=col)

                cell.value = None

                cell.fill = PatternFill(fill_type=None)

                cell.font = Font()

                cell.border = Border()

                cell.alignment = Alignment()

    

    def _create_channel_daily_print_layout(self, ws, df, start_row):

        """渠道日报打印布局 - 分页显示渠道指标"""

        # 第一页：渠道核心指标

        channel_columns = [

            '日期', '总代号', '渠道名称', '方式', '总消耗(U)', '充值金额(U)', 

            '新增注册人数', '首充人数', '充值人数', '首充次日复充率', 

            '首充3日 复充率', '首充7日 复充率', 'ROI', '首充成本(U)', '一级首充成本(U)'
        ]

        

        # 筛选存在的列

        existing_channel_columns = [col for col in channel_columns if col in df.columns]

        channel_df = df[existing_channel_columns]

        

        # 写入渠道数据

        for r in dataframe_to_rows(channel_df, index=False, header=True):

            ws.append(r)

        

        # 设置渠道样式

        self._setup_channel_styles(ws, channel_df, start_row)

    

    def _create_detail_print_layout(self, ws, df, start_row):

        """投放明细打印布局 - 分页显示明细数据"""

        # 第一页：明细核心指标

        detail_columns = [

            '日期', '总代号', '渠道名称', '方式', '投放方式', '总消耗(U)', 

            '充值金额(U)', '新增注册人数', '首充人数', '充值人数', 'ROI'

        ]

        

        # 筛选存在的列

        existing_detail_columns = [col for col in detail_columns if col in df.columns]

        detail_df = df[existing_detail_columns]

        

        # 写入明细数据

        for r in dataframe_to_rows(detail_df, index=False, header=True):

            ws.append(r)

        

        # 设置明细样式

        self._setup_detail_styles(ws, detail_df, start_row)

    

    def _create_default_print_layout(self, ws, df, start_row):

        """默认打印布局"""

        # 写入所有数据

        for r in dataframe_to_rows(df, index=False, header=True):

            ws.append(r)

        

        # 设置默认样式

        self._setup_default_styles(ws, df, start_row)

    

    def _setup_core_kpi_styles(self, ws, df, start_row):

        """设置核心KPI样式 - 优化列宽，避免拥挤"""

        # 设置列宽（按最长值+20%安全边距）

        column_widths = {

            '日期': 12,

            '总消耗(U)': 15,

            '充值金额(U)': 15,

            '新增注册人数': 12,

            '首充人数': 12,

            '充值人数': 12,

            '首充次日复充率': 12,

            '首充3日 复充率': 12,
            '首充7日 复充率': 12,
            '首充30日 复充率': 12,
            '人均充值金额(U)': 15,

            '人均充值笔数': 12,

            '首充成本(U)': 15,

            '一级首充成本(U)': 15,

            'ROI': 12

        }

        

        for col_idx, col_name in enumerate(df.columns, 1):

            if col_name in column_widths:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = column_widths[col_name]

            else:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = 12

        

        # 设置行高

        ws.row_dimensions[start_row].height = 24  # 表头行高

        for row in range(start_row + 1, start_row + len(df) + 1):

            ws.row_dimensions[row].height = 18  # 数据行高

        

        # 设置数字格式

        self._setup_print_number_formats(ws, df, start_row)

    

    def _setup_channel_styles(self, ws, df, start_row):

        """设置渠道样式"""

        # 设置列宽

        column_widths = {

            '日期': 12,

            '总代号': 10,

            '渠道名称': 20,

            '方式': 15,

            '总消耗(U)': 15,

            '充值金额(U)': 15,

            '新增注册人数': 12,

            '首充人数': 12,

            '充值人数': 12,

            '首充次日复充率': 12,

            '首充3日 复充率': 12,
            '首充7日 复充率': 12,
            'ROI': 12,

            '首充成本(U)': 15,

            '一级首充成本(U)': 15

        }

        

        for col_idx, col_name in enumerate(df.columns, 1):

            if col_name in column_widths:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = column_widths[col_name]

            else:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = 12

        

        # 设置行高

        ws.row_dimensions[start_row].height = 24

        for row in range(start_row + 1, start_row + len(df) + 1):

            ws.row_dimensions[row].height = 18

        

        # 设置数字格式

        self._setup_print_number_formats(ws, df, start_row)

    

    def _setup_detail_styles(self, ws, df, start_row):

        """设置明细样式"""

        # 设置列宽

        column_widths = {

            '日期': 12,

            '总代号': 10,

            '渠道名称': 20,

            '方式': 15,

            '投放方式': 15,

            '总消耗(U)': 15,

            '充值金额(U)': 15,

            '新增注册人数': 12,

            '首充人数': 12,

            '充值人数': 12,

            'ROI': 12

        }

        

        for col_idx, col_name in enumerate(df.columns, 1):

            if col_name in column_widths:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = column_widths[col_name]

            else:

                col_letter = chr(64 + col_idx)

                ws.column_dimensions[col_letter].width = 12

        

        # 设置行高

        ws.row_dimensions[start_row].height = 24

        for row in range(start_row + 1, start_row + len(df) + 1):

            ws.row_dimensions[row].height = 18

        

        # 设置数字格式

        self._setup_print_number_formats(ws, df, start_row)

    

    def _setup_default_styles(self, ws, df, start_row):

        """设置默认样式"""

        # 设置列宽

        for col_idx in range(1, len(df.columns) + 1):

            col_letter = chr(64 + col_idx)

            ws.column_dimensions[col_letter].width = 12

        

        # 设置行高

        ws.row_dimensions[start_row].height = 24

        for row in range(start_row + 1, start_row + len(df) + 1):

            ws.row_dimensions[row].height = 18

        

        # 设置数字格式

        self._setup_print_number_formats(ws, df, start_row)

    

    def _setup_print_number_formats(self, ws, df, start_row):

        """设置打印版数字格式 - 统一格式，避免长小数，禁止拼接数值字符串"""

        for row_idx in range(start_row + 1, start_row + len(df) + 1):

            for col_idx, col_name in enumerate(df.columns, 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                

                # 修复：统一数字格式，严禁10位以上小数

                if '金额' in col_name or '消耗' in col_name or '成本' in col_name or '(U)' in col_name:

                    cell.number_format = '#,##0.00'  # 货币：千分位+2位小数

                elif '率' in col_name or '比' in col_name or 'ROI' in col_name:

                    cell.number_format = '0.0%'  # 百分比：1位小数

                elif '人数' in col_name or '用户' in col_name:

                    cell.number_format = '#,##0'  # 人数：千分位整数

                else:

                    cell.number_format = 'General'

                

                # 修复：处理空值，避免nan/None导致显示异常

                value = df.iloc[row_idx - start_row - 1, col_idx - 1]

                if pd.isna(value) or value == '' or str(value).lower() in ['nan', 'none']:

                    cell.value = ''

                else:

                    # 修复：禁止直接拼接数值字符串，确保数值类型正确

                    if isinstance(value, str) and ('%' in value or ',' in value):

                        # 处理百分比字符串

                        if '%' in value:

                            try:

                                numeric_value = float(value.replace('%', '')) / 100

                                cell.value = numeric_value

                            except:

                                cell.value = 0

                        # 处理千分位字符串

                        elif ',' in value:

                            try:

                                numeric_value = float(value.replace(',', ''))

                                cell.value = numeric_value

                            except:

                                cell.value = 0

                        else:

                            cell.value = value

                    else:

                        cell.value = value

                

                # 修复：确保数值类型正确，避免字符串导致格式错误

                if isinstance(cell.value, (int, float)) and not pd.isna(cell.value):

                    # 对于数值类型，确保格式正确

                    if '金额' in col_name or '消耗' in col_name or '成本' in col_name or '(U)' in col_name:

                        # 确保货币格式正确

                        if abs(cell.value) > 1000:  # 大数值需要千分位

                            pass  # 格式已在上面设置

                        else:

                            cell.number_format = '0.00'  # 小数值2位小数

                    elif '率' in col_name or '比' in col_name or 'ROI' in col_name:

                        # 确保百分比格式正确

                        if 0 <= cell.value <= 1:  # 已经是0-1范围

                            pass  # 格式已在上面设置

                        elif cell.value > 1:  # 需要转换为0-1范围

                            cell.value = cell.value / 100

                    elif '人数' in col_name or '用户' in col_name:

                        # 确保人数格式正确

                        cell.value = int(cell.value) if not pd.isna(cell.value) else 0

    

    def _setup_print_styles(self, ws, df, title):

        """设置打印版样式 - 优化可读性"""

        # 设置表头样式

        self._setup_print_header_styles(ws, df)

        

        # 设置交替底色

        self._apply_print_alternating_colors(ws, df)

        

        # 设置网格线

        self._setup_print_grid_lines(ws, df)

        

        # 设置对齐方式

        self._setup_print_alignment(ws, df)

    

    def _setup_print_header_styles(self, ws, df):

        """设置打印版表头样式"""

        # 表头字体

        header_font = Font(name='Noto Sans CJK SC', size=11, bold=True, color='FFFFFF')

        

        # 表头填充

        header_fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

        

        # 设置表头样式

        for col_idx in range(1, len(df.columns) + 1):

            cell = ws.cell(row=4, column=col_idx)

            cell.font = header_font

            cell.fill = header_fill

            cell.alignment = Alignment(horizontal='center', vertical='center')

    

    def _apply_print_alternating_colors(self, ws, df):

        """应用打印版交替底色 - 浅灰隔行"""

        alt_fill = PatternFill(start_color='F8F8F8', end_color='F8F8F8', fill_type='solid')

        

        # 从数据行开始应用交替底色

        start_row = 5

        for row in range(start_row, start_row + len(df)):

            if row % 2 == 0:  # 偶数行

                for col in range(1, len(df.columns) + 1):

                    cell = ws.cell(row=row, column=col)

                    cell.fill = alt_fill

    

    def _setup_print_grid_lines(self, ws, df):

        """设置打印版网格线 - 细内框线，外框加粗"""

        thin_border = Border(

            left=Side(style='thin', color='CCCCCC'),

            right=Side(style='thin', color='CCCCCC'),

            top=Side(style='thin', color='CCCCCC'),

            bottom=Side(style='thin', color='CCCCCC')

        )

        

        thick_border = Border(

            left=Side(style='thick', color='000000'),

            right=Side(style='thick', color='000000'),

            top=Side(style='thick', color='000000'),

            bottom=Side(style='thick', color='000000')

        )

        

        # 设置所有单元格边框

        for row in range(4, 4 + len(df) + 1):

            for col in range(1, len(df.columns) + 1):

                cell = ws.cell(row=row, column=col)

                if row == 4 or row == 4 + len(df):  # 表头和最后一行

                    cell.border = thick_border

                else:

                    cell.border = thin_border

    

    def _setup_print_alignment(self, ws, df):

        """设置打印版对齐方式"""

        for row in range(4, 4 + len(df) + 1):

            for col_idx, col_name in enumerate(df.columns, 1):

                cell = ws.cell(row=row, column=col_idx)

                

                # 根据列类型设置对齐方式

                if '金额' in col_name or '消耗' in col_name or '成本' in col_name or '人数' in col_name:

                    cell.alignment = Alignment(horizontal='right', vertical='center')

                elif '率' in col_name or '比' in col_name or 'ROI' in col_name:

                    cell.alignment = Alignment(horizontal='center', vertical='center')

                else:

                    cell.alignment = Alignment(horizontal='left', vertical='center')

    

    def _setup_print_page_layout(self, ws):

        """设置打印版页面布局 - A3横向，1页宽×高度自动"""

        # 修复：A3横向，1页宽×高度自动，不强制压缩

        ws.page_setup.orientation = 'landscape'

        ws.page_setup.paperSize = 8  # A3

        ws.page_setup.fitToWidth = 1  # 1页宽

        ws.page_setup.fitToHeight = 0  # 高度自动，不强制压缩

        

        # 设置窄边距，为内容争取横向空间

        ws.page_margins = PageMargins(

            left=0.5, right=0.5, top=0.5, bottom=0.5,

            header=0.3, footer=0.3

        )

        

        # 设置打印标题行

        ws.print_title_rows = '1:4'  # 表头行重复
        

        # 设置打印区域（只包含关键列）

        max_col = min(ws.max_column, 26)  # 限制在A-Z范围内

        if max_col > 0:

            ws.print_area = f'A1:{chr(64 + max_col)}{ws.max_row}'

        

        # 水平居中

        ws.print_options.horizontalCentered = True

    

    def _add_header_section(self, ws, title):

        """添加抬头区：标题+备注+汇率 - 修复：统一字体"""

        # 修复：统一使用思源黑体，避免字体替换

        header_font = Font(name='Noto Sans CJK SC', size=16, bold=True, color='FFFFFF')

        body_font = Font(name='Noto Sans CJK SC', size=10)

        

        # 标题行 - 20pt深蓝，居中加粗

        ws.merge_cells('A1:K1')

        ws['A1'] = title

        ws['A1'].font = Font(name='Microsoft YaHei', size=20, bold=True, color='1F4E78')

        ws['A1'].alignment = Alignment(horizontal='center', vertical='center')

        ws.row_dimensions[1].height = 28

        

        # 备注行 - 居中

        ws.merge_cells('A2:K2')

        ws['A2'] = "备注：10.12日消耗已更正，报表已同步产品端汇率18.7。"

        ws['A2'].font = Font(name='Microsoft YaHei', size=10)

        ws['A2'].alignment = Alignment(horizontal='center', vertical='center')

        ws.row_dimensions[2].height = 18

        

        # 汇率行 - 贴右，合并最后4列

        ws.merge_cells('H3:K3')

        ws['H3'] = f"汇率 {self.EXCHANGE_RATE}"

        ws['H3'].font = Font(name='Microsoft YaHei', size=10, bold=True)

        ws['H3'].alignment = Alignment(horizontal='right', vertical='center')

        ws.row_dimensions[3].height = 18

    

    def _add_group_header(self, ws, title, start_row, num_cols):

        """添加分组横条：深蓝底白字 - 修复：控制在2行，避免同名字段重复"""

        group_name = ""

        if '短信日报' in title:

            group_name = "短信"

        elif '网红日报' in title:

            group_name = "网红"

        elif '投放日报' in title:

            group_name = "投放"

        

        if group_name:

            # 修复：控制在2行表头，避免同名字段重复

            max_col = min(num_cols, 26)  # 限制在A-Z范围内

            end_col = chr(64 + max_col) if max_col <= 26 else 'Z'

            ws.merge_cells(f'A{start_row}:{end_col}{start_row}')

            cell = ws[f'A{start_row}']

            cell.value = group_name

            cell.fill = PatternFill(start_color='1F4E79', end_color='1F4E79', fill_type='solid')

            cell.font = Font(name='Noto Sans CJK SC', size=11, bold=True, color='FFFFFF')

            cell.alignment = Alignment(horizontal='center', vertical='center')

            

            # 修复：设置行高，避免文字拥挤

            ws.row_dimensions[start_row].height = 24

            ws.row_dimensions[start_row].height = 22

    

    def _format_header(self, ws, start_row, num_cols):

        """设置表头样式:深蓝底黑字 - 按照配置"""

        header_fill = PatternFill(start_color='0D2D5A', end_color='0D2D5A', fill_type='solid')

        header_font = Font(name='Microsoft YaHei', size=11, bold=True, color='000000')
        header_alignment = Alignment(horizontal='center', vertical='center')

        thin_border = Border(

            left=Side(style='thin', color='000000'),

            right=Side(style='thin', color='000000'),

            top=Side(style='thin', color='000000'),

            bottom=Side(style='thin', color='000000')

        )

        

        for col in range(1, num_cols + 1):

            cell = ws.cell(row=start_row, column=col)

            cell.fill = header_fill

            cell.font = header_font

            cell.alignment = header_alignment

            cell.border = thin_border

        

        ws.row_dimensions[start_row].height = 22

    

    def _format_data(self, ws, df, start_row):

        """设置数据格式：数值+格式 - 统一小数位"""

        for col_idx, col_name in enumerate(df.columns, 1):

            for row_idx in range(start_row + 1, start_row + len(df) + 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                

                # 获取值

                value = df.iloc[row_idx - start_row - 1, col_idx - 1]

                

                # 修复：统一数字格式，避免长小数

                if isinstance(value, (int, float)):

                    cell.value = value

                    if '%' in str(col_name) or '率' in str(col_name) or '比' in str(col_name):

                        # 比率列：1位小数百分比

                        cell.number_format = '0.0%'

                    elif '(U)' in str(col_name) or '金额' in str(col_name) or '成本' in str(col_name) or 'LTV' in str(col_name):

                        # 金额列：千分位+2位小数

                        cell.number_format = '#,##0.00'

                    elif '人数' in str(col_name) or '用户' in str(col_name):

                        # 人数列：千分位整数

                        cell.number_format = '#,##0'

                    else:

                        cell.number_format = 'General'

                else:

                    # 修复：处理空值，避免nan/None导致显示异常

                    if pd.isna(value) or value == '' or str(value).lower() in ['nan', 'none']:

                        cell.value = ''

                    else:

                        cell.value = value

                

                # 设置边框

                cell.border = Border(

                    left=Side(style='thin', color='000000'),

                    right=Side(style='thin', color='000000'),

                    top=Side(style='thin', color='000000'),

                    bottom=Side(style='thin', color='000000')

                )

    

    def _apply_zebra_striping(self, ws, df, start_row):

        """应用斑马纹：奇行浅蓝，偶行更浅蓝 - 强化对比"""

        odd_fill = PatternFill(start_color='E9F0F8', end_color='E9F0F8', fill_type='solid')

        even_fill = PatternFill(start_color='F6FAFF', end_color='F6FAFF', fill_type='solid')

        

        for row_idx in range(start_row + 1, start_row + len(df) + 1):

            for col_idx in range(1, len(df.columns) + 1):

                cell = ws.cell(row=row_idx, column=col_idx)

                

                # 跳过特殊行（总计/日均）

                if row_idx - start_row - 1 < len(df):

                    row_data = df.iloc[row_idx - start_row - 1]

                    if row_data.iloc[0] in ['总计', '日均']:

                        continue

                

                # 应用斑马纹

                if (row_idx - start_row) % 2 == 1:  # 奇行

                    cell.fill = odd_fill

                else:  # 偶行

                    cell.fill = even_fill

    

    def _apply_data_bars(self, ws, df, start_row):

        """应用数据条：按VNL报表规范设置"""

        # 根据报表类型设置不同的列配置

        if '大盘日报' in ws.title:

            self._apply_daily_summary_formatting(ws, df, start_row)

        elif any(x in ws.title for x in ['短信日报', '网红日报', '投放日报']):

            self._apply_channel_daily_formatting(ws, df, start_row)

        elif '投放明细' in ws.title:

            self._apply_detail_formatting(ws, df, start_row)

    

    def _apply_daily_summary_formatting(self, ws, df, start_row):

        """VNL大盘日报格式化"""

        # 修复：数据条列配置，避免与数值层叠

        data_bar_columns = {

            '总消耗(U)': {'color': '4F81BD', 'show_value': True, 'width': 12},

            '充值金额(U)': {'color': '4F81BD', 'show_value': True, 'width': 12},

            '新增注册人数': {'color': '4F81BD', 'show_value': False, 'width': 10},

            '首充人数': {'color': '4F81BD', 'show_value': False, 'width': 10},

            '充值人数': {'color': '4F81BD', 'show_value': False, 'width': 10},

        }

        

        # 渐变热力色列

        heatmap_columns = {

            '首充次日复充率': {'color': '4F81BD'},

            '首充3日 复充率': {'color': '4F81BD'},
            '首充7日 复充率': {'color': '4F81BD'},
            '首充30日 复充率': {'color': '4F81BD'},
            '首充次日复登率': {'color': '4F81BD'},

            '首充3日复登率': {'color': '4F81BD'},

            '首充7日复登率': {'color': '4F81BD'},

        }

        

        # 负值红字列

        negative_columns = {

            '总充提差(U)': {'threshold': 0},

            '历史营收(历史充提差-历史消耗)': {'threshold': 0},

            '历史充提差': {'threshold': 0},

        }

        

        self._apply_conditional_formatting(ws, df, start_row, data_bar_columns, heatmap_columns, negative_columns)

    

    def _apply_channel_daily_formatting(self, ws, df, start_row):

        """VNL短信/网红/投放日报格式化"""

        # 数据条列

        data_bar_columns = {

            '消耗': {'color': '4F81BD'},

            '充值金额': {'color': '4F81BD'},

            '新增用户': {'color': '4F81BD'},

            '首充人数': {'color': '4F81BD'},

            '当日消耗(U)': {'color': '4F81BD'},

            '充值金额(U)': {'color': '4F81BD'},

            '新增注册人数': {'color': '4F81BD'},

        }

        

        # 渐变热力色列 - 留存/复登/复充

        heatmap_columns = {

            '次日': {'color': '4F81BD'},

            '3日': {'color': '4F81BD'},

            '4日': {'color': '4F81BD'},

            '5日': {'color': '4F81BD'},

            '6日': {'color': '4F81BD'},

            '7日': {'color': '4F81BD'},

            '30日': {'color': '4F81BD'},

            '首充次日复充率': {'color': '4F81BD'},

            '首充3日 复充率': {'color': '4F81BD'},
            '首充7日 复充率': {'color': '4F81BD'},
            '首充30日 复充率': {'color': '4F81BD'},
            '首充次日复登率': {'color': '4F81BD'},

            '首充3日复登率': {'color': '4F81BD'},

            '首充7日复登率': {'color': '4F81BD'},

        }

        

        # 负值红字列

        negative_columns = {

            'ROI': {'threshold': 0},

            '净差': {'threshold': 0},

            '利润': {'threshold': 0},

            '充提差': {'threshold': 0},

            '历史营收(历史充提差-历史消耗)': {'threshold': 0},

            '历史充提差': {'threshold': 0},

        }

        

        self._apply_conditional_formatting(ws, df, start_row, data_bar_columns, heatmap_columns, negative_columns)

    

    def _apply_detail_formatting(self, ws, df, start_row):

        """VNL投放明细格式化"""

        # 数据条列

        data_bar_columns = {

            '当日消耗($)': {'color': '4F81BD'},

            '首充金额': {'color': '4F81BD'},

            '非首充充值金额': {'color': '4F81BD'},

            '首充人数': {'color': '4F81BD'},

            '非首充人数': {'color': '4F81BD'},

            '新增用户': {'color': '4F81BD'},

            '充值人数': {'color': '4F81BD'},

        }

        

        # 负值红字列

        negative_columns = {

            'ROI': {'threshold': 0},

            '净差': {'threshold': 0},

            '利润': {'threshold': 0},

            '充提差': {'threshold': 0},

        }

        

        # 渐变热力色列 - 留存/复登/复充

        heatmap_columns = {

            '次日': {'color': '4F81BD'},

            '3日': {'color': '4F81BD'},

            '4日': {'color': '4F81BD'},

            '5日': {'color': '4F81BD'},

            '6日': {'color': '4F81BD'},

            '7日': {'color': '4F81BD'},

            '30日': {'color': '4F81BD'},

            '首充次日复充率': {'color': '4F81BD'},

            '首充3日 复充率': {'color': '4F81BD'},
            '首充7日 复充率': {'color': '4F81BD'},
            '首充30日 复充率': {'color': '4F81BD'},
            '首充次日复登率': {'color': '4F81BD'},

            '首充3日复登率': {'color': '4F81BD'},

            '首充7日复登率': {'color': '4F81BD'},

        }

        

        self._apply_conditional_formatting(ws, df, start_row, data_bar_columns, heatmap_columns, negative_columns)

    

    def _apply_conditional_formatting(self, ws, df, start_row, data_bar_columns, heatmap_columns, negative_columns):

        """应用条件格式化：数据条、热力色、负值红字 - 排除总计和日均行"""

        

        # 计算数据行范围，排除总计和日均行

        data_rows = []

        for i, row in df.iterrows():

            if row.iloc[0] not in ['总计', '日均']:  # 排除总计和日均行

                data_rows.append(i + start_row + 1)  # +1是因为数据从start_row+1开始

        

        if not data_rows:

            return

        

        # 1. 数据条 - 只应用到非总计/日均行

        for col_name, config in data_bar_columns.items():

            if col_name in df.columns:

                col_idx = list(df.columns).index(col_name) + 1

                start_data_row = min(data_rows)

                end_data_row = max(data_rows)

                data_range = f"{chr(64 + col_idx)}{start_data_row}:{chr(64 + col_idx)}{end_data_row}"

                

                data_bar = DataBarRule(

                    start_type='min',

                    start_value=0,

                    end_type='max',

                    end_value=None,

                    color=config['color'],

                    showValue=True,

                    minLength=None,

                    maxLength=None

                )

                try:

                    ws.conditional_formatting.add(data_range, data_bar)

                except:

                    pass

        

        # 2. 渐变热力色 - 只应用到非总计/日均行

        for col_name, config in heatmap_columns.items():

            if col_name in df.columns:

                col_idx = list(df.columns).index(col_name) + 1

                start_data_row = min(data_rows)

                end_data_row = max(data_rows)

                data_range = f"{chr(64 + col_idx)}{start_data_row}:{chr(64 + col_idx)}{end_data_row}"

                

                color_scale = ColorScaleRule(

                    start_type='min',

                    start_color=config['color'] + '20',  # 浅色

                    mid_type='percentile',

                    mid_value=50,

                    mid_color=config['color'] + '60',  # 中色

                    end_type='max',

                    end_color=config['color'] + 'FF'   # 深色

                )

                try:

                    ws.conditional_formatting.add(data_range, color_scale)

                except:

                    pass

        

        # 3. 负值红字 - 只应用到非总计/日均行

        for col_name, config in negative_columns.items():

            if col_name in df.columns:

                col_idx = list(df.columns).index(col_name) + 1

                start_data_row = min(data_rows)

                end_data_row = max(data_rows)

                data_range = f"{chr(64 + col_idx)}{start_data_row}:{chr(64 + col_idx)}{end_data_row}"

                

                red_font = Font(color='FF0000')

                negative_rule = CellIsRule(operator='lessThan', formula=[str(config['threshold'])], font=red_font)

                try:

                    ws.conditional_formatting.add(data_range, negative_rule)

                except:

                    pass

    

    def _format_special_rows(self, ws, df, start_row):

        """设置特殊行样式：总计/日均 - 强化块感"""

        total_fill = PatternFill(start_color='D9E1F2', end_color='D9E1F2', fill_type='solid')

        avg_fill = PatternFill(start_color='EDEFF7', end_color='EDEFF7', fill_type='solid')

        

        for row_idx in range(start_row + 1, start_row + len(df) + 1):

            if row_idx - start_row - 1 < len(df):

                row_data = df.iloc[row_idx - start_row - 1]

                if row_data.iloc[0] == '总计':

                    for col_idx in range(1, len(df.columns) + 1):

                        cell = ws.cell(row=row_idx, column=col_idx)

                        cell.fill = total_fill

                        cell.font = Font(name='Microsoft YaHei', size=10, bold=True)

                elif row_data.iloc[0] == '日均':

                    for col_idx in range(1, len(df.columns) + 1):

                        cell = ws.cell(row=row_idx, column=col_idx)

                        cell.fill = avg_fill

                        cell.font = Font(name='Microsoft YaHei', size=10, italic=True)

    

    def _setup_page_layout(self, ws):

        """设置页面布局：A3横向+1页宽×高度自动 - 修复：避免文字拥挤"""

        # 修复：A3横向，1页宽×高度自动，不强制压缩

        ws.page_setup.orientation = 'landscape'

        ws.page_setup.paperSize = 8  # A3

        ws.page_setup.fitToWidth = 1  # 1页宽

        ws.page_setup.fitToHeight = 0  # 高度自动，不强制压缩

        

        # 设置窄边距，为内容争取横向空间

        ws.page_margins = PageMargins(

            left=0.5, right=0.5, top=0.5, bottom=0.5,

            header=0.3, footer=0.3

        )

        

        # 设置打印标题行

        ws.print_title_rows = '1:2'  # 表头行重复
        

        # 修复：分级设置列宽，避免文字拥挤

        self._set_column_widths(ws)

        

        # 设置打印区域（只包含关键列）

        self._set_print_area(ws)

        

        # 水平居中

        ws.print_options.horizontalCentered = True

    

    def _set_column_widths(self, ws):

        """分级设置列宽 - 修复：避免文字拥挤"""

        for col in range(1, min(ws.max_column + 1, 27)):  # 限制在A-Z范围内

            col_letter = chr(64 + col)

            

            # 获取列标题判断列类型

            header_cell = ws.cell(row=1, column=col)

            header_text = str(header_cell.value or '').lower()

            

            if '日期' in header_text or '时间' in header_text:

                ws.column_dimensions[col_letter].width = 10  # 日期列

            elif any(keyword in header_text for keyword in ['金额', '消耗', '成本', 'usd', 'u)']):

                ws.column_dimensions[col_letter].width = 12  # 货币列

            elif any(keyword in header_text for keyword in ['率', '比', '%', 'ratio']):

                ws.column_dimensions[col_letter].width = 10  # 百分比列

            elif any(keyword in header_text for keyword in ['人数', '用户', 'count']):

                ws.column_dimensions[col_letter].width = 10  # 人数列

            elif any(keyword in header_text for keyword in ['渠道', '方式', '分组', '名称']):

                ws.column_dimensions[col_letter].width = 18  # 文本列

            else:

                ws.column_dimensions[col_letter].width = 10  # 默认列宽

    

    def _set_print_area(self, ws):

        """设置打印区域 - 修复：只包含关键列，排除辅助列"""

        # 只包含关键列，排除辅助列

        max_col = min(ws.max_column, 26)  # 限制在A-Z范围内

        if max_col > 0:

            ws.print_area = f'A1:{chr(64 + max_col)}{ws.max_row}'

    

    def _apply_alternating_colors(self, ws, data_rows):

        """应用交替底色 - 修复：避免文字拥挤"""

        alt_fill = PatternFill(start_color='F9F9F9', end_color='F9F9F9', fill_type='solid')

        

        # 从数据行开始应用交替底色（跳过表头）

        start_row = 4  # 假设表头占3行

        for row in range(start_row, start_row + data_rows):

            if row % 2 == 0:  # 偶数行

                for col in range(1, ws.max_column + 1):

                    cell = ws.cell(row=row, column=col)

                    cell.fill = alt_fill

    

    def create_pdf_report(self, df_dict, title, filename):

        """创建PDF报表 - 直接转换Excel文件"""

        print("Generating PDF...")

        

        # 根据title找到对应的Excel文件

        excel_filename = None

        if 'VNL投放日报' in title:

            excel_filename = 'VNL投放日报-1015.xlsx'

        elif 'VNL短信日报' in title:

            excel_filename = 'VNL短信日报-1015.xlsx'

        elif 'VNL网红日报' in title:

            excel_filename = 'VNL网红日报-1015.xlsx'

        elif 'VNL投放明细' in title:

            excel_filename = 'VNL投放明细-1015.xlsx'

        elif 'VNL大盘日报' in title:

            excel_filename = 'VNL日报-1015.xlsx'

        

        if not excel_filename or not os.path.exists(excel_filename):

            print(f"  Warning: Excel file not found: {excel_filename}")

            return

        

        try:

            # 使用openpyxl读取Excel文件

            from openpyxl import load_workbook

            wb = load_workbook(excel_filename)

            

            # 选择打印sheet（如果存在），否则使用第一个sheet

            if f"{title}_打印" in wb.sheetnames:
                ws = wb[f"{title}_打印"]

            else:

                ws = wb.active

            

            # 使用matplotlib将Excel转换为PDF

            import matplotlib.pyplot as plt

            from matplotlib.backends.backend_pdf import PdfPages

            

            # 创建PDF文件

            with PdfPages(filename) as pdf:

                # 设置页面尺寸

                fig_width = 11.69 if '明细' in title else 8.27

                fig_height = 8.27

                

                # 创建图形

                fig, ax = plt.subplots(figsize=(fig_width, fig_height))

                ax.axis('off')

                

                # 读取Excel数据并转换为表格

                data = []

                for row in ws.iter_rows(values_only=True):

                    if any(cell is not None for cell in row):  # 跳过空行

                        data.append([str(cell) if cell is not None else '' for cell in row])

                

                if data:

                    # 创建表格

                    table = ax.table(cellText=data, loc='center', cellLoc='center')

                    table.auto_set_font_size(False)

                    table.set_fontsize(8)

                    table.scale(1, 1.5)

                    

                    # 设置表格样式

                    for i in range(len(data)):

                        for j in range(len(data[i])):

                            cell = table[(i, j)]

                            if i == 0:  # 表头

                                cell.set_facecolor('#1F4E78')

                                cell.set_text_props(weight='bold', color='white')

                            elif i % 2 == 0:  # 偶数行

                                cell.set_facecolor('#F6FAFF')

                            else:  # 奇数行

                                cell.set_facecolor('#E9F0F8')

                

                # 保存为PDF

                pdf.savefig(fig, bbox_inches='tight', dpi=300)

                plt.close(fig)

            

            print(f"  PDF saved successfully")

            

        except Exception as e:

            print(f"  Error creating PDF: {e}")

            return

    

    def generate_all_reports(self):

        """生成所有报表"""

        print("Starting VNL report generation...")

        

        # 加载数据

        df = self.load_data()

        

        # 生成Excel报表
        reports = [

            ("VNL投放日报", "VNL投放日报-1018.xlsx"),
            ("VNL短信日报", "VNL短信日报-1018.xlsx"),
            ("VNL网红日报", "VNL网红日报-1018.xlsx"),
            ("VNL投放明细", "VNL投放明细-1018.xlsx"),
            ("VNL大盘日报", "VNL大盘日报-1018.xlsx")
        ]

        

        for title, filename in reports:

            self.create_excel_report(df, title, filename)

        

        # 生成产品二-VNL日报

        print("Generating 产品二-VNL日报...")
        self.create_excel_report(df, "产品二-VNL日报", "产品二-VNL日报.xlsx")
        

        # 跳过PDF生成，只生成Excel文件（提高速度）

        print("Skipping PDF generation for faster execution...")

        # pdf_reports = [

        #     ("VNL投放日报", "VNL投放日报-1015.pdf"),

        #     ("VNL短信日报", "VNL短信日报-1015.pdf"),

        #     ("VNL网红日报", "VNL网红日报-1015.pdf"),

        #     ("VNL投放明细", "VNL投放明细-1015.pdf"),

        #     ("VNL大盘日报", "VNL日报-1015.pdf")

        # ]

        

        # for title, filename in pdf_reports:

        #     self.create_pdf_report(df, title, filename)

        

        print("All reports generated successfully!")

    

    def _generate_daily_summary_data(self, df_dict):

        """生成VNL大盘日报的汇总数据"""

        # 从后台sheet获取基础数据

        backend_data = df_dict.get('后台', pd.DataFrame())

        ltv_data = df_dict.get('LTV', pd.DataFrame())
        

        # 加载留存数据

        retention_data = self._load_retention_data()

        

        if backend_data.empty:

            print("Warning: No backend data for VNL大盘日报")
            return self._get_mock_data()

        

        if ltv_data.empty:

            print("Warning: No LTV data for VNL大盘日报")
            return self._get_mock_data()

        

        # 处理日期格式 - 修复日期解析问题

        if '时间' in backend_data.columns:

            # 使用dayfirst=True来正确解析日期格式 (1/9/2025 = 2025年9月1日)

            backend_data['时间'] = pd.to_datetime(backend_data['时间'], dayfirst=True, errors='coerce')

            backend_data = backend_data.dropna(subset=['时间'])

            backend_data = backend_data.sort_values('时间')

        

        # 处理LTV数据日期格式 - 修复日期解析问题

        if '时间' in ltv_data.columns:

            # LTV数据已经是ISO格式(2025-09-01)，直接解析即可

            ltv_data['时间'] = pd.to_datetime(ltv_data['时间'], errors='coerce')

            ltv_data = ltv_data.dropna(subset=['时间'])

            ltv_data = ltv_data.sort_values('时间')

            print(f"Debug: LTV数据日期范围: {ltv_data['时间'].min()} 到 {ltv_data['时间'].max()}")
            

            # 清理消耗数据中的美元符号

            if '消耗' in ltv_data.columns:

                ltv_data['消耗'] = ltv_data['消耗'].astype(str).str.replace('$', '').str.replace(',', '')

                ltv_data['消耗'] = pd.to_numeric(ltv_data['消耗'], errors='coerce').fillna(0)

                print(f"Debug: 消耗数据范围: {ltv_data['消耗'].min()} 到 {ltv_data['消耗'].max()}")
            

            # 清理LTV数据中的美元符号 - 检查多种可能的字段名

            ltv_columns_to_clean = ['14日LTV', '30日LTV', 'LTV14', 'LTV30', '14日', '30日']

            for col in ltv_columns_to_clean:

                if col in ltv_data.columns:

                    ltv_data[col] = ltv_data[col].astype(str).str.replace('$', '').str.replace(',', '')

                    ltv_data[col] = pd.to_numeric(ltv_data[col], errors='coerce').fillna(0)

        

        daily_data_list = []

        

        # 为每一天计算指标

        for _, row in backend_data.iterrows():

            date_str = row['时间'].strftime('%Y-%m-%d') if pd.notna(row['时间']) else '未知日期'
            

            # 从LTV sheet获取当日消耗数据（已经是美元，不需要汇率换算）

            # 使用更灵活的日期匹配

            backend_date = row['时间'].date() if pd.notna(row['时间']) else None

            ltv_row = pd.DataFrame()

            

            if not ltv_data.empty and backend_date:

                # 尝试精确日期匹配

                ltv_row = ltv_data[ltv_data['时间'].dt.date == backend_date]

                

                # 如果精确匹配失败，尝试日期字符串匹配

                if ltv_row.empty:

                    backend_date_str = row['时间'].strftime('%Y-%m-%d')

                    ltv_row = ltv_data[ltv_data['时间'].dt.strftime('%Y-%m-%d') == backend_date_str]

                

                # 如果还是失败，尝试容差匹配（前后1天）

                if ltv_row.empty and backend_date:

                    try:

                        # 确保时间列是datetime类型

                        if ltv_data['时间'].dtype == 'object':

                            ltv_data['时间'] = pd.to_datetime(ltv_data['时间'], errors='coerce')

                        

                        # 计算日期差异 - 修复计算逻辑

                        # 使用 apply 来计算每个日期与目标日期的差异

                        date_diff = ltv_data['时间'].apply(lambda x: abs((x.date() - backend_date).days) if pd.notna(x) else 999)

                        if (date_diff <= 1).any():

                            ltv_row = ltv_data[date_diff <= 1].iloc[[0]]  # 取最接近的日期

                    except Exception as e:

                        print(f"Debug: 日期容差匹配失败: {e}")
            

            if not ltv_row.empty:

                # 当日消耗（不是累计消耗）- 处理美元符号和格式

                consumption_raw = ltv_row.iloc[0].get('消耗', 0)

                if pd.isna(consumption_raw):

                    daily_consumption = 0

                else:

                    # 处理美元符号和逗号

                    consumption_str = str(consumption_raw).replace('$', '').replace(',', '')

                    daily_consumption = pd.to_numeric(consumption_str, errors='coerce')

                    if pd.isna(daily_consumption):

                        daily_consumption = 0

                

                print(f"Debug: 找到LTV数据，日期: {backend_date}, 原始消耗: {consumption_raw}, 处理后消耗: {daily_consumption}")
                

                # 计算LTV数据 - 公式：(充值金额 - 提现金额) ÷ 充值人数
                ltv_14 = 0

                ltv_30 = 0

                

                # 获取充值金额和提现金额
                recharge_amount_ltv = pd.to_numeric(ltv_row.iloc[0].get('充值金额', 0), errors='coerce')
                withdraw_amount_ltv = pd.to_numeric(ltv_row.iloc[0].get('提现金额', 0), errors='coerce')
                recharge_users_ltv = pd.to_numeric(ltv_row.iloc[0].get('充值人数', 0), errors='coerce')
                
                if pd.isna(recharge_amount_ltv):
                    recharge_amount_ltv = 0
                if pd.isna(withdraw_amount_ltv):
                    withdraw_amount_ltv = 0
                if pd.isna(recharge_users_ltv):

                    recharge_users_ltv = 0

                

                # 计算充提差
                charge_withdraw_diff = recharge_amount_ltv - withdraw_amount_ltv
                
                # 计算LTV - 使用公式：(充值金额 - 提现金额) ÷ 充值人数
                # 14日LTV和30日LTV应该从不同的数据源或时间点计算
                
                # 先计算基础LTV值
                if recharge_users_ltv > 0:

                    base_ltv = charge_withdraw_diff / recharge_users_ltv

                    print(f"Debug: 基础LTV计算 - 充提差: {charge_withdraw_diff}, 充值人数: {recharge_users_ltv}, LTV: {base_ltv}")
                else:
                    base_ltv = 0
                    print(f"Debug: 充值人数为0，LTV设为0")
                
                # 尝试获取14日和30日的LTV数据
                # 14日LTV：从14天前的数据计算
                ltv_14 = self._calculate_ltv_for_period(ltv_data, backend_date, 14)
                # 30日LTV：从30天前的数据计算  
                ltv_30 = self._calculate_ltv_for_period(ltv_data, backend_date, 30)
                
                # 如果没有找到对应日期的数据，使用当前日期的LTV
                if ltv_14 == 0:
                    ltv_14 = base_ltv

                if ltv_30 == 0:
                    ltv_30 = base_ltv

                
                print(f"Debug: LTV计算结果 - 14日LTV: {ltv_14}, 30日LTV: {ltv_30}")
                    
                print(f"Debug: LTV计算 - 充值金额: {recharge_amount_ltv}, 提现金额: {withdraw_amount_ltv}, 充值人数: {recharge_users_ltv}")
                print(f"Debug: LTV计算结果 - 14日: {ltv_14}, 30日: {ltv_30}")
            else:

                daily_consumption = 0

                ltv_14 = 0

                ltv_30 = 0

                print(f"Debug: 未找到LTV数据，日期: {backend_date}")
                if not ltv_data.empty:

                    print(f"Debug: 可用LTV日期: {ltv_data['时间'].dt.date.tolist()[:5]}")
            

            # 使用当日消耗（不是累计消耗）

            total_consumption = daily_consumption

            print(f"Debug: 总消耗计算 - 当日消耗: {daily_consumption}, 总消耗: {total_consumption}")
            

            # 如果LTV数据中的消耗为0，尝试从后台数据获取

            if total_consumption == 0:

                # 尝试从后台数据获取消耗数据

                backend_consumption = pd.to_numeric(row.get('当日消耗', 0), errors='coerce')

                if pd.isna(backend_consumption):

                    backend_consumption = 0

                if backend_consumption > 0:

                    total_consumption = backend_consumption

                    print(f"Debug: 从后台数据获取消耗: {total_consumption}")
                else:

                    print(f"Debug: 警告 - 总消耗为0，检查数据源")
            

            # 计算历史消耗（累计消耗）

            # 从后台数据获取历史消耗，如果没有则使用当日消耗
            historical_consumption = pd.to_numeric(row.get('历史消耗', 0), errors='coerce')
            if pd.isna(historical_consumption):
                historical_consumption = total_consumption  # 如果没有历史消耗数据，使用当日消耗
            print(f"Debug: 历史消耗: {historical_consumption}")
            

            # 后台sheet数据需要汇率换算

            recharge_amount = pd.to_numeric(row.get('商城充值金额', 0), errors='coerce') / self.EXCHANGE_RATE

            recharge_count = pd.to_numeric(row.get('商城充值次数', 0), errors='coerce')

            recharge_users = pd.to_numeric(row.get('充值人数', 0), errors='coerce')

            new_users = pd.to_numeric(row.get('新增人员', 0), errors='coerce')

            first_recharge_users = pd.to_numeric(row.get('首充人数', 0), errors='coerce')

            first_level_users = pd.to_numeric(row.get('一级首充人数', 0), errors='coerce')

            

            # 调试信息：检查首充人数和一级首充人数数据

            print(f"Debug: 首充人数: {first_recharge_users}, 一级首充人数: {first_level_users}")
            if first_level_users == 0:

                print(f"Debug: 一级首充人数为0，检查数据源字段: {list(row.keys())}")
                print(f"Debug: 一级首充人数原始值: {row.get('一级首充人数', '字段不存在')}")
                # 尝试其他可能的字段名

                for key in row.keys():

                    if '一级' in str(key) or 'level' in str(key).lower():

                        print(f"Debug: 找到可能的字段: {key} = {row.get(key)}")
            

            if first_recharge_users == 0:

                print(f"Debug: 首充人数为0，检查数据源字段: {list(row.keys())}")
                print(f"Debug: 首充人数原始值: {row.get('首充人数', '字段不存在')}")
                # 尝试其他可能的字段名

                for key in row.keys():

                    if '首充' in str(key) and '人数' in str(key):

                        print(f"Debug: 找到可能的字段: {key} = {row.get(key)}")
            

            # 计算派生指标

            first_recharge_amount = pd.to_numeric(row.get('首充用户总充值金额', 0), errors='coerce') / self.EXCHANGE_RATE

            old_user_amount = recharge_amount - first_recharge_amount

            old_user_count = recharge_users - first_recharge_users

            

            # 成本计算

            first_recharge_cost = total_consumption / first_recharge_users if first_recharge_users > 0 else 0

            first_level_cost = total_consumption / first_level_users if first_level_users > 0 else 0

            

            print(f"Debug: 成本计算 - 总消耗: {total_consumption}, 首充人数: {first_recharge_users}, 一级首充人数: {first_level_users}")
            print(f"Debug: 首充成本: {first_recharge_cost}, 一级首充成本: {first_level_cost}")
            

            # 人均指标

            avg_recharge_amount = recharge_amount / recharge_users if recharge_users > 0 else 0

            avg_recharge_count = recharge_count / recharge_users if recharge_users > 0 else 0

            first_recharge_avg = first_recharge_amount / first_recharge_users if first_recharge_users > 0 else 0

            old_user_avg = old_user_amount / old_user_count if old_user_count > 0 else 0

            

            # 比率计算

            charge_withdraw_amount = row.get('充提差', 0) / self.EXCHANGE_RATE  # 充提差也需要汇率换算

            charge_withdraw_ratio = charge_withdraw_amount / recharge_amount if recharge_amount > 0 else 0

            # 修复：老用户付费率 = (充值人数 - 首充人数) / 充值人数

            old_user_pay_rate = (recharge_users - first_recharge_users) / recharge_users if recharge_users > 0 else 0

            first_recharge_rate = first_recharge_users / new_users if new_users > 0 else 0

            

            # 从留存数据获取复登/复充率

            retention_rates = self._get_retention_rates(retention_data, date_str, first_recharge_users)

            print(f"Debug: 留存数据获取结果: {retention_rates}")
            

            # 从各个渠道LTV数据中汇总复登率

            ltv_aggregated_rates = self._aggregate_retention_from_ltv(df_dict, date_str)

            print(f"Debug: LTV汇总留存率: {ltv_aggregated_rates}")
            

            # 将汇总的复登率合并到留存率中

            retention_rates.update(ltv_aggregated_rates)

            

            # 如果留存数据为空，尝试从后台数据直接获取

            if not retention_rates:

                retention_rates = self._get_retention_from_backend(row, first_recharge_users)

                print(f"Debug: 从后台数据获取留存率: {retention_rates}")
            

            # 从后台sheet获取首充复投率

            # 根据公式：首充复投率 = 首充用户X日投注人数 ÷ 首充人数
            first_recharge_betting_rates = {}

            betting_retention_days = ['次日', '3日', '7日']

            for day in betting_retention_days:

                # 从后台sheet获取对应日期的首充复投率数据

                betting_rate_key = f'首充{day}复投率'

                if betting_rate_key in row:

                    # 如果后台sheet直接有复投率数据

                    betting_rate = pd.to_numeric(row.get(betting_rate_key, 0), errors='coerce')
                    if pd.isna(betting_rate):

                        betting_rate = 0

                    first_recharge_betting_rates[f'首充{day}复投率'] = betting_rate
                else:

                    # 如果没有直接数据，尝试计算：首充用户X日投注人数 ÷ 首充人数
                    betting_users_key = f'首充{day}投注人数'
                    if betting_users_key in row and first_recharge_users > 0:
                        betting_users = pd.to_numeric(row.get(betting_users_key, 0), errors='coerce')
                        if pd.isna(betting_users):
                            betting_users = 0
                        first_recharge_betting_rates[f'首充{day}复投率'] = betting_users / first_recharge_users
                    else:

                        first_recharge_betting_rates[f'首充{day}复投率'] = 0
            

            # 计算非一级首充人数

            non_first_level_users = first_recharge_users - first_level_users

            print(f"Debug: 非一级首充人数计算: {first_recharge_users} - {first_level_users} = {non_first_level_users}")
            

            # 计算非一级首充人数/首充人数比率

            non_first_level_ratio = non_first_level_users / first_recharge_users if first_recharge_users > 0 else 0

            print(f"Debug: 非一级首充人数/首充人数比率: {non_first_level_ratio}")
            

            # 根据VNL大盘日报表头生成数据

            daily_row = {

                '日期': date_str,

                '总消耗(U)': total_consumption,

                '首充成本(U)': first_recharge_cost,

                '一级首充成本(U)': first_level_cost,

                '充提差比': charge_withdraw_ratio,

                '总充提差(U)': row.get('充提差', 0) / self.EXCHANGE_RATE,

                '充值金额(U)': recharge_amount,

                '首充充值金额(U)': first_recharge_amount,

                '老用户充值金额(U)': old_user_amount,

                '人均充值金额(U)': avg_recharge_amount,

                '人均充值笔数': avg_recharge_count,

                '首充人均充值金额(U)': first_recharge_avg,

                '老用户人均充值金额U': old_user_avg,

                '老用户付费率': old_user_pay_rate,

                '14日LTV': ltv_14,

                '30日LTV': ltv_30,

                '首充次日复充率': retention_rates.get('首充次日复充率', 0),

                '首充3日 复充率': retention_rates.get('首充3日 复充率', 0),
                '首充7日 复充率': retention_rates.get('首充7日 复充率', 0),
                '首充30日 复充率': retention_rates.get('首充30日 复充率', 0),
                '非一级首充人数/首充人数': (first_recharge_users - first_level_users) / first_recharge_users if first_recharge_users > 0 else 0,
                '非一级首充人数/充值人数': (first_recharge_users - first_level_users) / recharge_users if recharge_users > 0 else 0,
                '首充数转化率': first_recharge_rate,

                '新增注册人数': new_users,

                '首充人数': first_recharge_users,

                '一级首充人数': first_level_users,

                '充值人数': recharge_users,

                '日期': date_str,  # 重复的日期字段

                '投注用户数': row.get('投注人数', 0),

                '充投用户数': row.get('充值投注人数', 0),

                '首充次日复登率': retention_rates.get('首充次日复登率', 0),

                '首充3日复登率': retention_rates.get('首充3日复登率', 0),

                '首充7日复登率': retention_rates.get('首充7日复登率', 0),

                '首充次日复投率': first_recharge_betting_rates.get('首充次日复投率', 0),
                '首充3日复投率': first_recharge_betting_rates.get('首充3日复投率', 0),
                '首充7日复投率': first_recharge_betting_rates.get('首充7日复投率', 0),
                '投注金额(U)': round(row.get('当日总流水', 0) / self.EXCHANGE_RATE, 2),

                '出入人数比': row.get('提现人数', 0) / recharge_users if recharge_users > 0 else 0,

                '游戏盈亏投注比': row.get('当日总盈利', 0) / row.get('当日总流水', 1) if row.get('当日总流水', 0) > 0 else 0,

                '投充比': row.get('今日投充比', 0),

                '佣金金额(U)': row.get('实际到账金币', 0) / self.EXCHANGE_RATE,

                '彩金赠送充值比': (row.get('总赠送', 0) / self.EXCHANGE_RATE) / recharge_amount if recharge_amount > 0 else 0,

                '历史营收(历史充提差-历史消耗)': (row.get('充提差', 0) / self.EXCHANGE_RATE) - historical_consumption,

                '历史充提差': row.get('充提差', 0) / self.EXCHANGE_RATE,

                '历史消耗': historical_consumption

            }

            daily_data_list.append(daily_row)

        

        # 计算总计和日均

        if daily_data_list:

            df = pd.DataFrame(daily_data_list)

            total_data, avg_data = self._calculate_summary_metrics(df)

            return pd.concat([df, pd.DataFrame([total_data, avg_data])], ignore_index=True)

        

        return self._get_mock_data()



def main():

        generator = VNLReportGenerator()

        generator.generate_all_reports()



if __name__ == "__main__":

    main()

