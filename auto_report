## VERSION: forcehash_v3 + aria_combobox helper + generic_dropdown + continue_if_missing
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import asyncio, argparse, contextlib, datetime as dt, json, os, re
from pathlib import Path
from typing import Optional
from playwright.async_api import async_playwright, Page, BrowserContext

# ---------- Utils ----------
def sanitize_filename(name: str) -> str:
    name = re.sub(r"[\\/:*?\"<>|]+", "_", name)
    name = re.sub(r"\s+", " ", name).strip()
    return name[:180]

def page_of(scope):
    return getattr(scope, "page", scope)


# --- Helpers: robust platform dropdown opening ---
async def _try_expand_filters(scope):
    """Try to expand hidden filter panels (common in Element/AntD UIs)."""
    pg = page_of(scope)
    texts = ["ç­›é€‰", "æ›´å¤š", "é«˜çº§", "å±•å¼€", "æ›´å¤šç­›é€‰", "æ¡ä»¶", "å¹³å°"]
    for t in texts:
        try:
            locs = [
                scope.get_by_role("button", name=re.compile(re.escape(t))),
                scope.locator("button, .el-button, .ant-btn").filter(has_text=re.compile(re.escape(t))),
                scope.get_by_text(re.compile(re.escape(t)))
            ]
            for lc in locs:
                if await lc.count():
                    el = lc.first
                    with contextlib.suppress(Exception): await el.scroll_into_view_if_needed()
                    with contextlib.suppress(Exception): await el.click()
                    with contextlib.suppress(Exception): await pg.wait_for_timeout(150)
        except Exception:
            pass

async def _open_platform_dropdown(scope, select_idx: int) -> bool:
    """Try many ways to open platform dropdown. Return True if options likely visible."""
    pg = page_of(scope)
    await _try_expand_filters(scope)

    # candidate containers
    candidates = [
        "[role='combobox']",
        ".el-select .el-select__selection",
        ".el-select .select-trigger",
        ".ant-select-selector",
        ".el-select",
        ".mx-input",
        ".vxe-select--wrapper",
    ]

    box = None
    for css in candidates:
        loc = scope.locator(css)
        try:
            cnt = await loc.count()
        except Exception:
            cnt = 0
        if cnt:
            box = loc.nth(select_idx if select_idx < cnt else 0); break

    if box is None:
        return False

    # Scroll into view
    with contextlib.suppress(Exception):
        await box.scroll_into_view_if_needed()

    # Several click strategies
    strategies = []

    # 1) Click container
    strategies.append(lambda: box.click())
    # 2) Force click
    strategies.append(lambda: box.click(force=True))
    # 3) Click caret/icon within
    strategies.append(lambda: box.locator(".el-select__caret, .el-select__suffix, .ant-select-arrow").click())
    strategies.append(lambda: box.locator(".el-select__caret, .el-select__suffix, .ant-select-arrow").click(force=True))
    # 4) Focus input and press keys
    strategies.append(lambda: box.press("Enter"))
    strategies.append(lambda: box.press("Space"))
    strategies.append(lambda: box.press("ArrowDown"))

    for action in strategies:
        with contextlib.suppress(Exception):
            await action()
            # wait for dropdown
            if await _dropdown_visible(pg):
                return True
            with contextlib.suppress(Exception):
                await pg.wait_for_timeout(120)

    # Final attempt: dispatch mousedown via JS
    try:
        elh = await box.element_handle()
        if elh:
            await pg.evaluate("(e)=>{e.dispatchEvent(new MouseEvent('mousedown',{bubbles:true}));e.dispatchEvent(new MouseEvent('click',{bubbles:true}));}", elh)
            if await _dropdown_visible(pg):
                return True
    except Exception:
        pass

    return await _dropdown_visible(pg)

async def _dropdown_visible(pg) -> bool:
    try:
        lb = pg.get_by_role("listbox")
        if await lb.count():
            await lb.first.wait_for(state="visible", timeout=500)
            return True
    except Exception:
        pass
    # CSS panels
    try:
        panel = pg.locator(".el-select-dropdown:visible, .ant-select-dropdown:visible, .vxe-select--panel:visible")
        return (await panel.count()) > 0
    except Exception:
        return False

async def _open_platform_by_aria(scope, select_idx: int) -> bool:
    """Target the exact Element Plus input[role=combobox] with aria-controls and use it to open listbox."""
    pg = page_of(scope)
    inp = scope.locator("input.el-select__input[role='combobox']")
    try:
        n = await inp.count()
    except Exception:
        n = 0
    if n == 0:
        return False

    i = select_idx if select_idx < n else 0
    node = inp.nth(i)

    # Gather aria attributes for debugging
    try:
        ac = await node.get_attribute("aria-controls")
        ae = await node.get_attribute("aria-expanded")
        aid = await node.get_attribute("id")
        print(f"[ARIA] combobox idx={i}, id={aid}, controls={ac}, expanded={ae}")
    except Exception:
        ac = None

    # Focus then try keys & clicks
    with contextlib.suppress(Exception): await node.scroll_into_view_if_needed()
    with contextlib.suppress(Exception): await node.focus()
    with contextlib.suppress(Exception): await node.click()
    for key in ["ArrowDown", "Enter", " "]:
        with contextlib.suppress(Exception):
            await node.press(key)
            if await _dropdown_visible(pg):
                return True
            await pg.wait_for_timeout(120)

    # If there is an aria-controls, wait for that listbox id
    if ac:
        try:
            lb = pg.locator(f"#{ac}")
            await lb.wait_for(state="visible", timeout=800)
            return True
        except Exception:
            pass

    # Try suffix/caret relative to the input
    try:
        container = node.locator("xpath=ancestor::*[contains(@class,'el-select')][1]")
        if await container.count():
            suf = container.locator(".el-select__suffix, .el-select__caret")
            if await suf.count():
                with contextlib.suppress(Exception): await suf.first.click()
                if await _dropdown_visible(pg):
                    return True
                with contextlib.suppress(Exception): await suf.first.click(force=True)
                if await _dropdown_visible(pg):
                    return True
    except Exception:
        pass

    # JS events
    try:
        elh = await node.element_handle()
        if elh:
            await pg.evaluate("(e)=>{e.dispatchEvent(new MouseEvent('mousedown',{bubbles:true}));e.dispatchEvent(new MouseEvent('click',{bubbles:true}));}", elh)
            if await _dropdown_visible(pg):
                return True
    except Exception:
        pass

    return await _dropdown_visible(pg)
async def snapshot(scope, tag: str, shotdir: Path):
    pg = page_of(scope)
    try:
        shotdir.mkdir(parents=True, exist_ok=True)
        p = shotdir / f"{dt.datetime.now().strftime('%Y%m%d_%H%M%S')}_{tag}.png"
        await pg.screenshot(path=str(p), full_page=True)
        print(f"[SHOT] {p.name}")
    except Exception as e:
        print(f"[SHOT-FAIL] {tag}: {e}")

async def wait_login_pause(page: Page, shotdir: Path, *, once_flag: dict):
    if once_flag.get("done"): return
    try:
        html = await page.content()
        if any(k in html for k in ["ç™»å½•","é©—è­‰ç¢¼","éªŒè¯ç ","captcha","æ»‘å—","æ‰«ä¸€æ‰«ç™»å½•","çŸ­ä¿¡éªŒè¯ç "]):
            print("[PAUSE] æ£€æµ‹åˆ°ç™»å½•/éªŒè¯ç ç•Œé¢ï¼Œè¯·å¤„ç†åæŒ‰ â–¶ ç»§ç»­ã€‚")
            await snapshot(page, "login_pause", shotdir)
            await page.pause()
    except Exception:
        pass
    finally:
        once_flag["done"] = True

def get_scope(page: Page, frame_selector: str = ""):
    return page.frame_locator(frame_selector) if frame_selector else page

# ---------- Menu ----------
async def goto_by_menu(scope, menu_path: list, shotdir: Path) -> bool:
    pg = page_of(scope)

    async def _try_click(_scope, text: str) -> bool:
        rx = re.compile(re.escape(text.strip()))
        # Prefer visible elements
        cands = [
            _scope.get_by_role("menuitem", name=rx),
            _scope.locator(".el-menu .el-menu-item:visible, .el-submenu__title:visible").filter(has_text=rx),
            _scope.get_by_text(rx, exact=True),
            _scope.locator("a:visible,button:visible,span:visible,div:visible").filter(has_text=rx),
        ]
        for loc in cands:
            try:
                cnt = await loc.count()
            except Exception:
                cnt = 0
            if cnt:
                el = loc.first
                try:
                    await el.scroll_into_view_if_needed()
                except Exception:
                    pass
                with contextlib.suppress(Exception):
                    await el.hover()
                try:
                    await el.click()
                    return True
                except Exception:
                    # force click fallback
                    with contextlib.suppress(Exception):
                        await el.click(force=True)
                        return True
        return False

    # Expand any collapsed submenus if needed
    async def _expand_if_possible(_scope):
        subs = _scope.locator(".el-submenu__title:visible")
        try:
            n = await subs.count()
        except Exception:
            n = 0
        for i in range(n):
            title = subs.nth(i)
            with contextlib.suppress(Exception):
                txt = (await title.inner_text()).strip()
                # Heuristic: expand generic submenus that might contain our items
                if txt and txt not in ("",):
                    with contextlib.suppress(Exception):
                        await title.click()

    # Iframes fallback: try within each frame as well
    async def _try_everywhere(text: str) -> bool:
        # current scope
        if await _try_click(scope, text):
            return True
        # try expanding submenus and retry
        await _expand_if_possible(scope)
        if await _try_click(scope, text):
            return True
        # frames
        try:
            for fr in pg.frames:
                with contextlib.suppress(Exception):
                    sc = fr
                    if await _try_click(sc, text):
                        return True
                    await _expand_if_possible(sc)
                    if await _try_click(sc, text):
                        return True
        except Exception:
            pass
        # last resort: partial match (remove spaces)
        norm = re.sub(r"\s+", "", text)
        return await _try_click(scope, norm)

    for text in menu_path:
        # wait a bit for menus to render after route change
        with contextlib.suppress(Exception):
            await pg.wait_for_load_state("domcontentloaded")
        with contextlib.suppress(Exception):
            await pg.wait_for_timeout(200)

        clicked = False
        # retry loop
        for _ in range(3):
            if await _try_everywhere(text):
                clicked = True
                break
            # small wait and retry after trying to expand
            with contextlib.suppress(Exception):
                await pg.wait_for_timeout(400)
        if not clicked:
            print(f"[WARN] Menu not found: {text}")
            await snapshot(scope, f"no_menu_{text}", shotdir)
            return False
        with contextlib.suppress(Exception):
            await pg.wait_for_load_state("networkidle")
        with contextlib.suppress(Exception):
            await pg.wait_for_timeout(200)
    return True

    return True

# ---------- Platform (manual: read only, never click) ----------
async def read_selected_platform(scope, select_idx: int) -> Optional[str]:
    """å°½å¯èƒ½é²æ£’åœ°è¯»å–é€‰ä¸­çš„å¹³å°æ–‡æœ¬ï¼ˆåªè¯»ä¸ç‚¹ï¼‰ã€‚æ”¯æŒ Element Plus / AntD / VXEã€‚"""
    import contextlib as _ctx, re as _re
    try:
        # å®šä½ select å®¹å™¨ï¼ˆå…¼å®¹å¤šç§ UI æ¡†æ¶ï¼‰
        container_selectors = [
            ".el-select",
            ".ant-select",
            ".vxe-select--wrapper",
            "[role='combobox']",
            ".mx-input",
        ]
        box = None
        for css in container_selectors:
            loc = scope.locator(css)
            cnt = await loc.count()
            if cnt:
                box = loc.nth(select_idx if select_idx < cnt else 0)
                break
        if box is None:
            # å…œåº•ï¼šä»å°è¯• Element Plus å®¹å™¨
            box = scope.locator(".el-select").nth(select_idx)

        # 1) Element Plus å¤šé€‰æ ‡ç­¾
        tags = box.locator(".el-select__tags .el-tag .el-tag__content, .el-select__tags .el-tag span")
        if await tags.count():
            texts = []
            limit = min(await tags.count(), 5)
            for i in range(limit):
                with _ctx.suppress(Exception):
                    t = (await tags.nth(i).inner_text()).strip()
                    if t:
                        texts.append(t)
            if texts:
                return _re.sub(r"\s+", " ", ",".join(texts))

        # 2) Element Plus å•é€‰é¡¹
        for sel_css in [
            ".el-select__selected-item",
            ".el-select__selection span",
            ".el-select__selection .el-select__selected-item",
            ".el-select .el-select__selected-item",
            ".select-trigger .el-select__selected-item",
        ]:
            sel = box.locator(sel_css)
            if await sel.count():
                txt = (await sel.first.inner_text()).strip()
                if txt:
                    return _re.sub(r"\s+", " ", txt)

        # 3) Ant Design å•/å¤šé€‰
        ant_multi = box.locator(".ant-select-selection-overflow-item .ant-select-selection-item")
        if await ant_multi.count():
            texts = []
            limit = min(await ant_multi.count(), 5)
            for i in range(limit):
                with _ctx.suppress(Exception):
                    t = (await ant_multi.nth(i).inner_text()).strip()
                    if t:
                        texts.append(t)
            if texts:
                return _re.sub(r"\s+", " ", ",".join(texts))
        for ant_css in [
            ".ant-select-selection-item",
            ".ant-select-selector .ant-select-selection-item",
            ".ant-select-selection-item-content",
        ]:
            ant = box.locator(ant_css)
            if await ant.count():
                txt = (await ant.first.inner_text()).strip()
                if txt:
                    return _re.sub(r"\s+", " ", txt)

        # 4) è¾“å…¥æ¡†å€¼ï¼ˆElement/AntD/VXEï¼‰
        for ip_css in [
            "input.el-select__input[role='combobox']",
            "input[role='combobox']",
            ".vxe-input--inner",
            ".ant-select-selection-search-input",
        ]:
            ipt = box.locator(ip_css)
            if await ipt.count():
                with _ctx.suppress(Exception):
                    val = await ipt.first.input_value()
                    if val and val.strip():
                        return _re.sub(r"\s+", " ", val.strip())
                with _ctx.suppress(Exception):
                    ph = await ipt.first.get_attribute("placeholder")
                    if ph and ph.strip() and ph.strip() not in {"è¯·é€‰æ‹©", "æ¸ é“åˆ†ç»„æŸ¥è¯¢"}:
                        return _re.sub(r"\s+", " ", ph.strip())

        # 5) å…œåº•ï¼šè¯»å–å®¹å™¨æ–‡æœ¬ï¼Œå»è£…é¥°ç¬¦ä¸å ä½ç¬¦
        with _ctx.suppress(Exception):
            raw = (await box.inner_text()).strip()
            if raw:
                raw = _re.sub(r"\s+", " ", raw)
                raw = raw.replace("â–¼", "").replace("â–²", "").replace("â–¾", "").strip()
                if raw and raw not in {"è¯·é€‰æ‹©", "æ¸ é“åˆ†ç»„æŸ¥è¯¢"}:
                    return raw
    except Exception:
        pass
    return None

async def _clear_current_selection(scope, select_idx: int) -> bool:
    """
    æ¸…é™¤å½“å‰å·²é€‰æ‹©çš„å¹³å°ï¼ˆç‚¹å‡» X æŒ‰é’®ï¼‰
    è¿”å›ï¼šæ˜¯å¦æˆåŠŸæ¸…é™¤
    """
    pg = page_of(scope)
    
    try:
        # å°è¯•å¤šç§é€‰æ‹©å™¨æ‰¾åˆ°æ¸…é™¤æŒ‰é’®
        clear_button_selectors = [
            # Element Plus çš„å…³é—­æŒ‰é’®ï¼ˆtag å†…çš„ Xï¼‰
            ".el-select .el-select__tags .el-tag__close",
            ".el-select .el-select__tags .el-icon-close",
            # Element Plus çš„æ¸…é™¤æŒ‰é’®ï¼ˆæ•´ä½“æ¸…é™¤ï¼‰
            ".el-select .el-select__clear",
            ".el-select .el-icon-circle-close",
            # Ant Design çš„å…³é—­æŒ‰é’®
            ".ant-select-selector .ant-select-selection-item-remove",
            ".ant-select-clear",
            # VXE çš„å…³é—­æŒ‰é’®
            ".vxe-select--wrapper .vxe-select--clear-icon",
            # é€šç”¨çš„å…³é—­å›¾æ ‡
            ".el-select [class*='close']:visible",
            ".el-select [class*='clear']:visible",
            # SVG å›¾æ ‡
            ".el-select svg.el-icon",
        ]
        
        # å®šä½åˆ°å…·ä½“çš„ select å®¹å™¨
        select_container = None
        try:
            selects = scope.locator(".el-select")
            count = await selects.count()
            print(f"[CLEAR-DEBUG] æ‰¾åˆ° {count} ä¸ª .el-select å…ƒç´ ï¼Œéœ€è¦ç¬¬ {select_idx} ä¸ª")
            if count > select_idx:
                select_container = selects.nth(select_idx)
                print(f"[CLEAR-DEBUG] å®šä½åˆ°ç›®æ ‡ select å®¹å™¨")
        except Exception as e:
            print(f"[CLEAR-DEBUG] å®šä½ select å®¹å™¨å¤±è´¥: {e}")
            pass
        
        if select_container:
            # åœ¨ç‰¹å®šå®¹å™¨å†…æŸ¥æ‰¾æ¸…é™¤æŒ‰é’®
            for i, selector in enumerate(clear_button_selectors):
                try:
                    clear_btn = select_container.locator(selector)
                    btn_count = await clear_btn.count()
                    if btn_count > 0:
                        print(f"[CLEAR] æ‰¾åˆ°æ¸…é™¤æŒ‰é’®ï¼ˆé€‰æ‹©å™¨ {i+1}/{len(clear_button_selectors)}ï¼‰: {selector}")
                        # å°è¯•æ»šåŠ¨åˆ°å¯è§å¹¶æ‚¬åœï¼ˆæ¿€æ´»æ¸…é™¤æŒ‰é’®ï¼‰
                        with contextlib.suppress(Exception):
                            await select_container.hover()
                        await clear_btn.first.click()
                        print(f"[CLEAR] å·²ç‚¹å‡»æ¸…é™¤æŒ‰é’®")
                        await asyncio.sleep(0.5)  # ç­‰å¾…æ¸…é™¤ç”Ÿæ•ˆ
                        return True
                except Exception as e:
                    continue
        
        # å¦‚æœä¸Šé¢æ²¡æ‰¾åˆ°ï¼Œå°è¯•å…¨å±€æŸ¥æ‰¾ï¼ˆé’ˆå¯¹ç¬¬ select_idx ä¸ªï¼‰
        print(f"[CLEAR-DEBUG] åœ¨å®¹å™¨å†…æœªæ‰¾åˆ°ï¼Œå°è¯•å…¨å±€æŸ¥æ‰¾")
        for i, selector in enumerate(clear_button_selectors):
            try:
                all_clear = pg.locator(selector)
                count = await all_clear.count()
                if count > select_idx:
                    print(f"[CLEAR] æ‰¾åˆ°å…¨å±€æ¸…é™¤æŒ‰é’®: {selector}")
                    await all_clear.nth(select_idx).click()
                    print(f"[CLEAR] å·²ç‚¹å‡»æ¸…é™¤æŒ‰é’®")
                    await asyncio.sleep(0.5)
                    return True
            except Exception:
                continue
        
        print("[CLEAR] æœªæ‰¾åˆ°æ¸…é™¤æŒ‰é’®ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨æ¸…é™¤æˆ–ä¸æ”¯æŒæ¸…é™¤")
        return False
        
    except Exception as e:
        print(f"[CLEAR] æ¸…é™¤é€‰æ‹©æ—¶å‡ºé”™: {e}ï¼Œç»§ç»­...")
        return False

async def discover_all_platforms(scope, select_idx: int, skip_indices: list = None, skip_pattern: str = None) -> list[str]:
    """
    æ™ºèƒ½è‡ªåŠ¨å‘ç°ä¸‹æ‹‰åˆ—è¡¨ä¸­çš„æ‰€æœ‰å¹³å°é€‰é¡¹
    
    Args:
        scope: é¡µé¢æˆ–frame
        select_idx: å¹³å°ä¸‹æ‹‰æ¡†çš„ç´¢å¼•
        skip_indices: è¦è·³è¿‡çš„å¹³å°ç´¢å¼•åˆ—è¡¨ï¼ˆä¾‹å¦‚ [0, 2] è¡¨ç¤ºè·³è¿‡ç´¢å¼•0å’Œ2çš„é€‰é¡¹ï¼‰
        skip_pattern: è¦è·³è¿‡çš„å¹³å°åç§°æ­£åˆ™è¡¨è¾¾å¼ï¼ˆä¾‹å¦‚ "^å…¨å¹³å°$|æµ‹è¯•|å·²åœç”¨"ï¼‰
    
    Returns:
        å¹³å°åç§°åˆ—è¡¨ï¼ˆå·²å»é‡å¹¶è¿‡æ»¤ï¼‰
    """
    pg = page_of(scope)
    skip_indices = skip_indices or []
    
    print(f"[DISCOVER] ğŸ” å¼€å§‹æ™ºèƒ½å‘ç°å¹³å°åˆ—è¡¨...")
    print(f"[DISCOVER] é…ç½®ï¼šè·³è¿‡ç´¢å¼• {skip_indices}, è·³è¿‡æ¨¡å¼ '{skip_pattern}'")
    
    # 1. æ‰“å¼€å¹³å°ä¸‹æ‹‰æ¡†
    opened = await _open_platform_dropdown(scope, select_idx)
    if not opened:
        print(f"[WARN] æ— æ³•æ‰“å¼€å¹³å°ä¸‹æ‹‰æ¡†ï¼Œå°è¯•å¤‡ç”¨æ–¹æ³•...")
        # å¤‡ç”¨æ–¹æ³•ï¼šç›´æ¥ç‚¹å‡»
        try:
            container_selectors = [
                ".el-select",
                ".ant-select",
                ".vxe-select--wrapper",
                "[role='combobox']",
            ]
            for css in container_selectors:
                loc = scope.locator(css)
                if await loc.count() > select_idx:
                    await loc.nth(select_idx).click()
                    await asyncio.sleep(0.3)
                    opened = True
                    break
        except Exception:
            pass
    
    if not opened:
        print(f"[ERROR] æ— æ³•æ‰“å¼€å¹³å°ä¸‹æ‹‰æ¡†ï¼Œè‡ªåŠ¨å‘ç°å¤±è´¥")
        return []
    
    # ç­‰å¾…ä¸‹æ‹‰é€‰é¡¹æ¸²æŸ“
    await asyncio.sleep(0.6)
    
    # 2. è¯»å–æ‰€æœ‰é€‰é¡¹
    panel_selectors = [
        ".el-select-dropdown:visible",
        ".ant-select-dropdown:not(.ant-select-dropdown-hidden)",
        ".vxe-select--panel:visible",
        "[role='listbox']:visible",
    ]
    
    option_selectors = [
        "[role='option']",
        ".el-select-dropdown__item",
        ".ant-select-item",
        ".vxe-select--option",
        ".el-option"
    ]
    
    platforms = []
    skip_regex = re.compile(skip_pattern) if skip_pattern else None
    
    # å°è¯•æ‰¾åˆ°æ¿€æ´»çš„ä¸‹æ‹‰é¢æ¿
    panel_found = False
    for ps in panel_selectors:
        try:
            panels = pg.locator(ps)
            panel_count = await panels.count()
            
            if panel_count > 0:
                # å–æœ€åä¸€ä¸ªå¯è§é¢æ¿ï¼ˆé€šå¸¸æ˜¯æœ€æ–°æ‰“å¼€çš„ï¼‰
                panel = panels.last
                print(f"[DISCOVER] æ‰¾åˆ°ä¸‹æ‹‰é¢æ¿ï¼š{ps}")
                
                # åœ¨é¢æ¿å†…æŸ¥æ‰¾æ‰€æœ‰é€‰é¡¹
                for opt_sel in option_selectors:
                    try:
                        options = panel.locator(opt_sel)
                        count = await options.count()
                        
                        if count > 0:
                            print(f"[DISCOVER] æ‰¾åˆ° {count} ä¸ªå€™é€‰å¹³å°é€‰é¡¹")
                            panel_found = True
                            
                            for i in range(count):
                                # è·³è¿‡æŒ‡å®šç´¢å¼•
                                if i in skip_indices:
                                    print(f"[DISCOVER] â­ï¸  è·³è¿‡ç´¢å¼• {i}ï¼ˆé…ç½®è·³è¿‡ï¼‰")
                                    continue
                                
                                try:
                                    option = options.nth(i)
                                    
                                    # æ£€æŸ¥æ˜¯å¦è¢«ç¦ç”¨
                                    is_disabled = False
                                    try:
                                        classes = await option.get_attribute("class") or ""
                                        aria_disabled = await option.get_attribute("aria-disabled") or ""
                                        if "disabled" in classes.lower() or aria_disabled == "true":
                                            is_disabled = True
                                    except Exception:
                                        pass
                                    
                                    if is_disabled:
                                        print(f"[DISCOVER] â­ï¸  è·³è¿‡ç´¢å¼• {i}ï¼ˆå·²ç¦ç”¨ï¼‰")
                                        continue
                                    
                                    # è¯»å–é€‰é¡¹æ–‡æœ¬
                                    text = await option.inner_text()
                                    text = re.sub(r"\s+", " ", text.strip())
                                    
                                    # è¿‡æ»¤ç©ºé€‰é¡¹
                                    if not text:
                                        continue
                                    
                                    # è¿‡æ»¤å¸¸è§çš„éå¹³å°é€‰é¡¹
                                    if text in {"è¯·é€‰æ‹©", "è¯·é€‰æ‹©å¹³å°", "Select", "Please select", "â€”", "-", "..."}:
                                        print(f"[DISCOVER] â­ï¸  è·³è¿‡ç´¢å¼• {i}ï¼š'{text}'ï¼ˆé€šç”¨æç¤ºï¼‰")
                                        continue
                                    
                                    # åº”ç”¨æ­£åˆ™è¿‡æ»¤
                                    if skip_regex and skip_regex.search(text):
                                        print(f"[DISCOVER] â­ï¸  è·³è¿‡ç´¢å¼• {i}ï¼š'{text}'ï¼ˆåŒ¹é…è¿‡æ»¤è§„åˆ™ï¼‰")
                                        continue
                                    
                                    # å»é‡
                                    if text not in platforms:
                                        platforms.append(text)
                                        print(f"[DISCOVER] âœ… ç´¢å¼• {i}: {text}")
                                    else:
                                        print(f"[DISCOVER] â­ï¸  è·³è¿‡ç´¢å¼• {i}ï¼š'{text}'ï¼ˆé‡å¤ï¼‰")
                                        
                                except Exception as e:
                                    print(f"[WARN] è¯»å–é€‰é¡¹ {i} å¤±è´¥: {e}")
                                    continue
                            
                            # æ‰¾åˆ°é€‰é¡¹åè·³å‡º
                            if platforms:
                                break
                                
                    except Exception as e:
                        print(f"[DEBUG] é€‰æ‹©å™¨ {opt_sel} å¤±è´¥: {e}")
                        continue
                
                if panel_found:
                    break
                    
        except Exception as e:
            print(f"[DEBUG] é¢æ¿é€‰æ‹©å™¨ {ps} å¤±è´¥: {e}")
            continue
    
    # 3. å…³é—­ä¸‹æ‹‰æ¡†ï¼ˆæŒ‰ESCé”®ï¼‰
    try:
        await pg.keyboard.press("Escape")
        await asyncio.sleep(0.3)
    except Exception:
        pass
    
    if platforms:
        print(f"[DISCOVER] âœ… æˆåŠŸå‘ç° {len(platforms)} ä¸ªæœ‰æ•ˆå¹³å°")
        for idx, plat in enumerate(platforms, 1):
            print(f"[DISCOVER]   {idx}. {plat}")
    else:
        print(f"[WARN] æœªèƒ½è‡ªåŠ¨å‘ç°ä»»ä½•å¹³å°ï¼Œå¯èƒ½éœ€è¦æ£€æŸ¥é¡µé¢ç»“æ„")
    
    return platforms

async def auto_select_platform_option(scope, target_text: str, shotdir: Path) -> bool:
    """
    è‡ªåŠ¨åœ¨å·²æ‰“å¼€çš„ä¸‹æ‹‰åˆ—è¡¨ä¸­æŸ¥æ‰¾å¹¶ç‚¹å‡»ç›®æ ‡å¹³å°é€‰é¡¹ã€‚
    - ä¼˜å…ˆç›´æ¥ç‚¹å‡»å¯è§é¡¹
    - é¿å…å¼ºä¾èµ–æ»šåŠ¨ï¼›æä¾› force ç‚¹å‡»ä¸ JS ç‚¹å‡»å…œåº•
    è¿”å›ï¼šæ˜¯å¦æˆåŠŸç‚¹å‡»
    """
    pg = page_of(scope)

    # ç­‰å¾…ä¸‹æ‹‰é€‰é¡¹æ¸²æŸ“
    await asyncio.sleep(0.4)

    # åœ¨"å½“å‰æ¿€æ´»çš„ä¸‹æ‹‰é¢æ¿"å†…æŸ¥æ‰¾é€‰é¡¹ï¼Œé¿å…è·¨é¢æ¿è¯¯ç‚¹
    panel_selectors = [
        ".el-select-dropdown",
        ".ant-select-dropdown",
        ".vxe-select--panel",
        "[role='listbox']",
    ]

    def _match(a: str, b: str) -> bool:
        return a in b or b in a

    # å°è¯•ä»ç›®æ ‡æ–‡æœ¬ä¸­è§£æå‡ºå¹³å°ç¼–å·ï¼ˆä¾‹å¦‚ "1153 | xxx" â†’ 1153ï¼‰
    id_match = re.search(r"^\s*(\d+)\s*\|", target_text)
    target_id = id_match.group(1) if id_match else None

    # å–æœ€åä¸€ä¸ªå¯è§é¢æ¿ä½œä¸ºå½“å‰æ¿€æ´»çš„ä¸‹æ‹‰
    active_found = False
    for ps in panel_selectors:
        panels = pg.locator(ps)
        cnt = await panels.count()
        if not cnt:
            continue
        for i in range(cnt - 1, -1, -1):
            panel = panels.nth(i)
            with contextlib.suppress(Exception):
                if not await panel.is_visible():
                    continue
            # åœ¨è¯¥é¢æ¿å†…å®šä½é€‰é¡¹
            options = panel.locator("[role='option'], .el-select-dropdown__item, .ant-select-item, .vxe-select--option, .el-option")
            opt_cnt = await options.count()
            if not opt_cnt:
                continue
            active_found = True
            print(f"[INFO] åœ¨æ¿€æ´»ä¸‹æ‹‰é¢æ¿å†…æ‰¾åˆ° {opt_cnt} ä¸ªé€‰é¡¹ï¼ŒæŸ¥æ‰¾ï¼š{target_text}")
            for j in range(opt_cnt):
                option = options.nth(j)
                try:
                    text = await option.inner_text()
                    text = re.sub(r"\s+", " ", text.strip())
                    # è·³è¿‡"å…¨å¹³å°"ï¼Œé™¤éç›®æ ‡å°±æ˜¯å®ƒ
                    if text == "å…¨å¹³å°" and target_text != "å…¨å¹³å°":
                        continue
                    ok = False
                    if _match(target_text, text):
                        ok = True
                    elif target_id:
                        m = re.search(r"^\s*(\d+)\s*\|", text)
                        if m and m.group(1) == target_id:
                            ok = True
                    if not ok:
                        continue

                    print(f"[AUTO] è‡ªåŠ¨é€‰æ‹©å¹³å°ï¼š{text}")
                    with contextlib.suppress(Exception):
                        await option.click()
                        await asyncio.sleep(0.25)
                        return True
                    with contextlib.suppress(Exception):
                        await option.click(force=True)
                        await asyncio.sleep(0.25)
                        return True
                    with contextlib.suppress(Exception):
                        await option.evaluate("el => el && el.click && el.click()")
                        await asyncio.sleep(0.25)
                        return True
                except Exception:
                    continue

    # é”®å…¥ç­›é€‰å…œåº•ï¼šå¯¹è·å¾—ç„¦ç‚¹çš„ combobox è¾“å…¥ç›®æ ‡å…³é”®å­—å¹¶å›è½¦
    try:
        focus_inputs = pg.locator("input[role='combobox']:focus, .el-select input.el-select__input:focus, .ant-select-selection-search-input:focus")
        if await focus_inputs.count():
            key = target_id or target_text
            with contextlib.suppress(Exception):
                await focus_inputs.first.fill("")
            with contextlib.suppress(Exception):
                await focus_inputs.first.type(str(key))
            with contextlib.suppress(Exception):
                await focus_inputs.first.press("Enter")
            await asyncio.sleep(0.35)
            return True
    except Exception:
        pass

    # è‹¥æœªæ‰¾åˆ°æ¿€æ´»é¢æ¿æˆ–ç‚¹å‡»æœªæˆåŠŸï¼Œé€€å›åˆ°å…¨å±€å…œåº•ï¼ˆæå°‘æ•°æƒ…å†µï¼‰
    if not active_found:
        option_selectors = [
            "[role='option']",
            ".el-select-dropdown__item",
            ".ant-select-item",
            ".vxe-select--option",
            ".el-option"
        ]
        for selector in option_selectors:
            try:
                options = pg.locator(selector)
                count = await options.count()
                if count <= 0:
                    continue
                for i in range(count):
                    option = options.nth(i)
                    try:
                        text = await option.inner_text()
                        text = re.sub(r"\s+", " ", text.strip())
                        if text == "å…¨å¹³å°" and target_text != "å…¨å¹³å°":
                            continue
                        ok = False
                        if _match(target_text, text):
                            ok = True
                        elif target_id:
                            m = re.search(r"^\s*(\d+)\s*\|", text)
                            if m and m.group(1) == target_id:
                                ok = True
                        if not ok:
                            continue
                        with contextlib.suppress(Exception):
                            await option.click()
                            await asyncio.sleep(0.25)
                            return True
                        with contextlib.suppress(Exception):
                            await option.click(force=True)
                            await asyncio.sleep(0.25)
                            return True
                        with contextlib.suppress(Exception):
                            await option.evaluate("el => el && el.click && el.click()")
                            await asyncio.sleep(0.25)
                            return True
                    except Exception:
                        continue
            except Exception:
                continue

    print(f"[WARN] æœªèƒ½è‡ªåŠ¨æ‰¾åˆ°åŒ¹é…çš„å¹³å°é€‰é¡¹ï¼š{target_text}")
    await snapshot(scope, f"auto_select_fail_{sanitize_filename(target_text)}", shotdir)
    return False

async def wait_for_user_platform(scope, select_idx: int, target_text: str, timeout_ms: int = 180000, auto_mode: bool = True, clear_before_select: bool = False) -> Optional[str]:
    """
    é€‰æ‹©å¹³å°ï¼šæ”¯æŒè‡ªåŠ¨æ¨¡å¼å’Œæ‰‹åŠ¨æ¨¡å¼
    auto_mode=True: è‡ªåŠ¨æŸ¥æ‰¾å¹¶ç‚¹å‡»ç›®æ ‡å¹³å°ï¼ˆé»˜è®¤ï¼‰
    auto_mode=False: ç­‰å¾…æ‰‹åŠ¨é€‰æ‹©
    clear_before_select=True: é€‰æ‹©å‰å…ˆæ¸…é™¤ä¹‹å‰çš„é€‰æ‹©ï¼ˆç”¨äº LTV ç­‰ä»»åŠ¡ï¼‰
    è¿”å›ï¼šæœ€ç»ˆç”¨äºå¯¼å‡ºçš„"å¹³å°å"ï¼ˆè‹¥å§‹ç»ˆè¯»ä¸åˆ°åˆ™è¿”å› Noneï¼‰ã€‚
    """
    pg = page_of(scope)
    shotdir = Path("_shots")

    def _norm(s: Optional[str]) -> Optional[str]:
        return re.sub(r"\s+", " ", s.strip()) if s else None

    before = _norm(await read_selected_platform(scope, select_idx))

    # è‹¥å½“å‰å·²æ˜¯ç›®æ ‡å¹³å°ï¼Œåˆ™ç›´æ¥è¿”å›æˆåŠŸï¼Œé¿å…é‡å¤ç‚¹å‡»å¯¼è‡´åˆ¤å®šå¤±è´¥
    def _extract_id(txt: Optional[str]) -> Optional[str]:
        if not txt: return None
        m = re.match(r"^(\d+)\s*\|", txt)
        return m.group(1) if m else None

    if before:
        tid = _extract_id(target_text)
        bid = _extract_id(before)
        if target_text in before or (tid and bid and tid == bid) or (target_text == "å…¨å¹³å°" and before == "å…¨å¹³å°"):
            print(f"[OK] å·²æ˜¯ç›®æ ‡å¹³å°ï¼š{before}")
            return before

    # Stabilize after route change with better timeout handling
    try:
        await pg.wait_for_load_state("domcontentloaded", timeout=10000)
        with contextlib.suppress(Exception):
            await pg.wait_for_load_state("networkidle", timeout=15000)
    except Exception as e:
        print(f"[WARN] Page load timeout: {e}, continue anyway")
        pass

    # å¦‚æœéœ€è¦æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©ï¼ˆä»… LTV ç­‰ç‰¹å®šä»»åŠ¡ï¼‰
    # æ³¨æ„ï¼šåªè¦æœ‰ä¹‹å‰çš„é€‰æ‹©å°±æ¸…é™¤ï¼Œä¸ç®¡æ˜¯å¦åŒ¹é…ï¼ˆå› ä¸ºå¯èƒ½æ˜¯ä¹‹å‰é€‰æ‹©æ®‹ç•™ï¼‰
    if clear_before_select and before and auto_mode:
        print(f"[CLEAR] æ£€æµ‹åˆ°ä¹‹å‰çš„é€‰æ‹©ï¼š{before}ï¼Œå‡†å¤‡æ¸…é™¤")
        await _clear_current_selection(scope, select_idx)
        # æ¸…é™¤åç­‰å¾…é¡µé¢ç¨³å®š
        await asyncio.sleep(0.5)
        # éªŒè¯æ˜¯å¦æ¸…é™¤æˆåŠŸ
        after_clear = _norm(await read_selected_platform(scope, select_idx))
        if after_clear:
            print(f"[CLEAR] æ¸…é™¤åä»æœ‰é€‰æ‹©ï¼š{after_clear}ï¼Œç»§ç»­å°è¯•")
        else:
            print(f"[CLEAR] æ¸…é™¤æˆåŠŸ")

    # First, try ARIA-driven open on exact combobox input
    opened = await _open_platform_by_aria(scope, select_idx)
    if not opened:
        opened = await _open_platform_dropdown(scope, select_idx)
    if not opened:
        print("[INFO] æœªæ£€æµ‹åˆ°æœ‰æ•ˆçš„ä¸‹æ‹‰é¢æ¿ï¼Œä½¿ç”¨å½“å‰å¹³å°ç»§ç»­ã€‚")
        return before

    # --- stabilization after potential page refresh & open the dropdown ---
    try:
        await pg.wait_for_load_state("domcontentloaded")
        with contextlib.suppress(Exception):
            await pg.wait_for_load_state("networkidle")
    except Exception:
        pass

    # è‡ªåŠ¨æ¨¡å¼ï¼šå°è¯•è‡ªåŠ¨é€‰æ‹©
    if auto_mode:
        print(f"[AUTO] è‡ªåŠ¨é€‰æ‹©æ¨¡å¼ï¼šæ­£åœ¨æŸ¥æ‰¾ {target_text}")
        success = await auto_select_platform_option(scope, target_text, shotdir)
        
        if success:
            # ç­‰å¾…é€‰æ‹©ç”Ÿæ•ˆï¼ˆå¢åŠ ç­‰å¾…æ—¶é—´ï¼‰
            await asyncio.sleep(1.0)
            
            # å¤šæ¬¡éªŒè¯ï¼Œå› ä¸ºé¡µé¢å¯èƒ½éœ€è¦æ—¶é—´æ›´æ–°
            for attempt in range(3):
                final_name = _norm(await read_selected_platform(scope, select_idx))
                if final_name:
                    # æ£€æŸ¥æ˜¯å¦çœŸçš„é€‰æ‹©äº†ç›®æ ‡ï¼ˆæ¨¡ç³ŠåŒ¹é…ï¼‰
                    if target_text in final_name or final_name in target_text:
                        print(f"[OK] è‡ªåŠ¨é€‰æ‹©æˆåŠŸï¼š{final_name}")
                        return final_name
                    else:
                        print(f"[WARN] é€‰æ‹©ä¸åŒ¹é…ï¼ŒæœŸæœ›ï¼š{target_text}ï¼Œå®é™…ï¼š{final_name}")
                        if attempt < 2:
                            print(f"[RETRY] ç­‰å¾…é¡µé¢æ›´æ–°...")
                            await asyncio.sleep(0.5)
                            continue
                        else:
                            # å¯èƒ½æ˜¯é¡µé¢é€»è¾‘é—®é¢˜ï¼Œè¿”å›å½“å‰é€‰æ‹©
                            print(f"[OK] ä½¿ç”¨å½“å‰é€‰æ‹©ï¼š{final_name}")
                            return final_name
                else:
                    if attempt < 2:
                        await asyncio.sleep(0.5)
                        continue
        
        print(f"[WARN] è‡ªåŠ¨é€‰æ‹©å¤±è´¥ï¼Œå°è¯•æ‰‹åŠ¨æ¨¡å¼")
    
    # æ‰‹åŠ¨æ¨¡å¼æˆ–è‡ªåŠ¨å¤±è´¥åçš„å¤‡ç”¨æ–¹æ¡ˆ
    # Prefer ARIA role first
    combobox = None
    try:
        cb_count = await scope.get_by_role("combobox").count()
        if cb_count and select_idx < cb_count:
            combobox = scope.get_by_role("combobox").nth(select_idx)
    except Exception:
        combobox = None

    if combobox is None:
        # fallbacks for common UI libs
        candidates = [
            ".el-select .el-select__selection",
            ".el-select .select-trigger",
            ".ant-select-selector",
            "[role='combobox']",
            ".vxe-select--wrapper",
            ".mx-input"
        ]
        for css in candidates:
            loc = scope.locator(css)
            cnt = await loc.count()
            if cnt:
                combobox = loc.nth(select_idx if select_idx < cnt else 0)
                break
        if combobox is None:
            combobox = scope.locator(".el-select").nth(select_idx)

    with contextlib.suppress(Exception):
        await combobox.scroll_into_view_if_needed()

    # Try to open the listbox so the user can click an item
    opened = False
    with contextlib.suppress(Exception):
        await combobox.click()
        opened = True
    if not opened:
        with contextlib.suppress(Exception):
            await combobox.click(force=True)
            opened = True

    # Keep the dropdown open (best-effort): wait for options/listbox to appear
    try:
        lb = pg.get_by_role("listbox")
        if await lb.count():
            await lb.first.wait_for(state="visible", timeout=2000)
    except Exception:
        with contextlib.suppress(Exception):
            await pg.wait_for_selector("[role='option'], .el-select-dropdown, .ant-select-dropdown, .vxe-select--panel", state="visible", timeout=2000)

    print(f"[WAIT] è¯·åœ¨å¹³å°ä¸‹æ‹‰ä¸­æ‰‹åŠ¨é€‰æ‹©ï¼š{target_text}ï¼ˆé€‰å¥½åç‚¹å‡» â–¶ ç»§ç»­ï¼‰")
    await snapshot(scope, f"wait_platform_{sanitize_filename(target_text)}", shotdir)
    with contextlib.suppress(Exception):
        await pg.pause()  # ä½ ç‚¹ â–¶ åç»§ç»­

    elapsed = 0.0
    step = 1.0
    final_name: Optional[str] = None

    try:
        while elapsed < (timeout_ms / 1000.0):
            cur = _norm(await read_selected_platform(scope, select_idx))
            if cur:
                print(f"[INFO] å½“å‰å·²é€‰å¹³å°ï¼š{cur}ï¼ˆç›®æ ‡ï¼š{target_text}ï¼‰")
                if target_text in cur:
                    print(f"[OK] å·²é€‰æ‹©å¹³å°ï¼ˆåŒ¹é…ç›®æ ‡ï¼‰ï¼š{cur}")
                    final_name = cur
                    break
                if before is None or cur != before:
                    print(f"[OK] å·²é€‰æ‹©å¹³å°ï¼ˆæœªåŒ¹é…ç›®æ ‡ï¼Œä½†æ£€æµ‹åˆ°æ›´æ”¹ï¼‰ï¼š{cur}")
                    final_name = cur
                    break
            await asyncio.sleep(step)
            elapsed += step
    except Exception as e:
        print(f"[WARN] ç­‰å¾…å¹³å°æœŸé—´å‡ºç°å¼‚å¸¸ï¼š{e}")

    if final_name is None:
        final_name = _norm(await read_selected_platform(scope, select_idx))
        if final_name:
            print(f"[OK] ä½¿ç”¨å½“å‰å¹³å°ï¼ˆå…œåº•ï¼‰ï¼š{final_name}")
        else:
            print(f"[SKIP] æœªèƒ½è¯»åˆ°å·²é€‰å¹³å°ï¼Œè·³è¿‡ã€‚")
    return final_name

# ---------- Date / Query ----------
async def open_date_panel(scope, strategies: list, shotdir: Path) -> bool:
    pg = page_of(scope)
    for strat in strategies:
        q = strat.get("query")
        try:
            loc = scope.locator(q)
            if await loc.count():
                await loc.first.click()
                try: await pg.wait_for_timeout(100)
                except Exception: pass
                return True
        except Exception: pass
    await snapshot(scope, "no_date_open", shotdir); return False

async def type_range(scope, start_str: str, end_str: str):
    pg = page_of(scope)
    inputs = scope.locator(".el-date-editor input, .ant-picker-input input, .vxe-input--inner, input.mx-input")
    if await inputs.count() >= 2:
        await inputs.nth(0).fill(start_str)
        await inputs.nth(1).fill(end_str)
        with contextlib.suppress(Exception):
            await inputs.nth(1).press("Enter")
        try: await pg.wait_for_timeout(120)
        except Exception: pass
        return True
    return False

async def pick_quick_or_type(scope, label: str, shotdir: Path) -> bool:
    today = dt.date.today()
    if label == "æ˜¨å¤©":
        s = today - dt.timedelta(days=1); e = s
    elif label == "æœ¬æœˆ":
        s = today.replace(day=1); e = today
    elif label == "ä¸Šæœˆ":
        first_this = today.replace(day=1); last_prev = first_this - dt.timedelta(days=1)
        s = last_prev.replace(day=1); e = last_prev
    else:
        return False
    for fmt in ("%Y-%m-%d", "%Y/%m/%d"):
        if await type_range(scope, s.strftime(fmt), e.strftime(fmt)):
            return True
    # å¯è§å¿«æ·é¡¹å†ç‚¹
    pg = page_of(scope)
    btn = scope.locator(
        ".el-picker-panel__shortcut:visible, .vxe-picker--panel .vxe-button:visible, .ant-picker-now-btn:visible"
    ).get_by_text(label, exact=False)
    if await btn.count():
        try:
            await btn.first.click()
            try: await pg.wait_for_timeout(120)
            except Exception: pass
            return True
        except Exception:
            return False
    return False

async def click_query(scope) -> bool:
    pg = page_of(scope)
    for nm in ["æŸ¥è¯¢","æœç´¢","Search","æŸ¥è¯¢æ•°æ®","ç­›é€‰"]:
        btn = scope.get_by_role("button", name=re.compile(nm))
        if await btn.count():
            await btn.first.scroll_into_view_if_needed(); await btn.first.click()
            with contextlib.suppress(Exception): await pg.wait_for_load_state("networkidle")
            try: await pg.wait_for_timeout(220)
            except Exception: pass
            return True
    return False

async def wait_table_loaded(scope):
    pg = page_of(scope)
    with contextlib.suppress(Exception):
        await pg.wait_for_selector(".el-table, .ant-table, table, .vxe-table", state="visible", timeout=8000)
    mask = pg.locator(".el-loading-mask, .vxe-modal--wrapper.lock--view.is--mask")
    if await mask.count():
        with contextlib.suppress(Exception):
            await mask.first.wait_for(state="hidden", timeout=8000)
    try: await pg.wait_for_timeout(200)
    except Exception: pass

# ---------- Export with modal ----------
async def wait_any_modal(scope, timeout=8000):
    pg = page_of(scope)
    sels = [
        ".vxe-modal--wrapper.is--visible.is--active",
        ".el-message-box__wrapper",
        ".el-dialog__wrapper",
        ".el-dialog.is-active, .el-dialog[aria-modal='true']",
        ".ant-modal-root .ant-modal-wrap, .ant-modal-root .ant-modal"
    ]
    for sel in sels:
        try:
            await pg.wait_for_selector(sel, state="visible", timeout=timeout)
            loc = pg.locator(sel)
            if await loc.count():
                return loc.first
        except Exception:
            pass
    return None

async def _detect_global_no_data(scope) -> bool:
    """
    è¯†åˆ«å…¨å±€é¡¶éƒ¨/è½»æç¤ºçš„"æš‚æ— å¯¼å‡ºæ•°æ®"ç­‰æç¤ºï¼ˆä¾‹å¦‚çº¢è‰²toastï¼‰ï¼Œéå¯¹è¯æ¡†å†…å…ƒç´ ã€‚
    è¿”å›ï¼šTrue è¡¨ç¤ºæ£€æµ‹åˆ°æ— æ•°æ®æç¤ºã€‚
    """
    try:
        pg = page_of(scope)
        # å¸¸è§ UI åº“çš„å…¨å±€æç¤ºå®¹å™¨é€‰æ‹©å™¨ï¼ˆElement Plus / VXE / AntDï¼‰
        toast_selectors = [
            ".el-message.el-message--error, .el-message.is-error, .el-message--warning",
            ".el-notification__content:has-text('æš‚æ— '), .el-notification:has-text('æš‚æ— ')",
            ".vxe-modal--wrapper .vxe-modal--body:has-text('æš‚æ— ')",
            ".ant-message-notice:has-text('æš‚æ— '), .ant-notification-notice:has-text('æš‚æ— ')",
            "[class*='message']:has-text('æš‚æ— å¯¼å‡ºæ•°æ®')",
            "[class*='toast']:has-text('æš‚æ— å¯¼å‡ºæ•°æ®')",
            # æœ‰çš„é¡µé¢æ–‡æ¡ˆé‡Œ"æš‚æ— å¯¼å‡º æ•°æ®"ä¸­é—´æœ‰ç©ºç™½
            "[class*='message']:has-text('æš‚æ— å¯¼å‡º æ•°æ®')",
            "[class*='toast']:has-text('æš‚æ— å¯¼å‡º æ•°æ®')",
        ]
        for sel in toast_selectors:
            try:
                loc = pg.locator(sel)
                if await loc.count():
                    # è¯»å–éƒ¨åˆ†æ–‡æœ¬ç”¨äºæ—¥å¿—
                    with contextlib.suppress(Exception):
                        txt = (await loc.first.inner_text()).strip()
                        print(f"[NO-DATA] âœ“ æ£€æµ‹åˆ°å…¨å±€æç¤ºï¼š'{txt[:80]}'")
                    return True
            except Exception:
                continue
        return False
    except Exception as e:
        print(f"[NO-DATA] å…¨å±€æç¤ºæ£€æµ‹å¼‚å¸¸: {e}")
        return False

async def _check_no_data_message(modal) -> bool:
    """
    æ£€æŸ¥æ¨¡æ€æ¡†ä¸­æ˜¯å¦æœ‰"æš‚æ— å¯¼å‡ºæ•°æ®"æˆ–ç±»ä¼¼çš„æç¤º
    è¿”å›ï¼šTrue è¡¨ç¤ºæœ‰æ— æ•°æ®æç¤º
    """
    try:
        # å¸¸è§çš„æ— æ•°æ®æç¤ºæ–‡æœ¬
        no_data_messages = [
            "æš‚æ— å¯¼å‡ºæ•°æ®",
            "æš‚æ— æ•°æ®",
            "æ— å¯¼å‡ºæ•°æ®",
            "æ²¡æœ‰æ•°æ®",
            "æ— æ•°æ®å¯å¯¼å‡º",
            "æš‚æ— å¯å¯¼å‡ºæ•°æ®",
            "no data",
            "No Data",
            "No data to export",
            "æš‚æ— è®°å½•",
            "æš‚æ— ",
        ]
        
        # å°è¯•è·å–æ¨¡æ€æ¡†çš„æ–‡æœ¬å†…å®¹
        try:
            modal_text = await modal.inner_text()
            modal_text = modal_text.strip()
            
            # è¾“å‡ºæ¨¡æ€æ¡†å…¨æ–‡ç”¨äºè°ƒè¯•
            print(f"[NO-DATA-DEBUG] æ¨¡æ€æ¡†æ–‡æœ¬å†…å®¹: '{modal_text[:200]}'")  # åªæ˜¾ç¤ºå‰200å­—ç¬¦
            
            # æ£€æŸ¥æ˜¯å¦åŒ…å«æ— æ•°æ®æç¤º
            for msg in no_data_messages:
                if msg in modal_text:
                    print(f"[NO-DATA] âœ“ æ£€æµ‹åˆ°æç¤ºï¼š'{msg}'")
                    return True
            
            print(f"[NO-DATA-DEBUG] æœªåŒ¹é…åˆ°ä»»ä½•æ— æ•°æ®å…³é”®è¯")
        except Exception as e:
            print(f"[NO-DATA-DEBUG] è·å–æ¨¡æ€æ¡†æ–‡æœ¬å¤±è´¥: {e}")
            pass
        
        # å°è¯•æŸ¥æ‰¾ç‰¹å®šçš„æç¤ºå…ƒç´ ï¼ˆé€šå¸¸æ˜¯çº¢è‰²æç¤ºæ¡†ï¼‰
        no_data_selectors = [
            ".el-message-box__message:has-text('æš‚æ— ')",
            ".el-message-box__message:has-text('æ— æ•°æ®')",
            ".el-message-box__content:has-text('æš‚æ— ')",
            ".el-alert--error:has-text('æš‚æ— ')",
            "[class*='message']:has-text('æš‚æ— ')",
            "[class*='alert']:has-text('æš‚æ— ')",
            "[class*='tip']:has-text('æš‚æ— ')",
            "p:has-text('æš‚æ— ')",
            "div:has-text('æš‚æ— å¯¼å‡ºæ•°æ®')",
        ]
        
        for selector in no_data_selectors:
            try:
                elem = modal.locator(selector)
                if await elem.count() > 0:
                    text = await elem.first.inner_text()
                    print(f"[NO-DATA] âœ“ æ‰¾åˆ°æç¤ºå…ƒç´ ï¼š'{text.strip()}' (é€‰æ‹©å™¨: {selector})")
                    return True
            except Exception:
                continue
        
        print(f"[NO-DATA-DEBUG] æœªæ£€æµ‹åˆ°æ— æ•°æ®æç¤º")
        return False
        
    except Exception as e:
        print(f"[NO-DATA] æ£€æµ‹æç¤ºæ—¶å‡ºé”™: {e}")
        return False

async def _close_modal_without_download(modal) -> bool:
    """
    å…³é—­æ— æ•°æ®çš„æ¨¡æ€æ¡†ï¼ˆä¼˜å…ˆç‚¹å‡»"å–æ¶ˆ"æŒ‰é’®ï¼‰
    è¿”å›ï¼šæ˜¯å¦æˆåŠŸå…³é—­
    """
    try:
        # ä¼˜å…ˆçº§1ï¼šå–æ¶ˆ/å…³é—­æŒ‰é’®ï¼ˆåº•éƒ¨æ“ä½œæŒ‰é’®ï¼‰
        cancel_button_selectors = [
            # Element Plus çš„å–æ¶ˆæŒ‰é’®
            ".el-message-box__btns button:has-text('å–æ¶ˆ')",
            ".el-dialog__footer button:has-text('å–æ¶ˆ')",
            # VXE çš„å–æ¶ˆæŒ‰é’®
            ".vxe-modal--footer button:has-text('å–æ¶ˆ')",
            "button:has-text('å–æ¶ˆå¯¼å‡º')",
            # é€šç”¨å–æ¶ˆæŒ‰é’®
            "button:has-text('å–æ¶ˆ')",
            "button:has-text('å…³é—­')",
            "button:has-text('Cancel')",
            "button:has-text('Close')",
            # é€šè¿‡ç±»åæŸ¥æ‰¾éä¸»è¦æŒ‰é’®ï¼ˆé€šå¸¸æ˜¯å–æ¶ˆæŒ‰é’®ï¼‰
            ".el-message-box__btns .el-button:not(.el-button--primary)",
            ".el-dialog__footer .el-button:not(.el-button--primary)",
            ".vxe-modal--footer .vxe-button:not(.theme--primary)",
            ".ant-modal-footer .ant-btn:not(.ant-btn-primary)",
        ]
        
        print(f"[MODAL-CLOSE-DEBUG] å¼€å§‹æŸ¥æ‰¾å–æ¶ˆæŒ‰é’®...")
        for i, selector in enumerate(cancel_button_selectors):
            try:
                btn = modal.locator(selector)
                count = await btn.count()
                print(f"[MODAL-CLOSE-DEBUG] é€‰æ‹©å™¨ {i+1}/{len(cancel_button_selectors)}: {selector} - æ‰¾åˆ° {count} ä¸ªå…ƒç´ ")
                if count > 0:
                    # è·å–æŒ‰é’®æ–‡æœ¬ç”¨äºç¡®è®¤
                    try:
                        btn_text = await btn.first.inner_text()
                        print(f"[MODAL-CLOSE] æ‰¾åˆ°å–æ¶ˆæŒ‰é’®: '{btn_text.strip()}' (é€‰æ‹©å™¨: {selector})")
                    except:
                        print(f"[MODAL-CLOSE] æ‰¾åˆ°å–æ¶ˆæŒ‰é’® (é€‰æ‹©å™¨: {selector})")
                    
                    await btn.first.click()
                    await asyncio.sleep(0.3)  # ç­‰å¾…æ¨¡æ€æ¡†å…³é—­
                    return True
            except Exception as e:
                print(f"[MODAL-CLOSE-DEBUG] é€‰æ‹©å™¨å¤±è´¥: {e}")
                continue
        
        # ä¼˜å…ˆçº§2ï¼šé€šç”¨é¡µè„šæŒ‰é’®ç»„ä¸­é€‰"éä¸»æŒ‰é’®"ä½œä¸ºå–æ¶ˆï¼ˆVXE/Element/AntDï¼‰
        footer_groups = [
            ".vxe-modal--footer .vxe-button",
            ".vxe-modal--footer button",
            ".el-dialog__footer .el-button",
            ".el-message-box__btns .el-button",
            ".ant-modal-footer .ant-btn"
        ]
        for group_sel in footer_groups:
            try:
                group = modal.locator(group_sel)
                cnt = await group.count()
                if cnt:
                    print(f"[MODAL-CLOSE-DEBUG] é¡µè„šæŒ‰é’®ç»„ {group_sel} æœ‰ {cnt} ä¸ªæŒ‰é’®")
                    # å…ˆæ‰¾éä¸»æŒ‰é’®
                    try:
                        non_primary_sel = f"{group_sel}:not(.theme--primary):not(.el-button--primary):not(.ant-btn-primary)"
                        non_primary = modal.locator(non_primary_sel)
                        non_primary_cnt = await non_primary.count()
                        if non_primary_cnt:
                            print(f"[MODAL-CLOSE] é€šè¿‡é¡µè„šéä¸»æŒ‰é’®å…³é—­: {group_sel}")
                            await non_primary.first.click()
                            await asyncio.sleep(0.3)
                            return True
                    except Exception:
                        pass
                    # å…œåº•ï¼šVXEç­‰é¡µè„šå·¦ä¾§ç¬¬ä¸€ä¸ªé€šå¸¸å°±æ˜¯å–æ¶ˆ
                    if cnt >= 1:
                        print(f"[MODAL-CLOSE] é¡µè„šæŒ‰é’®ç»„ç‚¹å‡»ç¬¬ä¸€ä¸ªï¼ˆé€šå¸¸æ˜¯å–æ¶ˆï¼‰: {group_sel}")
                        with contextlib.suppress(Exception):
                            await group.first.click()
                            await asyncio.sleep(0.3)
                            return True
            except Exception:
                continue

        # ä¼˜å…ˆçº§3ï¼šX å…³é—­æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
        close_x_selectors = [
            ".el-message-box__headerbtn .el-message-box__close",
            ".el-dialog__headerbtn .el-dialog__close",
            ".vxe-modal--close-btn",
            ".ant-modal-close",
            "[class*='close'][class*='btn']",
        ]
        
        print(f"[MODAL-CLOSE-DEBUG] æœªæ‰¾åˆ°å–æ¶ˆæŒ‰é’®ï¼Œå°è¯•æŸ¥æ‰¾Xå…³é—­æŒ‰é’®...")
        for selector in close_x_selectors:
            try:
                btn = modal.locator(selector)
                if await btn.count() > 0:
                    print(f"[MODAL-CLOSE] æ‰¾åˆ°Xå…³é—­æŒ‰é’®: {selector}")
                    await btn.first.click()
                    await asyncio.sleep(0.3)
                    return True
            except Exception:
                continue
        
        # ä¼˜å…ˆçº§4ï¼šå°è¯•æŒ‰ ESC é”®å…³é—­ï¼ˆæœ€åæ‰‹æ®µï¼‰
        print(f"[MODAL-CLOSE-DEBUG] æœªæ‰¾åˆ°ä»»ä½•å…³é—­æŒ‰é’®ï¼Œå°è¯•æŒ‰ESCé”®...")
        try:
            pg = page_of(modal)
            await pg.keyboard.press("Escape")
            await asyncio.sleep(0.3)
            print(f"[MODAL-CLOSE] å·²æŒ‰ ESC é”®å…³é—­")
            return True
        except Exception:
            pass
        
        print(f"[MODAL-CLOSE] æœªæ‰¾åˆ°ä»»ä½•å…³é—­æ–¹å¼")
        return False
        
    except Exception as e:
        print(f"[MODAL-CLOSE] å…³é—­æ¨¡æ€æ¡†å‡ºé”™: {e}")
        return False

async def _wait_no_data_toast(scope, timeout_ms: int = 2000) -> bool:
    """åœ¨ç»™å®šæ—¶é—´å†…ç­‰å¾…å…¨å±€'æš‚æ— å¯¼å‡ºæ•°æ®'æç¤ºå‡ºç°ã€‚å‡ºç°åˆ™è¿”å› Trueã€‚"""
    pg = page_of(scope)
    end = (timeout_ms or 0) / 1000.0
    step = 0.12
    elapsed = 0.0
    while elapsed <= end:
        if await _detect_global_no_data(scope):
            return True
        try:
            await pg.wait_for_timeout(int(step * 1000))
        except Exception:
            pass
        elapsed += step
    return False

async def _wait_download_or_toast(scope, timeout_ms: int = 8000):
    """ç­‰å¾…ä¸‹è½½äº‹ä»¶æˆ–æ— æ•°æ®toastï¼ŒäºŒè€…å…¶ä¸€å…ˆå‘ç”Ÿã€‚
    è¿”å› (kind, value): kind in { 'download', 'toast', 'timeout' }
    """
    pg = page_of(scope)
    task_dl = asyncio.create_task(pg.wait_for_event("download"))
    try:
        toast = asyncio.create_task(_wait_no_data_toast(scope, timeout_ms=min(2000, timeout_ms)))
        done, pending = await asyncio.wait({task_dl, toast}, timeout=(timeout_ms or 0)/1000.0, return_when=asyncio.FIRST_COMPLETED)
        if toast in done and await toast:
            # å‘ç°æ— æ•°æ®toast
            with contextlib.suppress(Exception):
                task_dl.cancel()
            return ("toast", None)
        if task_dl in done:
            try:
                dl = task_dl.result()
                return ("download", dl)
            except Exception:
                pass
        # è¶…æ—¶æˆ–éƒ½æœªå®Œæˆ
        with contextlib.suppress(Exception):
            task_dl.cancel()
        return ("timeout", None)
    finally:
        for t in [task_dl, 'toast']:
            pass

async def click_modal_confirm(modal, confirm_rx: re.Pattern, timeout_download=8000):
    """ç‚¹å‡»ç¡®è®¤æŒ‰é’®ï¼Œéšåç­‰å¾…ä¸‹è½½æˆ–æ— æ•°æ®toastï¼Œè°å…ˆæ¥ç”¨è°ã€‚"""
    pg = page_of(modal)
    # å¢å¼º VXE é¢æ¿æŒ‰é’®å®šä½
    cands = [
        modal.locator(".vxe-modal--footer .vxe-button, .vxe-modal--footer button, .vxe-button"),
        modal.locator(".vxe-export--panel .vxe-button, .vxe-export--panel button"),
        modal.locator(".el-message-box__btns button, .el-dialog__footer button, .el-button"),
        modal.locator(".ant-modal-footer button, .ant-btn"),
        modal.locator("button, .el-button, .vxe-button, .ant-btn")
    ]
    # æ‰©å±•ç¡®è®¤æ–‡æœ¬åŒ¹é…
    confirm_text_rx = re.compile(r"(å¯¼å‡º|ç¡®å®š|ä¸‹è½½|Export|OK|Confirm|CSV|Excel|å¼€å§‹å¯¼å‡º|æäº¤|ç¡®å®šå¯¼å‡º|å¯¼å‡ºæ•°æ®)", re.I)
    
    # å…ˆå°è¯•åŒ¹é…å¸¦ç¡®è®¤è¯­ä¹‰çš„æŒ‰é’®
    for loc in cands:
        cnt = await loc.count()
        for i in range(cnt):
            try:
                b = loc.nth(i)
                txt = (await b.inner_text()).strip()
                if confirm_text_rx.search(txt) or confirm_rx.search(txt):
                    await b.click()
                    kind, val = await _wait_download_or_toast(modal, timeout_ms=timeout_download)
                    if kind == "download":
                        return val
                    # æ£€æµ‹åˆ° toastï¼Œç«‹å³å…³é—­å¼¹çª—
                    if kind == "no_data_toast":
                        with contextlib.suppress(Exception):
                            await _close_modal_without_download(modal)
                    return None
            except Exception:
                continue
    # å†å°è¯•ä¸»æŒ‰é’®
    primary = modal.locator(".vxe-button.theme--primary, .el-button--primary, .ant-btn-primary")
    if await primary.count():
        with contextlib.suppress(Exception):
            await primary.first.click()
        kind, val = await _wait_download_or_toast(modal, timeout_ms=timeout_download)
        if kind == "download":
            return val
        # æ£€æµ‹åˆ° toastï¼Œç«‹å³å…³é—­å¼¹çª—
        if kind == "no_data_toast":
            with contextlib.suppress(Exception):
                await _close_modal_without_download(modal)
        return None
    # æœ€åå…œåº•ï¼šä»»æ„ç¬¬ä¸€ä¸ªæŒ‰é’®
    anybtn = modal.locator("button, .el-button, .vxe-button")
    if await anybtn.count():
        with contextlib.suppress(Exception):
            await anybtn.first.click()
        kind, val = await _wait_download_or_toast(modal, timeout_ms=timeout_download)
        if kind == "download":
            return val
        # æ£€æµ‹åˆ° toastï¼Œç«‹å³å…³é—­å¼¹çª—
        if kind == "no_data_toast":
            with contextlib.suppress(Exception):
                await _close_modal_without_download(modal)
        return None
    
    # å…œåº•ï¼šå°è¯•æŒ‰ Enter æäº¤
    print("[INFO] æœªæ‰¾åˆ°ç¡®è®¤æŒ‰é’®ï¼Œå°è¯•å›è½¦æäº¤")
    try:
        await modal.focus()
    except Exception:
        pass
    try:
        kind, val = await _wait_download_or_toast(modal, timeout_ms=timeout_download)
        await pg.keyboard.press("Enter")
        if kind == "download":
            return val
    except Exception:
        pass
    
    return None

async def click_export_and_download(scope, export_rx: re.Pattern, confirm_rx: re.Pattern, target_path: Path, shotdir: Path, timeout_modal: int = 8000, timeout_no_modal: int = 6000) -> bool:
    """æ— è®ºæ˜¯å¦äº§ç”Ÿæ–‡ä»¶ï¼Œéƒ½ä¸èƒ½æŠ›å¼‚å¸¸ï¼›æ— æ–‡ä»¶å°± False è®©ä¸Šå±‚è·³è¿‡ã€‚
    
    Args:
        timeout_modal: æœ‰å¼¹çª—æ—¶çš„ä¸‹è½½è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤8ç§’
        timeout_no_modal: æ— å¼¹çª—æ—¶çš„ä¸‹è½½è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤6ç§’
    """
    pg = page_of(scope)
    
    # ç­‰å¾…é¡µé¢ç©ºé—²ï¼šé®ç½©/åŠ¨ç”»å½»åº•æ¶ˆå¤±ï¼Œé¿å…ç‚¹å‡»è¢«æ‹¦æˆª
    print("[INFO] ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ...")
    async def wait_idle(max_ms=15000):
        sels = [
            ".vxe-grid.is--loading",
            ".vxe-grid.is--animat.is--loading",
            ".el-loading-mask",
            ".vxe-modal--wrapper.lock--view.is--mask",
        ]
        try:
            with contextlib.suppress(Exception):
                await pg.wait_for_timeout(150)
            start = await pg.evaluate("Date.now()")
            while True:
                busy = False
                for s in sels:
                    try:
                        loc = pg.locator(s)
                        if await loc.count():
                            with contextlib.suppress(Exception):
                                if await loc.first.is_visible():
                                    busy = True
                                    break
                    except Exception:
                        pass
                if not busy:
                    with contextlib.suppress(Exception):
                        await pg.wait_for_timeout(120)
                    return
                now = await pg.evaluate("Date.now()")
                if (now - start) > max_ms:
                    print("[WARN] ç­‰å¾…loadingé®ç½©è¶…æ—¶ï¼Œç»§ç»­å°è¯•ç‚¹å‡»")
                    return
                with contextlib.suppress(Exception):
                    await pg.wait_for_timeout(120)
        except Exception:
            pass
    
    await wait_idle(15000)
    
    btns = scope.get_by_role("button", name=export_rx)
    if not await btns.count():
        btns = scope.locator("button, .el-button, .vxe-button").filter(has_text=export_rx)
    if not await btns.count():
        btns = scope.locator("a").filter(has_text=export_rx)
    if not await btns.count():
        await snapshot(scope, "no_export_button", shotdir); return False

    try:
        await btns.first.scroll_into_view_if_needed()
        await btns.first.click()
    except Exception as e:
        # è‹¥æ—¥å¿—å«æœ‰æ‹¦æˆªå­—æ ·ï¼Œå†ç­‰å¾…ç©ºé—²é‡è¯•ä¸€æ¬¡
        if "intercepts pointer events" in f"{e}":
            print("[INFO] å‘ç°ç‚¹å‡»è¢«é®ç½©æ‹¦æˆªï¼ŒäºŒæ¬¡ç­‰å¾…ç©ºé—²åé‡è¯•ç‚¹å‡»")
            await wait_idle(8000)
            with contextlib.suppress(Exception):
                await btns.first.click()
        else:
            with contextlib.suppress(Exception):
                await btns.first.click(force=True)
    
    # å¯¼å‡ºæŒ‰é’®ç‚¹å‡»åï¼Œéƒ¨åˆ†ç³»ç»Ÿä¼šç«‹å³ä»¥"toast"æ–¹å¼æç¤º"æš‚æ— å¯¼å‡ºæ•°æ®"ä¸”å¼¹çª—ä»ä¿æŒ"å¯¼å‡ºæ•°æ®"è¡¨å•
    # åœ¨å¯¹è¯æ¡†ç¡®è®¤å‰å†å¿«é€Ÿæ£€æŸ¥ä¸€æ¬¡å…¨å±€æ— æ•°æ®æç¤ºï¼Œé¿å…è¿›å…¥é•¿æ—¶é—´çš„ä¸‹è½½ç­‰å¾…
    try:
        if await _detect_global_no_data(scope):
            modal_probe = await wait_any_modal(scope, timeout=500)
            if modal_probe is not None:
                with contextlib.suppress(Exception):
                    await _close_modal_without_download(modal_probe)
            return False
    except Exception:
        pass

    # å…ˆå¿«é€Ÿæ£€æŸ¥æ˜¯å¦å­˜åœ¨å…¨å±€"æš‚æ— å¯¼å‡ºæ•°æ®"æç¤ºï¼ˆçº¢è‰²toastç­‰ï¼‰
    try:
        if await _detect_global_no_data(scope):
            # è‹¥æ­¤æ—¶ä¹Ÿå‡ºç°äº†å¯¼å‡ºå¯¹è¯æ¡†ï¼Œä¸€å¹¶å…³é—­ï¼ˆç‚¹å‡»å–æ¶ˆï¼‰
            modal_probe = await wait_any_modal(scope, timeout=500)
            if modal_probe is not None:
                with contextlib.suppress(Exception):
                    await _close_modal_without_download(modal_probe)
            return False
    except Exception:
        pass

    # 1) æœ‰å¼¹çª—ï¼šç‚¹ç¡®å®šâ†’æœŸå¾…ä¸‹è½½ï¼›æ— ä¸‹è½½åˆ™è§†ä½œç©ºé›†
    modal = await wait_any_modal(scope, timeout=2000)
    if modal is not None:
        try:
            # å…ˆæ£€æŸ¥æ˜¯å¦æœ‰"æš‚æ— å¯¼å‡ºæ•°æ®"æˆ–ç±»ä¼¼æç¤º
            has_no_data = await _check_no_data_message(modal)
            
            if has_no_data:
                # æ£€æµ‹åˆ°æ— æ•°æ®æç¤ºï¼Œç›´æ¥ç‚¹å‡»å–æ¶ˆ
                await snapshot(scope, "modal_no_data_detected", shotdir)
                print(f"[INFO] æ£€æµ‹åˆ°'æš‚æ— å¯¼å‡ºæ•°æ®'æç¤ºï¼Œç‚¹å‡»å–æ¶ˆæŒ‰é’®")
                
                closed = await _close_modal_without_download(modal)
                if closed:
                    print(f"[INFO] å·²ç‚¹å‡»å–æ¶ˆï¼Œå…³é—­æ— æ•°æ®æ¨¡æ€æ¡†")
                else:
                    print(f"[WARN] æœªèƒ½å…³é—­æ¨¡æ€æ¡†")
                
                return False
            
            # æ²¡æœ‰æ— æ•°æ®æç¤ºï¼Œæ­£å¸¸ç‚¹å‡»ç¡®è®¤å¹¶ç­‰å¾…ä¸‹è½½
            dl = await click_modal_confirm(modal, confirm_rx, timeout_download=timeout_modal)
            if dl:
                await dl.save_as(str(target_path)); print(f"[DL] {target_path}"); return True
            
            # ç‚¹å‡»äº†ç¡®è®¤ä½†æ— ä¸‹è½½ï¼Œå…³é—­æ¨¡æ€æ¡†
            await snapshot(scope, "modal_no_download", shotdir)
            print(f"[INFO] æ— æ•°æ®ä¸‹è½½ï¼Œå‡†å¤‡å…³é—­æ¨¡æ€æ¡†")
            
            closed = await _close_modal_without_download(modal)
            if closed:
                print(f"[INFO] å·²å…³é—­æ— æ•°æ®æ¨¡æ€æ¡†ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª")
            else:
                print(f"[WARN] æœªèƒ½å…³é—­æ¨¡æ€æ¡†ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨å…³é—­")
            
            return False
        except Exception as e:
            await snapshot(scope, "modal_confirm_error", shotdir)
            print(f"[WARN] æ¨¡æ€æ¡†å¤„ç†å¼‚å¸¸: {e}")
            # å°è¯•å…³é—­æ¨¡æ€æ¡†
            with contextlib.suppress(Exception):
                await _close_modal_without_download(modal)
            return False

    # 2) æ— å¼¹çª—ï¼šç›´æ¥æœŸå¾…ä¸‹è½½
    try:
        async with pg.expect_download(timeout=timeout_no_modal) as dlfut:
            await btns.first.click()
        dl = await dlfut.value
        await dl.save_as(str(target_path)); print(f"[DL] {target_path}")
        return True
    except Exception:
        await snapshot(scope, "xhr_or_no_download", shotdir)
        await asyncio.sleep(0.12)
        return False

# ---------- Run ----------
async def run(args):
    cfg_path = Path(args.config)
    cfg = json.loads(cfg_path.read_text(encoding="utf-8"))
    base = cfg["base_origin"].rstrip("/")
    shotdir = Path("_shots"); shotdir.mkdir(exist_ok=True)

    export_rx = re.compile(cfg["buttons"]["export_any_regex"])
    confirm_rx = re.compile(cfg["buttons"]["confirm_any_regex"])
    strategies = cfg.get("date_open_strategy", [])
    menus = cfg["menus"]
    menu_modes = cfg.get("menu_modes", {})
    manual_targets = cfg.get("manual_platform_targets", [])
    skip_targets = set(cfg.get("skip_platform_targets", []))
    plat_idx = cfg.get("selectors",{}).get("platform_select_index", 0)
    frame_selector = cfg.get("frame_selector","")
    login_once = {"done": False}
    # --- Config diagnostics ---
    try:
        print(f"[CFG] ä½¿ç”¨é…ç½®æ–‡ä»¶: {cfg_path}")
        print(f"[CFG] base_origin: {base}")
        print(f"[CFG] platform_select_index: {plat_idx}")
        mm = cfg.get("menu_modes", {})
        print(f"[CFG] menu_modes.manual_platform: ops={mm.get('ops',{}).get('manual_platform')}, first_login_return={mm.get('first_login_return',{}).get('manual_platform')}, first_recharge_return={mm.get('first_recharge_return',{}).get('manual_platform')}, first_recharge_recharge={mm.get('first_recharge_recharge',{}).get('manual_platform')}, ltv={mm.get('ltv',{}).get('manual_platform')}, promotion={mm.get('promotion',{}).get('manual_platform')}, gift_type={mm.get('gift_type',{}).get('manual_platform')}, daily_channel={mm.get('daily_channel',{}).get('manual_platform')}")
        print(f"[CFG] manual_platform_targets: {len(manual_targets)} ä¸ª")
        if manual_targets:
            preview = manual_targets[:5]
            print(f"[CFG] targets é¢„è§ˆ: {preview}{' ...' if len(manual_targets)>5 else ''}")
        print(f"[CFG] auto_discover_platforms={cfg.get('auto_discover_platforms', False)}, skip_platform_indices={cfg.get('skip_platform_indices', [])}, skip_platform_pattern={cfg.get('skip_platform_pattern')}")
    except Exception:
        pass
    
    # è·å–ç›˜å£åç§°ï¼Œç”¨äºæ–‡ä»¶å‘½åï¼ˆå¢å¼ºï¼šå¦‚æœé…ç½®ç¼ºå¤±ï¼Œä»åŸŸåè‡ªåŠ¨æå–ï¼‰
    from urllib.parse import urlparse
    
    site_name_cfg = cfg.get("site_name", "").strip()
    site_name = site_name_cfg
    
    # å¦‚æœé…ç½®ä¸­æ²¡æœ‰ site_nameï¼Œå°è¯•ä»åŸŸåæå–
    if not site_name:
        try:
            host = urlparse(base).hostname or ""
            # ä¾‹å¦‚ mygamemxvip.com -> æå– mxvip
            m = re.search(r"mygame([a-z0-9]+)", host, re.I)
            if m:
                site_name = m.group(1).lower()
                print(f"[SITE] ä»åŸŸåè‡ªåŠ¨æå–ç›˜å£åç§°ï¼š{site_name}")
        except Exception:
            pass
    
    if site_name:
        print(f"[SITE] ç›˜å£åç§°ï¼š{site_name}")
    else:
        print("[WARN] æœªèƒ½è¯†åˆ«ç›˜å£åç§°ï¼Œæ–‡ä»¶åå°†ä¸å¸¦ç›˜å£å‰ç¼€")
    
    # è‡ªåŠ¨æ¨¡å¼ï¼šé»˜è®¤ä¸ºTrueï¼Œé™¤éç”¨æˆ·æŒ‡å®šäº† --manual
    auto_mode = not getattr(args, 'manual', False)
    print(f"[MODE] {'è‡ªåŠ¨' if auto_mode else 'æ‰‹åŠ¨'}é€‰æ‹©å¹³å°æ¨¡å¼")

    # Force route mapping: ä»é…ç½®æ–‡ä»¶è¯»å–è·¯ç”±æ˜ å°„ï¼Œæ–¹ä¾¿åˆ‡æ¢ä¸åŒç½‘ç«™
    # å¦‚æœ config.json ä¸­æ²¡æœ‰é…ç½® force_routesï¼Œåˆ™ä½¿ç”¨ç©ºå­—å…¸ï¼ˆå®Œå…¨ä¾èµ–èœå•å¯¼èˆªï¼‰
    FORCE_ROUTE = cfg.get("force_routes", {})
    
    # è¶…æ—¶é…ç½®ï¼šä»é…ç½®æ–‡ä»¶è¯»å–ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
    timeouts = cfg.get("timeouts", {})
    timeout_modal = timeouts.get("download_with_modal", 8000)
    timeout_no_modal = timeouts.get("download_no_modal", 6000)

    async with async_playwright() as pw:
        # ä½¿ç”¨æŒä¹…åŒ–æµè§ˆå™¨ä¸Šä¸‹æ–‡ï¼Œæœ€æ¥è¿‘çœŸå®æµè§ˆå™¨
        user_data_dir = Path("./browser_profile")
        user_data_dir.mkdir(exist_ok=True)
        
        # ç²¾ç®€å¯åŠ¨å‚æ•°ï¼Œé¿å…è§¦å‘æ£€æµ‹
        launch_args = [
            '--disable-blink-features=AutomationControlled',
        ]
        
        # å°è¯•ä½¿ç”¨ç³»ç»Ÿ Chrome å¯åŠ¨æŒä¹…åŒ–ä¸Šä¸‹æ–‡
        try:
            print("[INFO] å¯åŠ¨æŒä¹…åŒ–æµè§ˆå™¨ä¼šè¯ï¼ˆä½¿ç”¨ç³»ç»Ÿ Chromeï¼‰...")
            ctx: BrowserContext = await pw.chromium.launch_persistent_context(
                user_data_dir=str(user_data_dir),
                headless=args.headless,
                channel='chrome',  # ä½¿ç”¨ç³»ç»Ÿ Chrome
                args=launch_args,
                viewport={'width': 1920, 'height': 1080},
                locale='zh-CN',
                timezone_id='Asia/Shanghai',
                # ä½¿ç”¨çœŸå®çš„ Chrome 141 User Agent
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36',
                accept_downloads=True,
                # æ·»åŠ æƒé™ï¼Œé¿å…å¼¹çª—
                permissions=['geolocation', 'notifications'],
            )
            print("[INFO] âœ… ä½¿ç”¨æŒä¹…åŒ–æµè§ˆå™¨ï¼ˆä¼šè‡ªåŠ¨ä¿å­˜ç™»å½•çŠ¶æ€ã€cookiesï¼‰")
        except Exception as e:
            print(f"[WARN] ç³»ç»Ÿ Chrome ä¸å¯ç”¨ï¼Œä½¿ç”¨ Chromium: {e}")
            ctx: BrowserContext = await pw.chromium.launch_persistent_context(
                user_data_dir=str(user_data_dir),
                headless=args.headless,
                args=launch_args,
                viewport={'width': 1920, 'height': 1080},
                locale='zh-CN',
                timezone_id='Asia/Shanghai',
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36',
                accept_downloads=True,
            )
        
        # æ³¨å…¥åæ£€æµ‹è„šæœ¬
        await ctx.add_init_script("""
            // ç§»é™¤ webdriver æ ‡å¿—
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
            
            // æ·»åŠ çœŸå®çš„ chrome å¯¹è±¡
            window.navigator.chrome = {
                runtime: {},
                loadTimes: function() {},
                csi: function() {},
                app: {},
            };
            
            // çœŸå®çš„ plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5],
            });
            
            // è¯­è¨€è®¾ç½®
            Object.defineProperty(navigator, 'languages', {
                get: () => ['zh-CN', 'zh', 'en-US', 'en'],
            });
            
            // æ¨¡æ‹ŸçœŸå®çš„æƒé™æŸ¥è¯¢
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
        """)
        
        # è·å–æˆ–åˆ›å»ºé¡µé¢
        if len(ctx.pages) > 0:
            page: Page = ctx.pages[0]
            print("[INFO] ä½¿ç”¨å·²å­˜åœ¨çš„æµè§ˆå™¨æ ‡ç­¾é¡µ")
        else:
            page: Page = await ctx.new_page()
            print("[INFO] åˆ›å»ºæ–°çš„æµè§ˆå™¨æ ‡ç­¾é¡µ")
        try:
            # å¼ºåŒ–åˆå§‹å¯¼èˆªçš„é²æ£’æ€§ä¸è¶…æ—¶
            with contextlib.suppress(Exception):
                ctx.set_default_navigation_timeout(120000)
                ctx.set_default_timeout(60000)
            nav_attempts = 3
            for nav_try in range(nav_attempts):
                try:
                    print(f"[NAV] goto {base} (try {nav_try+1}/{nav_attempts})")
                    await page.goto(base, wait_until="domcontentloaded", timeout=90000)
                    # ç­‰å¾…åˆ°è‡³å°‘ domcontentloadedï¼Œå°½é‡ç­‰ networkidle ä½†ä¸å¼ºåˆ¶
                    with contextlib.suppress(Exception):
                        await page.wait_for_load_state("networkidle", timeout=15000)
                    break
                except Exception as e:
                    print(f"[NAV] goto timeout/error: {e}")
                    await snapshot(page, f"goto_error_try{nav_try+1}", shotdir)
                    if nav_try == nav_attempts - 1:
                        raise
                    await asyncio.sleep(3)
            # æ£€æŸ¥æ˜¯å¦éœ€è¦ç™»å½•ï¼ˆæŒä¹…åŒ–æµè§ˆå™¨ä¼šè‡ªåŠ¨ä¿å­˜ç™»å½•çŠ¶æ€ï¼‰
            skip_pause = getattr(args, "skip_login_pause", False)
            if not skip_pause:
                await wait_login_pause(page, shotdir, once_flag=login_once)
                print("[INFO] ç™»å½•å®Œæˆï¼Œç»§ç»­æ‰§è¡Œä»»åŠ¡")
                print("[INFO] ç™»å½•çŠ¶æ€å·²è‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨é…ç½®æ–‡ä»¶ä¸­")
            else:
                print("[INFO] è·³è¿‡ç™»å½•æš‚åœæ£€æµ‹")
            scope = get_scope(page, frame_selector)

            async def before_each_task(menu_key: str) -> bool:
                # Hard route first if configured
                try:
                    expected = FORCE_ROUTE.get(menu_key)
                    if expected:
                        cur = page.url
                        base_no_hash = cur.split("#")[0] if "#" in cur else base.split("#")[0]
                        target_url = base_no_hash + expected
                        if target_url != cur:
                            print(f"[ROUTE] Force redirect â†’ {target_url}")
                            await page.goto(target_url)
                            # è®°å½•å½“å‰ URLï¼Œå¸®åŠ©æ’æŸ¥
                            print(f"[ROUTE] Current URL: {page.url}")
                            await snapshot(page, f"route_{menu_key}", shotdir)
                        # åˆ·æ–°åé‡å»º scopeï¼ˆiframe å¯èƒ½å˜åŒ–ï¼‰
                        nonlocal scope
                        scope = get_scope(page, frame_selector)
                        return True
                except Exception as e:
                    print(f"[ROUTE] Force route error: {e}, fallback to menu click")

                # Fallback to menu clicking
                ok = await goto_by_menu(scope, menus[menu_key], shotdir)
                if ok:
                    print(f"[ROUTE] Menu click completed, current URL: {page.url}")
                return ok

            async def do_month_exports(tag_prefix: str):
                for label in ["æœ¬æœˆ","ä¸Šæœˆ"]:
                    try:
                        if not await open_date_panel(scope, strategies, shotdir):
                            print(f"[SKIP] {tag_prefix} {label} æ— æ³•æ‰“å¼€æ—¥æœŸé¢æ¿ï¼Œè·³è¿‡è¯¥æœˆä»½ã€‚")
                            continue
                        if not await pick_quick_or_type(scope, label, shotdir):
                            print(f"[SKIP] {tag_prefix} {label} æ— æ³•é€‰æ‹©æ—¥æœŸï¼Œè·³è¿‡è¯¥æœˆä»½ã€‚")
                            continue
                        await click_query(scope); await wait_table_loaded(scope)
                        tag = dt.datetime.now().strftime("%Y-%m-%d")
                        # åœ¨æ–‡ä»¶åä¸­æ·»åŠ ç›˜å£å
                        filename = f"{site_name}_{tag_prefix}_{label}_{tag}.csv" if site_name else f"{tag_prefix}_{label}_{tag}.csv"
                        downloads_dir = Path("downloads"); downloads_dir.mkdir(parents=True, exist_ok=True)
                        target = downloads_dir / sanitize_filename(filename)
                        ok = await click_export_and_download(scope, export_rx, confirm_rx, target, shotdir, timeout_modal, timeout_no_modal)
                        if not ok:
                            print(f"[SKIP] {tag_prefix} {label} æ— æ–‡ä»¶/ç©ºç»“æœï¼Œå·²è·³è¿‡ã€‚")
                    except Exception as e:
                        print(f"[ERROR] {tag_prefix} {label} å¯¼å‡ºå¤±è´¥: {e}ï¼Œç»§ç»­ä¸‹ä¸€æœˆä»½ã€‚")
                        continue

            async def do_yesterday_exports_multi(buttons_key: str, prefix: str):
                try:
                    if not await open_date_panel(scope, strategies, shotdir):
                        print(f"[SKIP] {prefix} æ— æ³•æ‰“å¼€æ—¥æœŸé¢æ¿ï¼Œè·³è¿‡è¯¥ä»»åŠ¡ã€‚")
                        return
                    if not await pick_quick_or_type(scope, "æ˜¨å¤©", shotdir):
                        print(f"[SKIP] {prefix} æ— æ³•é€‰æ‹©æ˜¨å¤©æ—¥æœŸï¼Œè·³è¿‡è¯¥ä»»åŠ¡ã€‚")
                        return
                    await click_query(scope); await wait_table_loaded(scope)
                    tag = dt.datetime.now().strftime("%Y-%m-%d")
                    for item in cfg["buttons"][buttons_key]:
                        try:
                            rx = re.compile(item["text_regex"])
                            fname = item["filename"].format(date=tag)
                            # åœ¨æ–‡ä»¶åä¸­æ·»åŠ ç›˜å£å
                            filename = f"{site_name}_{prefix}_{fname}" if site_name else f"{prefix}_{fname}"
                            downloads_dir = Path("downloads"); downloads_dir.mkdir(parents=True, exist_ok=True)
                            target = downloads_dir / sanitize_filename(filename)
                            ok = await click_export_and_download(scope, rx, confirm_rx, target, shotdir, timeout_modal, timeout_no_modal)
                            if not ok:
                                print(f"[SKIP] {prefix} {item['text_regex']} æ— æ–‡ä»¶/ç©ºç»“æœï¼Œå·²è·³è¿‡ã€‚")
                        except Exception as e:
                            print(f"[ERROR] {prefix} {item.get('text_regex', 'æœªçŸ¥')} å¯¼å‡ºå¤±è´¥: {e}ï¼Œç»§ç»­ä¸‹ä¸€é¡¹ã€‚")
                            continue
                except Exception as e:
                    print(f"[ERROR] {prefix} æ˜¨å¤©æ•°æ®å¯¼å‡ºå¤±è´¥: {e}")

            async def do_last_n_days_exports_multi(buttons_key: str, prefix: str, days: int = 15):
                """é€æ—¥å¯¼å‡ºæœ€è¿‘ N å¤©æ•°æ®ï¼ˆæ¯ä¸€å¤©å•ç‹¬æŸ¥è¯¢ä¸å¯¼å‡ºï¼‰ã€‚"""
                try:
                    base_day = dt.date.today()
                    # ä»æœ€è¿‘åˆ°è¾ƒæ—©ï¼Œæˆ–æŒ‰éœ€æ±‚å¯åå‘ï¼›è¿™é‡ŒæŒ‰ç”±æ—©åˆ°è¿‘ï¼Œä¾¿äºè§‚å¯Ÿè¿›åº¦
                    for offset in range(days - 1, -1, -1):
                        the_day = base_day - dt.timedelta(days=offset)
                        day_str = the_day.strftime("%Y-%m-%d")

                        # æ‰“å¼€æ—¥æœŸé¢æ¿å¹¶è¾“å…¥åŒä¸€å¤©çš„èµ·æ­¢
                        if not await open_date_panel(scope, strategies, shotdir):
                            print(f"[SKIP] {prefix} æ— æ³•æ‰“å¼€æ—¥æœŸé¢æ¿ï¼ˆ{day_str}ï¼‰ï¼Œè·³è¿‡è¯¥æ—¥ã€‚")
                            continue
                        if not await type_range(scope, day_str, day_str):
                            print(f"[SKIP] {prefix} æ— æ³•è®¾ç½®æ—¥æœŸä¸º {day_str}ï¼Œè·³è¿‡è¯¥æ—¥ã€‚")
                            continue

                        await click_query(scope)
                        await wait_table_loaded(scope)

                        for item in cfg["buttons"].get(buttons_key, []):
                            try:
                                rx = re.compile(item["text_regex"])
                                fname = item["filename"].format(date=day_str)
                                filename = f"{site_name}_{prefix}_{fname}" if site_name else f"{prefix}_{fname}"
                                downloads_dir = Path("downloads"); downloads_dir.mkdir(parents=True, exist_ok=True)
                                target = downloads_dir / sanitize_filename(filename)
                                ok = await click_export_and_download(scope, rx, confirm_rx, target, shotdir, timeout_modal, timeout_no_modal)
                                if not ok:
                                    print(f"[SKIP] {prefix} {item['text_regex']} {day_str} æ— æ–‡ä»¶/ç©ºç»“æœï¼Œå·²è·³è¿‡ã€‚")
                            except Exception as e:
                                print(f"[ERROR] {prefix} {item.get('text_regex','æœªçŸ¥')} {day_str} å¯¼å‡ºå¤±è´¥: {e}ï¼Œç»§ç»­ä¸‹ä¸€é¡¹ã€‚")
                                continue
                except Exception as e:
                    print(f"[ERROR] {prefix} æœ€è¿‘{days}å¤©æ•°æ®å¯¼å‡ºå¤±è´¥: {e}")

            # -------- tasks --------
            async def task_ops():
                if not await before_each_task("ops"): return
                await do_month_exports("download_ops_é»˜è®¤")

            async def task_retention_data(key):
                """å¤„ç†ç•™å­˜ç‡æ•°æ® - éœ€è¦åˆ†æ¸ é“å¤„ç†"""
                if not await before_each_task(key): return
                print(f"[INFO] Start {key} data crawling (channel processing)")
                # ===== æ™ºèƒ½è‡ªåŠ¨å‘ç°å¹³å°ï¼ˆç•™å­˜ä»»åŠ¡ï¼‰ =====
                auto_discover = cfg.get("auto_discover_platforms", False)
                skip_platform_indices = cfg.get("skip_platform_indices", [])
                skip_platform_pattern = cfg.get("skip_platform_pattern", None)

                if auto_discover:
                    print(f"[INFO] {key}ï¼šğŸ” è‡ªåŠ¨å‘ç°æ‰€æœ‰å¹³å°")
                    discovered_platforms = await discover_all_platforms(
                        scope,
                        plat_idx,
                        skip_platform_indices,
                        skip_platform_pattern
                    )
                    if discovered_platforms:
                        targets = discovered_platforms
                        print(f"[INFO] å°†å¤„ç† {len(targets)} ä¸ªè‡ªåŠ¨å‘ç°çš„å¹³å°")
                    else:
                        print("[WARN] è‡ªåŠ¨å‘ç°å¤±è´¥ï¼Œä½¿ç”¨é…ç½®çš„å¹³å°åˆ—è¡¨")
                        targets = manual_targets
                else:
                    targets = manual_targets
                    print(f"[INFO] ä½¿ç”¨æ‰‹åŠ¨é…ç½®çš„ {len(targets)} ä¸ªå¹³å°")
                try:
                    print(f"[RUN] {key} æœ¬æ¬¡ç›®æ ‡å¹³å°æ•°: {len(targets)}")
                except Exception:
                    pass
                # ===== è‡ªåŠ¨å‘ç°ç»“æŸ =====

                for target in targets:
                    if target in skip_targets:
                        print(f"[SKIP] Skip platform by rule: {target}")
                        continue
                    
                    # å¢åŠ é¡µé¢ç¨³å®šæ€§æ£€æŸ¥
                    try:
                        await page.wait_for_load_state("networkidle", timeout=10000)
                    except Exception:
                        print(f"[WARN] Page not stable, continue anyway")
                    
                    # å¹³å°é€‰æ‹©ï¼šä¸ºé¿å…é€‰æ‹©é”™è¯¯çš„ä¸‹æ‹‰æ¡†ï¼Œå°è¯•å¤šä¸ªç´¢å¼•ï¼ˆæ¨¡ä»¿é¦–å……å¤ç™»æˆåŠŸé€»è¾‘ï¼‰
                    # ä¼˜å…ˆä½¿ç”¨é…ç½®ä¸­çš„ç‰¹å®šç´¢å¼•ï¼Œå…¶æ¬¡å›é€€å°è¯• 0/1/2
                    per_task_indices = cfg.get("per_task_platform_indices", {}).get(key, [])
                    candidate_indices = []
                    if isinstance(per_task_indices, list):
                        candidate_indices.extend(per_task_indices)
                    candidate_indices.extend([plat_idx, 0, 1, 2])
                    # å»é‡ä¿åº
                    seen = set(); candidate_indices = [i for i in candidate_indices if (i not in seen and not seen.add(i))]

                    def _extract_id(txt: Optional[str]) -> Optional[str]:
                        if not txt: return None
                        m = re.match(r"(\d+)\s*\|", txt)
                        return m.group(1) if m else None

                    def _match_target(selected: Optional[str], target_text: str) -> bool:
                        if not selected: return False
                        s = re.sub(r"\s+", " ", selected.strip())
                        if target_text in s or s in target_text:
                            return True
                        sid = _extract_id(s); tid = _extract_id(target_text)
                        return bool(sid and tid and sid == tid)

                    plat_name = None
                    for try_idx in candidate_indices:
                        print(f"[SELECT] å°è¯•ä¸‹æ‹‰ç´¢å¼• {try_idx} é€‰æ‹©å¹³å°ï¼š{target}")
                        sel = await wait_for_user_platform(scope, try_idx, target, timeout_ms=180000, auto_mode=auto_mode, clear_before_select=True)
                        if _match_target(sel, target):
                            plat_name = sel
                            print(f"[OK] å¹³å°é€‰æ‹©æˆåŠŸï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼š{plat_name}")
                            break
                        else:
                            if sel:
                                print(f"[WARN] å¹³å°é€‰æ‹©æœªåŒ¹é…ï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼šå®é™…={sel} æœŸæœ›åŒ…å«/åŒID={target}")
                            else:
                                print(f"[WARN] ç´¢å¼• {try_idx} æœªè¯»åˆ°å·²é€‰å¹³å°ï¼Œç»§ç»­å°è¯•...")
                            await asyncio.sleep(0.4)

                    if not plat_name:
                        print(f"[SKIP] No platform selected after trying indices {candidate_indices}: {target}")
                        continue
                    
                    # å¢åŠ é‡è¯•æœºåˆ¶
                    max_retries = 2
                    for attempt in range(max_retries):
                        try:
                            # æ ¹æ®ä»»åŠ¡ç±»å‹ä½¿ç”¨ä¸åŒçš„æ–‡ä»¶åå‰ç¼€
                            if key == "first_recharge_return":
                                prefix = "ç”¨æˆ·ç•™å­˜ç‡_é¦–å……å¤ç™»"
                            elif key == "first_recharge_recharge":
                                prefix = "ç”¨æˆ·ç•™å­˜ç‡_é¦–å……å¤å……"
                            else:
                                prefix = f"download_{key}"
                            
                            await do_month_exports(f"{prefix}_{plat_name}")
                            break  # æˆåŠŸåˆ™è·³å‡ºé‡è¯•å¾ªç¯
                        except Exception as e:
                            print(f"[ERROR] Export failed (attempt {attempt + 1}/{max_retries}): {e}")
                            if attempt < max_retries - 1:
                                print(f"[INFO] Wait 5 seconds and retry...")
                                await asyncio.sleep(5)
                            else:
                                print(f"[ERROR] Export finally failed for {target}")

            async def task_ltv_with_retry():
                """LTVä»»åŠ¡ - æ·»åŠ è¶…æ—¶å¤„ç†å’Œé‡è¯•æœºåˆ¶"""
                if not await before_each_task("ltv"): return
                print("[INFO] å¼€å§‹LTVæ•°æ®çˆ¬å–ï¼ˆå·²å¯ç”¨è¶…æ—¶å¤„ç†å’Œé‡è¯•æœºåˆ¶ï¼‰")
                
                mode = menu_modes.get("ltv", {"manual_platform": False})
                if not mode.get("manual_platform", False):
                    # é»˜è®¤æ¨¡å¼ï¼Œç›´æ¥å¯¼å‡º
                    await do_month_exports_with_retry("download_ltv_é»˜è®¤")
                    return
                
                # æ‰‹åŠ¨å¹³å°æ¨¡å¼
                for target in manual_targets:
                    if target in skip_targets:
                        print(f"[SKIP] æŒ‰è§„åˆ™è·³è¿‡å¹³å°ï¼š{target}")
                        continue
                    
                    # å¢åŠ é‡è¯•æœºåˆ¶
                    max_retries = 3
                    for attempt in range(max_retries):
                        try:
                            print(f"[INFO] LTVå¹³å°é€‰æ‹©å°è¯• {attempt + 1}/{max_retries}: {target}")
                            
                            # åœ¨æ¯æ¬¡å°è¯•å‰ç­‰å¾…é¡µé¢ç¨³å®š
                            if attempt > 0:
                                print(f"[INFO] ç­‰å¾…é¡µé¢ç¨³å®š...")
                                await asyncio.sleep(3)
                                try:
                                    await page.wait_for_load_state("networkidle", timeout=10000)
                                except Exception:
                                    pass
                            
                            plat_name = await wait_for_user_platform(scope, plat_idx, target, timeout_ms=180000, auto_mode=auto_mode, clear_before_select=True)
                            if not plat_name:
                                print(f"[WARN] ç¬¬{attempt + 1}æ¬¡å°è¯•æœªé€‰æ‹©åˆ°å¹³å°ï¼š{target}")
                                if attempt < max_retries - 1:
                                    print(f"[INFO] ç­‰å¾…5ç§’åé‡è¯•...")
                                    await asyncio.sleep(5)
                                    continue
                                else:
                                    print(f"[SKIP] æœ€ç»ˆæœªé€‰æ‹©åˆ°å¹³å°ï¼š{target}")
                                    break
                            
                            # æˆåŠŸé€‰æ‹©å¹³å°ï¼Œæ‰§è¡Œå¯¼å‡º
                            await do_month_exports_with_retry(f"download_ltv_{plat_name}")
                            break  # æˆåŠŸåˆ™è·³å‡ºé‡è¯•å¾ªç¯
                            
                        except Exception as e:
                            print(f"[ERROR] LTVä»»åŠ¡å¼‚å¸¸ (å°è¯• {attempt + 1}/{max_retries}): {e}")
                            if attempt < max_retries - 1:
                                print(f"[INFO] ç­‰å¾…10ç§’åé‡è¯•...")
                                await asyncio.sleep(10)
                            else:
                                print(f"[ERROR] LTVä»»åŠ¡æœ€ç»ˆå¤±è´¥ï¼š{target}")

            async def do_month_exports_with_retry(tag_prefix: str):
                """å¸¦é‡è¯•æœºåˆ¶çš„æœˆåº¦å¯¼å‡º - æ¯ä¸ªæœˆä»½ç‹¬ç«‹å¤„ç†ï¼Œå¤±è´¥ä¸å½±å“å…¶ä»–æœˆä»½"""
                for label in ["æœ¬æœˆ","ä¸Šæœˆ"]:
                    max_retries = 2
                    success = False
                    
                    for attempt in range(max_retries):
                        try:
                            print(f"[INFO] å¯¼å‡º {label} æ•°æ® (å°è¯• {attempt + 1}/{max_retries}): {tag_prefix}")
                            
                            if not await open_date_panel(scope, strategies, shotdir):
                                print(f"[WARN] {tag_prefix} {label} æ— æ³•æ‰“å¼€æ—¥æœŸé¢æ¿")
                                if attempt < max_retries - 1:
                                    await asyncio.sleep(3)
                                    continue
                                else:
                                    print(f"[SKIP] {tag_prefix} {label} æ—¥æœŸé¢æ¿æ‰“å¼€å¤±è´¥ï¼Œè·³è¿‡è¯¥æœˆä»½ã€‚")
                                    break
                            
                            if not await pick_quick_or_type(scope, label, shotdir):
                                print(f"[WARN] {tag_prefix} {label} æ— æ³•é€‰æ‹©æ—¥æœŸ")
                                if attempt < max_retries - 1:
                                    await asyncio.sleep(3)
                                    continue
                                else:
                                    print(f"[SKIP] {tag_prefix} {label} æ—¥æœŸé€‰æ‹©å¤±è´¥ï¼Œè·³è¿‡è¯¥æœˆä»½ã€‚")
                                    break
                            
                            await click_query(scope)
                            await wait_table_loaded(scope)
                            tag = dt.datetime.now().strftime("%Y-%m-%d")
                            # åœ¨æ–‡ä»¶åä¸­æ·»åŠ ç›˜å£å
                            filename = f"{site_name}_{tag_prefix}_{label}_{tag}.csv" if site_name else f"{tag_prefix}_{label}_{tag}.csv"
                            downloads_dir = Path("downloads"); downloads_dir.mkdir(parents=True, exist_ok=True)
                            target = downloads_dir / sanitize_filename(filename)
                            ok = await click_export_and_download(scope, export_rx, confirm_rx, target, shotdir, timeout_modal, timeout_no_modal)
                            
                            if not ok:
                                print(f"[SKIP] {tag_prefix} {label} æ— æ–‡ä»¶/ç©ºç»“æœï¼Œå·²è·³è¿‡ã€‚")
                            
                            success = True
                            break  # æˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
                            
                        except Exception as e:
                            print(f"[ERROR] {tag_prefix} {label} å¯¼å‡ºå¼‚å¸¸ (å°è¯• {attempt + 1}/{max_retries}): {e}")
                            if attempt < max_retries - 1:
                                print(f"[INFO] ç­‰å¾…5ç§’åé‡è¯•...")
                                await asyncio.sleep(5)
                            else:
                                print(f"[SKIP] {tag_prefix} {label} æœ€ç»ˆå¤±è´¥ï¼Œè·³è¿‡è¯¥æœˆä»½ã€‚")
                    
                    # ç»§ç»­ä¸‹ä¸€ä¸ªæœˆä»½ï¼Œä¸ç®¡å½“å‰æœˆä»½æ˜¯å¦æˆåŠŸ

            async def task_A(key):
                if not await before_each_task(key): return
                mode = menu_modes.get(key, {"manual_platform": False})
                if not mode.get("manual_platform", False):
                    await do_month_exports(f"download_{key}_é»˜è®¤"); return
                for target in manual_targets:
                    if target in skip_targets:
                        print(f"[SKIP] æŒ‰è§„åˆ™è·³è¿‡å¹³å°ï¼š{target}")
                        continue
                    plat_name = await wait_for_user_platform(scope, plat_idx, target, timeout_ms=300000, auto_mode=auto_mode)
                    if not plat_name:
                        print(f"[SKIP] æœªé€‰æ‹©å¹³å°ï¼š{target}")
                        continue
                    await do_month_exports(f"download_{key}_{plat_name}")

            async def task_promotion():
                """æ¨å¹¿æ¸ é“ç»Ÿè®¡ - æŒ‰å¹³å°é€ä¸€å¯¼å‡ºï¼ˆè‹¥é…ç½®ä¸ºæ‰‹åŠ¨å¹³å°æ¨¡å¼ï¼‰"""
                if not await before_each_task("promotion"): return
                mode = menu_modes.get("promotion", {"manual_platform": False})
                if not mode.get("manual_platform", False):
                    print("[INFO] æ¨å¹¿æ¸ é“ç»Ÿè®¡ï¼šæŸ¥è¯¢ä¸€æ¬¡ï¼Œå¯¼å‡ºä¸‰æ¬¡ï¼ˆå…¨å¹³å°ï¼‰")
                    await do_yesterday_exports_multi("promotion_buttons", "æ¨å¹¿")
                    return

                # ===== æ™ºèƒ½è‡ªåŠ¨å‘ç°å¹³å° =====
                auto_discover = cfg.get("auto_discover_platforms", False)
                skip_platform_indices = cfg.get("skip_platform_indices", [])
                skip_platform_pattern = cfg.get("skip_platform_pattern", None)
                
                if auto_discover:
                    print("[INFO] æ¨å¹¿æ¸ é“ç»Ÿè®¡ï¼šğŸ” è‡ªåŠ¨å‘ç°æ‰€æœ‰å¹³å°")
                    discovered_platforms = await discover_all_platforms(
                        scope, 
                        plat_idx, 
                        skip_platform_indices, 
                        skip_platform_pattern
                    )
                    if discovered_platforms:
                        targets = discovered_platforms
                        print(f"[INFO] å°†å¤„ç† {len(targets)} ä¸ªè‡ªåŠ¨å‘ç°çš„å¹³å°")
                    else:
                        print("[WARN] è‡ªåŠ¨å‘ç°å¤±è´¥ï¼Œä½¿ç”¨é…ç½®çš„å¹³å°åˆ—è¡¨")
                        targets = manual_targets
                else:
                    targets = manual_targets
                    print(f"[INFO] ä½¿ç”¨æ‰‹åŠ¨é…ç½®çš„ {len(targets)} ä¸ªå¹³å°")
                # ===== è‡ªåŠ¨å‘ç°ç»“æŸ =====
                try:
                    print(f"[RUN] promotion æœ¬æ¬¡ç›®æ ‡å¹³å°æ•°: {len(targets)}")
                except Exception:
                    pass

                print("[INFO] æ¨å¹¿æ¸ é“ç»Ÿè®¡ï¼šæŒ‰å¹³å°é€ä¸€å¯¼å‡º")
                per_task_indices = cfg.get("per_task_platform_indices", {}).get("promotion", [])
                candidate_indices = []
                if isinstance(per_task_indices, list): candidate_indices.extend(per_task_indices)
                candidate_indices.extend([plat_idx, 0, 1, 2])
                # å»é‡ä¿åº
                seen = set(); candidate_indices = [i for i in candidate_indices if (i not in seen and not seen.add(i))]

                def _extract_id(txt: Optional[str]) -> Optional[str]:
                    if not txt: return None
                    m = re.match(r"(\d+)\s*\|", txt)
                    return m.group(1) if m else None

                def _match_target(selected: Optional[str], target_text: str) -> bool:
                    if not selected: return False
                    s = re.sub(r"\s+", " ", selected.strip())
                    if target_text in s or s in target_text: return True
                    sid = _extract_id(s); tid = _extract_id(target_text)
                    return bool(sid and tid and sid == tid)

                for target in targets:
                    if target in skip_targets:
                        print(f"[SKIP] è·³è¿‡å¹³å°ï¼š{target}")
                        continue

                    plat_name = None
                    for try_idx in candidate_indices:
                        print(f"[SELECT] å°è¯•ç´¢å¼• {try_idx} é€‰æ‹©å¹³å°ï¼š{target}")
                        sel = await wait_for_user_platform(scope, try_idx, target, timeout_ms=180000, auto_mode=auto_mode, clear_before_select=True)
                        if _match_target(sel, target):
                            plat_name = sel
                            print(f"[OK] å¹³å°é€‰æ‹©æˆåŠŸï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼š{plat_name}")
                            break
                        else:
                            if sel:
                                print(f"[WARN] å¹³å°é€‰æ‹©æœªåŒ¹é…ï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼šå®é™…={sel} æœŸæœ›åŒ…å«/åŒID={target}")
                            else:
                                print(f"[WARN] ç´¢å¼• {try_idx} æœªè¯»åˆ°å·²é€‰å¹³å°ï¼Œç»§ç»­å°è¯•...")
                            await asyncio.sleep(0.4)

                    if not plat_name:
                        print(f"[SKIP] æœªèƒ½é€‰æ‹©å¹³å°ï¼š{target}")
                        continue

                    # æŒ‰å¹³å°å¯¼å‡ºä¸‰é¡¹ï¼ˆæ˜¨å¤©ï¼‰
                    tag_prefix = f"æ¨å¹¿_{plat_name}"
                    await do_yesterday_exports_multi("promotion_buttons", tag_prefix)

            async def task_gift():
                """èµ é€ç±»å‹ç»Ÿè®¡ - æœ€è¿‘15å¤©ï¼ŒæŒ‰å¹³å°é€ä¸€å¯¼å‡ºï¼ˆè‹¥é…ç½®ä¸ºæ‰‹åŠ¨å¹³å°æ¨¡å¼ï¼‰"""
                if not await before_each_task("gift_type"): return
                mode = menu_modes.get("gift_type", {"manual_platform": False})
                if not mode.get("manual_platform", False):
                    print("[INFO] èµ é€ç±»å‹ç»Ÿè®¡ï¼šæœ€è¿‘15å¤©ï¼ˆå…¨å¹³å°ï¼‰")
                    await do_last_n_days_exports_multi("gift_type_buttons", "èµ é€ç±»å‹ç»Ÿè®¡", days=15)
                    return

                # ===== æ™ºèƒ½è‡ªåŠ¨å‘ç°å¹³å° =====
                auto_discover = cfg.get("auto_discover_platforms", False)
                skip_platform_indices = cfg.get("skip_platform_indices", [])
                skip_platform_pattern = cfg.get("skip_platform_pattern", None)
                
                if auto_discover:
                    print("[INFO] èµ é€ç±»å‹ç»Ÿè®¡ï¼šğŸ” è‡ªåŠ¨å‘ç°æ‰€æœ‰å¹³å°")
                    discovered_platforms = await discover_all_platforms(
                        scope, 
                        plat_idx, 
                        skip_platform_indices, 
                        skip_platform_pattern
                    )
                    if discovered_platforms:
                        targets = discovered_platforms
                        print(f"[INFO] å°†å¤„ç† {len(targets)} ä¸ªè‡ªåŠ¨å‘ç°çš„å¹³å°")
                    else:
                        print("[WARN] è‡ªåŠ¨å‘ç°å¤±è´¥ï¼Œä½¿ç”¨é…ç½®çš„å¹³å°åˆ—è¡¨")
                        targets = manual_targets
                else:
                    targets = manual_targets
                    print(f"[INFO] ä½¿ç”¨æ‰‹åŠ¨é…ç½®çš„ {len(targets)} ä¸ªå¹³å°")
                # ===== è‡ªåŠ¨å‘ç°ç»“æŸ =====
                try:
                    print(f"[RUN] gift_type æœ¬æ¬¡ç›®æ ‡å¹³å°æ•°: {len(targets)}")
                except Exception:
                    pass

                print("[INFO] èµ é€ç±»å‹ç»Ÿè®¡ï¼šæŒ‰å¹³å°é€æ—¥å¯¼å‡ºæœ€è¿‘15å¤©")
                per_task_indices = cfg.get("per_task_platform_indices", {}).get("gift_type", [])
                candidate_indices = []
                if isinstance(per_task_indices, list): candidate_indices.extend(per_task_indices)
                candidate_indices.extend([plat_idx, 0, 1, 2])
                seen = set(); candidate_indices = [i for i in candidate_indices if (i not in seen and not seen.add(i))]

                def _extract_id(txt: Optional[str]) -> Optional[str]:
                    if not txt: return None
                    m = re.match(r"(\d+)\s*\|", txt)
                    return m.group(1) if m else None

                def _match_target(selected: Optional[str], target_text: str) -> bool:
                    if not selected: return False
                    s = re.sub(r"\s+", " ", selected.strip())
                    if target_text in s or s in target_text: return True
                    sid = _extract_id(s); tid = _extract_id(target_text)
                    return bool(sid and tid and sid == tid)

                for target in targets:
                    if target in skip_targets:
                        print(f"[SKIP] è·³è¿‡å¹³å°ï¼š{target}")
                        continue

                    plat_name = None
                    for try_idx in candidate_indices:
                        print(f"[SELECT] å°è¯•ç´¢å¼• {try_idx} é€‰æ‹©å¹³å°ï¼š{target}")
                        sel = await wait_for_user_platform(scope, try_idx, target, timeout_ms=180000, auto_mode=auto_mode, clear_before_select=True)
                        if _match_target(sel, target):
                            plat_name = sel
                            print(f"[OK] å¹³å°é€‰æ‹©æˆåŠŸï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼š{plat_name}")
                            break
                        else:
                            if sel:
                                print(f"[WARN] å¹³å°é€‰æ‹©æœªåŒ¹é…ï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼šå®é™…={sel} æœŸæœ›åŒ…å«/åŒID={target}")
                            else:
                                print(f"[WARN] ç´¢å¼• {try_idx} æœªè¯»åˆ°å·²é€‰å¹³å°ï¼Œç»§ç»­å°è¯•...")
                            await asyncio.sleep(0.4)

                    if not plat_name:
                        print(f"[SKIP] æœªèƒ½é€‰æ‹©å¹³å°ï¼š{target}")
                        continue

                    # æŒ‰å¹³å°é€æ—¥å¯¼å‡ºæœ€è¿‘15å¤©
                    tag_prefix = f"èµ é€ç±»å‹ç»Ÿè®¡_{plat_name}"
                    await do_last_n_days_exports_multi("gift_type_buttons", tag_prefix, days=15)

            async def task_daily_channel():
                """æ¯æ—¥æ¸ é“ç»Ÿè®¡ - æŒ‰å¹³å°é€ä¸€å¯¼å‡ºï¼ˆè‹¥é…ç½®ä¸ºæ‰‹åŠ¨å¹³å°æ¨¡å¼ï¼‰"""
                if not await before_each_task("daily_channel"): return
                mode = menu_modes.get("daily_channel", {"manual_platform": False})
                if not mode.get("manual_platform", False):
                    print("[INFO] æ¯æ—¥æ¸ é“ç»Ÿè®¡ï¼šæ˜¨å¤©ï¼ˆå…¨å¹³å°ï¼‰")
                    await do_yesterday_exports_multi("daily_channel_buttons", "æ¯æ—¥æ¸ é“")
                    return

                # ===== æ™ºèƒ½è‡ªåŠ¨å‘ç°å¹³å° =====
                auto_discover = cfg.get("auto_discover_platforms", False)
                skip_platform_indices = cfg.get("skip_platform_indices", [])
                skip_platform_pattern = cfg.get("skip_platform_pattern", None)
                
                if auto_discover:
                    print("[INFO] æ¯æ—¥æ¸ é“ç»Ÿè®¡ï¼šğŸ” è‡ªåŠ¨å‘ç°æ‰€æœ‰å¹³å°")
                    discovered_platforms = await discover_all_platforms(
                        scope, 
                        plat_idx, 
                        skip_platform_indices, 
                        skip_platform_pattern
                    )
                    if discovered_platforms:
                        targets = discovered_platforms
                        print(f"[INFO] å°†å¤„ç† {len(targets)} ä¸ªè‡ªåŠ¨å‘ç°çš„å¹³å°")
                    else:
                        print("[WARN] è‡ªåŠ¨å‘ç°å¤±è´¥ï¼Œä½¿ç”¨é…ç½®çš„å¹³å°åˆ—è¡¨")
                        targets = manual_targets
                else:
                    targets = manual_targets
                    print(f"[INFO] ä½¿ç”¨æ‰‹åŠ¨é…ç½®çš„ {len(targets)} ä¸ªå¹³å°")
                # ===== è‡ªåŠ¨å‘ç°ç»“æŸ =====
                try:
                    print(f"[RUN] daily_channel æœ¬æ¬¡ç›®æ ‡å¹³å°æ•°: {len(targets)}")
                except Exception:
                    pass

                print("[INFO] æ¯æ—¥æ¸ é“ç»Ÿè®¡ï¼šæŒ‰å¹³å°é€ä¸€å¯¼å‡ºæ˜¨å¤©æ•°æ®")
                per_task_indices = cfg.get("per_task_platform_indices", {}).get("daily_channel", [])
                candidate_indices = []
                if isinstance(per_task_indices, list): candidate_indices.extend(per_task_indices)
                candidate_indices.extend([plat_idx, 0, 1, 2])
                seen = set(); candidate_indices = [i for i in candidate_indices if (i not in seen and not seen.add(i))]

                def _extract_id(txt: Optional[str]) -> Optional[str]:
                    if not txt: return None
                    m = re.match(r"(\d+)\s*\|", txt)
                    return m.group(1) if m else None

                def _match_target(selected: Optional[str], target_text: str) -> bool:
                    if not selected: return False
                    s = re.sub(r"\s+", " ", selected.strip())
                    if target_text in s or s in target_text: return True
                    sid = _extract_id(s); tid = _extract_id(target_text)
                    return bool(sid and tid and sid == tid)

                for target in targets:
                    if target in skip_targets:
                        print(f"[SKIP] è·³è¿‡å¹³å°ï¼š{target}")
                        continue

                    plat_name = None
                    for try_idx in candidate_indices:
                        print(f"[SELECT] å°è¯•ç´¢å¼• {try_idx} é€‰æ‹©å¹³å°ï¼š{target}")
                        sel = await wait_for_user_platform(scope, try_idx, target, timeout_ms=180000, auto_mode=auto_mode, clear_before_select=True)
                        if _match_target(sel, target):
                            plat_name = sel
                            print(f"[OK] å¹³å°é€‰æ‹©æˆåŠŸï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼š{plat_name}")
                            break
                        else:
                            if sel:
                                print(f"[WARN] å¹³å°é€‰æ‹©æœªåŒ¹é…ï¼ˆç´¢å¼• {try_idx}ï¼‰ï¼šå®é™…={sel} æœŸæœ›åŒ…å«/åŒID={target}")
                            else:
                                print(f"[WARN] ç´¢å¼• {try_idx} æœªè¯»åˆ°å·²é€‰å¹³å°ï¼Œç»§ç»­å°è¯•...")
                            await asyncio.sleep(0.4)

                    if not plat_name:
                        print(f"[SKIP] æœªèƒ½é€‰æ‹©å¹³å°ï¼š{target}")
                        continue

                    tag_prefix = f"æ¯æ—¥æ¸ é“_{plat_name}"
                    await do_yesterday_exports_multi("daily_channel_buttons", tag_prefix)

            # schedule - æŒ‰å›ºå®šé¡ºåºæ‰§è¡Œï¼Œä»è¿è¥ç»Ÿè®¡å¼€å§‹
            requested_tasks = [x.strip() for x in args.tasks.split(",") if x.strip()]
            
            # å®šä¹‰æ‰§è¡Œé¡ºåºï¼šè¿è¥ç»Ÿè®¡ â†’ é¦–å……å¤ç™» â†’ é¦–å……å¤å…… â†’ èµ é€ â†’ æ¨å¹¿ â†’ æ¯æ—¥æ¸ é“ â†’ LTVï¼ˆæœ€åæ‰§è¡Œï¼‰
            execution_order = [
                "ops",                     # è¿è¥ç»Ÿè®¡ï¼ˆä¼˜å…ˆæ‰§è¡Œï¼‰
                "first_recharge_return",   # ç”¨æˆ·ç•™å­˜ç‡(é¦–å……å¤ç™»)
                "first_recharge_recharge", # ç”¨æˆ·ç•™å­˜ç‡(é¦–å……å¤å……)
                "gift_type",               # èµ é€ç±»å‹ç»Ÿè®¡
                "promotion",               # æ¨å¹¿æ¸ é“ç»Ÿè®¡
                "daily_channel",           # æ¯æ—¥æ¸ é“ç»Ÿè®¡
                "ltv"                      # LTVæ•°æ®ï¼ˆæœ€åæ‰§è¡Œï¼‰
            ]
            
            # æŒ‰é¡ºåºæ‰§è¡Œè¯·æ±‚çš„ä»»åŠ¡
            for key in execution_order:
                if key in requested_tasks:
                    print(f"\n=== Start: {key} ===")
                    if key == "ops":
                        await task_ops()
                    elif key in ("first_recharge_return","first_recharge_recharge"):
                        # ç•™å­˜ç‡æ•°æ®éœ€è¦åˆ†æ¸ é“å¤„ç†
                        await task_retention_data(key)
                    elif key == "ltv":
                        # LTVæ•°æ®ä½¿ç”¨å¸¦é‡è¯•æœºåˆ¶çš„ä¸“ç”¨å‡½æ•°
                        await task_ltv_with_retry()
                    elif key == "promotion":
                        await task_promotion()
                    elif key == "gift_type":
                        await task_gift()
                    elif key == "daily_channel":
                        await task_daily_channel()
                    else:
                        print(f"[WARN] æœªçŸ¥ä»»åŠ¡ï¼š{key}")
            
            # æ£€æŸ¥æ˜¯å¦æœ‰æœªåœ¨é¡ºåºä¸­çš„ä»»åŠ¡
            for key in requested_tasks:
                if key not in execution_order:
                    print(f"\n=== å¼€å§‹ï¼š{key} ===")
                    print(f"[WARN] æœªçŸ¥ä»»åŠ¡ï¼š{key}")
        finally:
            keep_browser = getattr(args, 'keep_browser', False)
            if not keep_browser:
                # æŒä¹…åŒ–ä¸Šä¸‹æ–‡åªéœ€å…³é—­ ctx
                with contextlib.suppress(Exception):
                    await ctx.close()
                print("[INFO] æµè§ˆå™¨å·²å…³é—­ï¼Œç™»å½•çŠ¶æ€å·²ä¿å­˜")
            else:
                print("[HOLD] å·²å¼€å¯ --keep-browserï¼Œæµè§ˆå™¨ä¿æŒæ‰“å¼€çŠ¶æ€ï¼Œå¯æ‰‹åŠ¨è§‚å¯Ÿæˆ–å…³é—­ã€‚")

def main():
    p = argparse.ArgumentParser(description="VNL å¯¼å‡ºï¼ˆæ”¯æŒå…¨è‡ªåŠ¨å¹³å°é€‰æ‹©ï¼‰")
    p.add_argument("--config", default="config.json", help="é…ç½®æ–‡ä»¶è·¯å¾„")
    p.add_argument("--tasks", required=True, help="ops,first_recharge_return,first_recharge_recharge,ltv,promotion,gift_type,daily_channel")
    p.add_argument("--headless", action="store_true", help="æ— å¤´è¿è¡Œ")
    p.add_argument("--manual", action="store_true", help="æ‰‹åŠ¨æ¨¡å¼ï¼šéœ€è¦æ‰‹åŠ¨é€‰æ‹©å¹³å°ï¼ˆé»˜è®¤ä¸ºè‡ªåŠ¨æ¨¡å¼ï¼‰")
    p.add_argument("--keep-browser", action="store_true", help="ä»»åŠ¡å®Œæˆåä¿æŒæµè§ˆå™¨æ‰“å¼€ï¼ˆç”¨äºè°ƒè¯•è§‚å¯Ÿï¼‰")
    p.add_argument("--storage-state", default="", help="Playwright storage state json æ–‡ä»¶è·¯å¾„ï¼ˆå¤ç”¨ç™»å½•æ€ï¼‰")
    p.add_argument("--skip-login-pause", action="store_true", help="æ£€æµ‹åˆ°ç™»å½•é¡µä¹Ÿä¸æš‚åœï¼ˆç”¨äºå·²ç™»å½•æˆ–æ— éœ€æ‰‹åŠ¨ç™»å½•çš„åœºæ™¯ï¼‰")
    args = p.parse_args()
    asyncio.run(run(args))

if __name__ == "__main__":
    main()
