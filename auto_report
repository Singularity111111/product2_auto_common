import os
import glob
import pandas as pd
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
import shutil
from datetime import datetime

# =============================== 配置区 ==================================
SOURCE_EXCEL_NAME = '产品二-VNL日报-10月 (13).xlsx'
OUTPUT_EXCEL_NAME = SOURCE_EXCEL_NAME.replace('.xlsx', '_updated_v10.xlsx')

REPORT_MAP = {
    '运营统计': ('后台', '时间', 3), 
    '用户留存率(首充复登)_全平台': ('首充复登', '时间', 1),
    '用户留存率(首充复充)_全平台': ('首充复充', '时间', 1),
    'LTV全平台': ('LTV', '时间', 3), 
    '推广渠道统计-渠道质量': ('推广-渠道质量', '日期', 1),
    '推广渠道统计-用户质量': ('推广-用户质量', '日期', 1),
    '推广渠道统计-经济效益': ('推广-经济效益', '日期', 1),
    '赠送类型统计': ('赠送类型统计', '日期', 1),
    '每日渠道统计': ('每日渠道统计', '日期', 1),
}
# ========================================================================

def to_standard_date(series):
    """将一个Pandas Series转换为标准日期格式，并处理无效日期"""
    return pd.to_datetime(series, errors='coerce').dt.strftime('%Y-%m-%d')

def smart_update_excel_v10():
    """
    智能更新Excel V10 版：
    - 核心重构：使用Pandas进行核心的数据比对与合并，彻底解决因数据类型不匹配导致的覆盖失败。
    """
    current_directory = os.getcwd()
    source_path = os.path.join(current_directory, SOURCE_EXCEL_NAME)
    output_path = os.path.join(current_directory, OUTPUT_EXCEL_NAME)

    print(f"--- 启动智能更新程序 (V10 - 最终版) ---")

    try:
        shutil.copy(source_path, output_path)
        print(f"✓ 已创建安全副本: {OUTPUT_EXCEL_NAME}")
    except Exception as e:
        print(f"\n[错误] 创建副本失败: {e}")
        return

    csv_files = glob.glob(os.path.join(current_directory, '*.csv'))
    print(f"✓ 找到 {len(csv_files)} 个CSV文件准备处理...")

    try:
        workbook = openpyxl.load_workbook(output_path)
    except Exception as e:
        print(f"\n[错误] 打开Excel副本失败: {e}")
        return

    for csv_path in csv_files:
        filename = os.path.basename(csv_path)
        mapping = None
        for keyword, value in sorted(REPORT_MAP.items(), key=lambda item: len(item[0]), reverse=True):
            if keyword in filename:
                mapping = value
                break
        if not mapping:
            continue

        sheet_name, date_col_name, start_col = mapping
        print(f"\n+ [处理中] '{filename}' -> Sheet: '{sheet_name}'")

        try:
            # 1. 读取源CSV
            source_df = pd.read_csv(csv_path, keep_default_na=False, dtype=str)
            if source_df.empty:
                print("  - [信息] CSV文件为空，跳过。")
                continue

            # 2. 读取目标Excel Sheet
            sheet = workbook[sheet_name] if sheet_name in workbook.sheetnames else workbook.create_sheet(title=sheet_name)
            
            # 找到表头
            excel_rows = list(sheet.iter_rows(values_only=True))
            header_row_index = -1
            date_col_index = -1
            header = []
            for i in range(min(10, len(excel_rows))):
                row_values = [str(c).strip() if c is not None else '' for c in excel_rows[i]]
                if date_col_name in row_values:
                    header_row_index = i
                    header = row_values
                    break
            
            if header_row_index == -1 and sheet.max_row > 0: # 表存在但找不到表头
                 print(f"  - [警告] 在Sheet '{sheet_name}' 中找不到表头 '{date_col_name}'。将进行直接覆盖。")
                 sheet.delete_rows(1, sheet.max_row + 1) # 清空
                 for r in dataframe_to_rows(source_df, index=False, header=True):
                    sheet.append(r)
                 continue
            
            # 将Excel数据读入Pandas DataFrame
            if sheet.max_row > header_row_index + 1:
                target_df = pd.DataFrame(excel_rows[header_row_index+1:], columns=header)
            else:
                target_df = pd.DataFrame(columns=header)
            
            # 3. 核心：标准化日期列用于匹配
            source_df.columns = target_df.columns[:len(source_df.columns)]
            source_df['__match_key__'] = to_standard_date(source_df[date_col_name])
            target_df['__match_key__'] = to_standard_date(target_df[date_col_name])
            
            # 过滤掉无法识别的日期和汇总行
            source_df = source_df[source_df['__match_key__'].notna()]
            source_df = source_df[~source_df[date_col_name].str.contains("数据汇总")]
            
            # 4. 数据合并
            # 将DataFrame的索引设置为匹配键
            target_df.set_index('__match_key__', inplace=True)
            source_df.set_index('__match_key__', inplace=True)
            
            # 执行更新
            target_df.update(source_df)
            
            # 找出需要追加的新行
            new_rows_df = source_df[~source_df.index.isin(target_df.index)]
            
            # 合并旧数据、更新数据和新数据
            final_df = pd.concat([target_df, new_rows_df])
            final_df.reset_index(inplace=True) # 恢复索引
            
            updates_count = len(source_df.index.intersection(target_df.index))
            appends_count = len(new_rows_df)

            # 5. 写回Excel
            # 清空旧数据区域
            if sheet.max_row > header_row_index + 1:
                sheet.delete_rows(header_row_index + 2, sheet.max_row)

            # 写入合并后的新数据
            for index, row in final_df.iterrows():
                # 保持原始格式，所以不写回__match_key__
                row_to_write = row.drop('__match_key__').to_list()
                
                # 特殊处理LTV日期格式
                if sheet_name == 'LTV':
                    try:
                        date_obj = pd.to_datetime(row[date_col_name])
                        row_to_write[header.index(date_col_name)] = f"{date_obj.day}/{date_obj.month}/{date_obj.year}"
                    except: pass
                
                sheet.append(row_to_write)
            
            print(f"  ✓ 处理完成：更新了 {updates_count} 行，追加了 {appends_count} 行。")

        except Exception as e:
            import traceback
            print(f"  > [失败] 处理此文件时发生严重错误: {e}")
            # print(traceback.format_exc())

    try:
        workbook.save(output_path)
        print("\n" + "="*50)
        print(f"🎉 智能更新完毕！已生成新文件: {OUTPUT_EXCEL_NAME}")
        print("="*50)
    except Exception as e:
        print(f"\n[严重错误] 保存Excel文件失败: {e}")

if __name__ == '__main__':
    smart_update_excel_v10()
