import time
import os
import glob
from datetime import date, timedelta
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, ElementClickInterceptedException

# =============================== é…ç½®åŒº ==================================
# !! é‡è¦ !! è¯·åŠ¡å¿…å°†æ­¤è·¯å¾„ä¿®æ”¹ä¸ºæ‚¨è‡ªå·±ç”µè„‘ä¸Š chromedriver.exe çš„å®é™…è·¯å¾„
CHROMEDRIVER_PATH = r"C:\Users\User\Downloads\chromedriver-win64\chromedriver-win64\chromedriver.exe"

LOGIN_URL = "https://newplatform.mygamem777.com/#/HouseholdRetentionRate"
USERNAME = "touhout1"
PASSWORD = "a1234567"

# ä¸‹è½½æ–‡ä»¶å­˜æ”¾çš„ç›®å½• (é€šå¸¸æ˜¯ç³»ç»Ÿçš„â€œä¸‹è½½â€æ–‡ä»¶å¤¹)
DOWNLOADS_PATH = os.path.join(os.path.expanduser('~'), 'Downloads')

# é€šç”¨â€œé»‘åå•â€ï¼Œåœ¨éå†æ¸ é“æ—¶ï¼Œè¿™äº›æ¸ é“å°†è¢«è·³è¿‡ï¼Œä¸äºˆä¸‹è½½
EXCLUDED_CHANNELS = ['12 | ORGANIC', '1111 | æµ‹è¯•', '1112 | 7STAR']

# LTV æŠ¥è¡¨çš„åˆ†ç»„è§„åˆ™å®šä¹‰
# æ ¼å¼ï¼š 'ç”¨ä½œæ–‡ä»¶åçš„ç»„å': 'æ¸ é“åç§°ä¸­åŒ…å«çš„ç‹¬ç‰¹æ ‡è¯†ç¬¦'
LTV_GROUPS = {
    "æŠ•æ”¾ç»„(111)": "_111_",
    "KKKç»„(222)": "_222_",
    "ZZZç»„(333)": "_333_",
}
# ========================================================================

def find_and_rename_newest_file(download_path, new_filename_base, file_date):
    """æŸ¥æ‰¾æœ€æ–°ä¸‹è½½çš„æ–‡ä»¶ï¼Œå¹¶æ ¹æ®æä¾›çš„åŸºç¡€åç§°å’Œæ—¥æœŸè¿›è¡Œé‡å‘½åã€‚"""
    print(f"      > ç­‰å¾…æ–‡ä»¶ä¸‹è½½å®Œæˆ...")
    # [ä¿®æ”¹] æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œå°†ç­‰å¾…æ—¶é—´ç¼©çŸ­
    time.sleep(3)
    
    # æŸ¥æ‰¾ä¸‹è½½ç›®å½•ä¸­æœ€æ–°çš„ .csv æˆ– .xlsx æ–‡ä»¶
    list_of_files = glob.glob(os.path.join(download_path, '*.csv')) + glob.glob(os.path.join(download_path, '*.xlsx'))
    if not list_of_files:
        print(f"      [è­¦å‘Š] ä¸‹è½½ç›®å½•ä¸­æœªæ‰¾åˆ°ä»»ä½•æ–‡ä»¶ï¼")
        return None
        
    latest_file = max(list_of_files, key=os.path.getctime)
    
    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ˜¯åˆšåˆšåˆ›å»ºçš„ï¼Œé˜²æ­¢é”™è¯¯é‡å‘½åæ—§æ–‡ä»¶
    if time.time() - os.path.getctime(latest_file) > 120: # å¦‚æœæ–‡ä»¶åˆ›å»ºæ—¶é—´åœ¨2åˆ†é’Ÿå‰
        print(f"      [è­¦å‘Š] æœªæ‰¾åˆ°æœ€è¿‘2åˆ†é’Ÿå†…ä¸‹è½½çš„æ–°æ–‡ä»¶ï¼Œè·³è¿‡é‡å‘½åã€‚")
        return None

    _, extension = os.path.splitext(latest_file)
    new_filename = f"{new_filename_base}_{file_date.strftime('%Y-%m-%d')}{extension}"
    new_filepath = os.path.join(download_path, new_filename)
    
    # å¦‚æœç›®æ ‡æ–‡ä»¶åå·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
    if os.path.exists(new_filepath):
        os.remove(new_filepath)
        
    os.rename(latest_file, new_filepath)
    print(f"      [æˆåŠŸ] æ–‡ä»¶å·²é‡å‘½åä¸º: {new_filename}")
    return new_filepath


def perform_export_flow(driver, wait, download_path, filename_base, period, report_type="standard"):
    """
    ä¸€ä¸ªé€šç”¨çš„æ‰§è¡Œå¯¼å‡ºæµç¨‹çš„å‡½æ•°ã€‚
    period: "æœ¬æœˆ" æˆ– "ä¸Šæœˆ" æˆ– æ—¥æœŸå¯¹è±¡(date)
    """
    try:
        print(f"    -> æ­£åœ¨å¤„ç†æ—¶é—´æ®µ: {period if isinstance(period, str) else period.strftime('%Y-%m-%d')}")
        
        # --- 1. é€‰æ‹©æ—¶é—´ (ä»…éæ¯æ—¥æ¸ é“æŠ¥è¡¨éœ€è¦) ---
        if report_type != "daily_channel":
            if period in ["æœ¬æœˆ", "ä¸Šæœˆ"]:
                date_picker = wait.until(EC.element_to_be_clickable((By.CLASS_NAME, "el-range-separator")))
                date_picker.click()
                wait.until(EC.visibility_of_element_located((By.XPATH, f"//button/span[text()='{period}']")))
                driver.find_element(By.XPATH, f"//button/span[text()='{period}']").click()
                time.sleep(1)

        # --- 2. æŸ¥è¯¢ ---
        print("      > ç‚¹å‡»æŸ¥è¯¢...")
        # æ¯æ—¥æ¸ é“æŠ¥è¡¨éœ€è¦ç‰¹æ®Šå¤„ç†æ—¥æœŸè¾“å…¥
        if report_type == "daily_channel":
             date_input = wait.until(EC.element_to_be_clickable((By.XPATH, "//input[@placeholder='è¯·é€‰æ‹©æ—¥æœŸ']")))
             date_input.click()
             date_input.clear()
             date_input.send_keys(period.strftime('%Y-%m-%d'))
             driver.find_element(By.TAG_NAME, 'body').click()
             time.sleep(1)

        query_button = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[span[contains(text(),'æŸ¥è¯¢')]]")))
        query_button.click()
        print("      > ç­‰å¾…æ•°æ®åŠ è½½...")
        # [ä¿®æ”¹] æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œå°†ç­‰å¾…æ—¶é—´ç¼©çŸ­
        time.sleep(3)

        # --- 3. å¯¼å‡º ---
        print("      > ç‚¹å‡»å¯¼å‡º...")
        
        # æ ¹æ®æŠ¥è¡¨ç±»å‹å†³å®šå¯¼å‡ºæŒ‰é’®
        if report_type == "daily_channel":
             # æ¯æ—¥æ¸ é“æŠ¥è¡¨éœ€è¦æ ¹æ®filename_baseæ¥å†³å®šç‚¹å“ªä¸ªæŒ‰é’®
             if "æ¸ é“è´¨é‡" in filename_base:
                 export_button_xpath = "//button[span[contains(text(),'å¯¼å‡ºæ¸ é“è´¨é‡')]]"
             elif "ç”¨æˆ·è´¨é‡" in filename_base:
                 export_button_xpath = "//button[span[contains(text(),'å¯¼å‡ºç”¨æˆ·è´¨é‡')]]"
             else: # ç»æµæ•ˆç›Š
                 export_button_xpath = "//button[span[contains(text(),'å¯¼å‡ºç»æµæ•ˆç›Š')]]"
        else:
             export_button_xpath = "//button[span[contains(text(),'å¯¼å‡ºæœ¬é¡µæ•°æ®')]]"

        export_button = wait.until(EC.element_to_be_clickable((By.XPATH, export_button_xpath)))
        driver.execute_script("arguments[0].click();", export_button)
        
        # --- 4. åœ¨å¼¹çª—ä¸­ç¡®è®¤å¯¼å‡º ---
        print("      > åœ¨å¼¹çª—ä¸­ç¡®è®¤å¯¼å‡º...")
        popup_export_button_xpath = "//div[contains(@class, 'vxe-modal--wrapper')]//button[span[text()='å¯¼å‡º']]"
        popup_export_button = wait.until(EC.element_to_be_clickable((By.XPATH, popup_export_button_xpath)))
        driver.execute_script("arguments[0].click();", popup_export_button)

        # --- 5. é‡å‘½åæ–‡ä»¶ ---
        file_date = date.today() if period in ["æœ¬æœˆ", "ä¸Šæœˆ"] else period
        find_and_rename_newest_file(download_path, filename_base, file_date)

    except Exception as e:
        print(f"    [é”™è¯¯] åœ¨å¤„ç† '{filename_base}' çš„ '{period}' æ—¶é—´æ®µæ—¶å¤±è´¥: {e}")
        driver.refresh()
        # [ä¿®æ”¹] æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œå°†ç­‰å¾…æ—¶é—´ç¼©çŸ­
        time.sleep(3)


def get_all_channels(driver, wait):
    """ç‚¹å‡»æ¸ é“ä¸‹æ‹‰æ¡†å¹¶è¿”å›æ‰€æœ‰æ¸ é“åç§°çš„åˆ—è¡¨"""
    print("    -> æ­£åœ¨è·å–æ‰€æœ‰æ¸ é“åˆ—è¡¨...")
    try:
        channel_dropdown_input = wait.until(EC.element_to_be_clickable((By.XPATH, "(//input[@class='el-select__input'])[1]")))
        driver.execute_script("arguments[0].click();", channel_dropdown_input)
        
        dropdown_panel_xpath = "//body/div[contains(@class, 'el-select-dropdown') and not(contains(@style,'display: none'))]"
        wait.until(EC.visibility_of_element_located((By.XPATH, dropdown_panel_xpath)))
        
        channel_elements = driver.find_elements(By.XPATH, f"{dropdown_panel_xpath}//ul/li")
        channels = [elem.text for elem in channel_elements if elem.text]
        
        driver.find_element(By.TAG_NAME, 'body').click()
        time.sleep(1)
        print(f"    [æˆåŠŸ] å…±è·å–åˆ° {len(channels)} ä¸ªæ¸ é“ã€‚")
        return channels
    except Exception as e:
        print(f"    [ä¸¥é‡é”™è¯¯] è·å–æ¸ é“åˆ—è¡¨å¤±è´¥: {e}")
        return []

# --- ä¸»ç¨‹åº ---
def main():
    print("--- å…¨åŠŸèƒ½è‡ªåŠ¨åŒ–ä¸‹è½½è„šæœ¬å¯åŠ¨ (é«˜é€Ÿç‰ˆ) ---")
    s = Service(CHROMEDRIVER_PATH)
    chrome_options = Options()
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    chrome_options.add_experimental_option('useAutomationExtension', False)
    chrome_options.add_argument("--disable-blink-features=AutomationControlled")
    driver = webdriver.Chrome(service=s, options=chrome_options)
    wait = WebDriverWait(driver, 30)
    driver.maximize_window()

    try:
        driver.get(LOGIN_URL)
        print("é¡µé¢åŠ è½½ä¸­ï¼Œç­‰å¾…ç™»å½•...")
        wait.until(EC.presence_of_element_located((By.XPATH, "//input[@placeholder='è´¦æˆ·']"))).send_keys(USERNAME)
        driver.find_element(By.XPATH, "//input[@placeholder='å¯†ç ']").send_keys(PASSWORD)
        driver.find_element(By.XPATH, "//button[contains(., 'ç™»å½•')]").click()
        
        print("\n" + "="*50)
        print("è„šæœ¬å·²æš‚åœï¼è¯·æ‰‹åŠ¨å®Œæˆå¯èƒ½çš„éªŒè¯ç éªŒè¯ã€‚")
        input("ç™»å½•æˆåŠŸå¹¶çœ‹åˆ°ä¸»é¡µåï¼Œè¯·å›åˆ°æ­¤çª—å£ï¼ŒæŒ‰ Enter (å›è½¦) é”®ç»§ç»­...")
        print("="*50 + "\nè„šæœ¬æ¢å¤ï¼Œå¼€å§‹ä¸‹è½½æŠ¥è¡¨...\n")

        reports = [
            {"name": "è¿è¥ç»Ÿè®¡", "type": "standard"},
            {"name": "ç”¨æˆ·ç•™å­˜ç‡(é¦–å……å¤ç™»)", "type": "user_retention"},
            {"name": "ç”¨æˆ·ç•™å­˜ç‡(é¦–å……å¤å……)", "type": "user_retention"},
            {"name": "èµ é€ç±»å‹ç»Ÿè®¡", "type": "standard"},
            {"name": "æ¨å¹¿æ¸ é“ç»Ÿè®¡", "type": "standard"},
            {"name": "æ¯æ—¥æ¸ é“ç»Ÿè®¡", "type": "daily_channel"},
            {"name": "LTV", "type": "ltv"},
        ]

        for report in reports:
            print(f"\n--- å¼€å§‹å¤„ç†æŠ¥è¡¨: {report['name']} ---")
            try:
                menu_item = wait.until(EC.element_to_be_clickable((By.XPATH, f"//li[normalize-space()='{report['name']}']")))
                menu_item.click()
                print(f"  > å·²è¿›å…¥ '{report['name']}' é¡µé¢ï¼Œç­‰å¾…åŠ è½½...")
                # [ä¿®æ”¹] æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œå°†ç­‰å¾…æ—¶é—´ç¼©çŸ­
                time.sleep(3)

                if report['type'] == 'standard':
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}", "æœ¬æœˆ")
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}", "ä¸Šæœˆ")

                elif report['type'] == 'daily_channel':
                    yesterday = date.today() - timedelta(days=1)
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_æ¸ é“è´¨é‡", yesterday, report_type="daily_channel")
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_ç”¨æˆ·è´¨é‡", yesterday, report_type="daily_channel")
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_ç»æµæ•ˆç›Š", yesterday, report_type="daily_channel")

                elif report['type'] == 'user_retention':
                    print("  -> é˜¶æ®µä¸€: ä¸‹è½½å…¨å¹³å°æ•°æ®")
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_å…¨å¹³å°", "æœ¬æœˆ")
                    perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_å…¨å¹³å°", "ä¸Šæœˆ")

                    print("\n  -> é˜¶æ®µäºŒ: éå†ä¸‹è½½å•ä¸ªæ¸ é“æ•°æ®")
                    all_channels = get_all_channels(driver, wait)
                    for channel in all_channels:
                        if channel in EXCLUDED_CHANNELS or channel == "å…¨å¹³å°":
                            print(f"    - è·³è¿‡æ¸ é“: {channel}")
                            continue
                        
                        print(f"    -> æ­£åœ¨å¤„ç†æ¸ é“: {channel}")
                        wait.until(EC.element_to_be_clickable((By.XPATH, "(//input[@class='el-select__input'])[1]"))).click()
                        channel_option = wait.until(EC.element_to_be_clickable((By.XPATH, f"//body/div[contains(@class, 'el-select-dropdown')]//li[normalize-space()=\"{channel}\"]")))
                        channel_option.click()
                        time.sleep(1)

                        safe_channel_name = "".join(c for c in channel if c.isalnum() or c in (' ', '_')).rstrip()
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_channel_name}", "æœ¬æœˆ")
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_channel_name}", "ä¸Šæœˆ")
                
                elif report['type'] == 'ltv':
                    print("  -> LTVæŠ¥è¡¨å¤„ç†å¼€å§‹...")
                    all_channels = get_all_channels(driver, wait)
                    processed_channels = set()

                    print("\n  -> é˜¶æ®µä¸€: æŒ‰åˆ†ç»„å¤šé€‰ä¸‹è½½")
                    for group_name, identifier in LTV_GROUPS.items():
                        print(f"    -> æ­£åœ¨å¤„ç†åˆ†ç»„: {group_name}")
                        channels_in_group = [ch for ch in all_channels if identifier in ch]
                        
                        if not channels_in_group:
                            print(f"      - æœªæ‰¾åˆ°å±äºè¯¥ç»„ '{group_name}' çš„æ¸ é“ï¼Œè·³è¿‡ã€‚")
                            continue

                        multiselect_input = wait.until(EC.element_to_be_clickable((By.XPATH, "(//input[@class='el-select__input'])[1]")))
                        multiselect_input.click()
                        wait.until(EC.visibility_of_element_located((By.XPATH, "//body/div[contains(@class, 'el-select-dropdown')]")))

                        for channel in channels_in_group:
                            print(f"      > å‹¾é€‰: {channel}")
                            option = driver.find_element(By.XPATH, f"//body/div[contains(@class, 'el-select-dropdown')]//li[normalize-space()=\"{channel}\"]")
                            option.click()
                            processed_channels.add(channel)
                        
                        driver.find_element(By.TAG_NAME, 'body').click()
                        time.sleep(2)

                        safe_group_name = "".join(c for c in group_name if c.isalnum() or c in (' ', '_')).rstrip()
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_group_name}", "æœ¬æœˆ")
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_group_name}", "ä¸Šæœˆ")

                        # æ¸…ç©ºé€‰æ‹©ï¼Œä¸ºä¸‹ä¸€ä¸ªåˆ†ç»„æˆ–å•ä¸ªæ¸ é“åšå‡†å¤‡
                        print("      > æ¸…ç©ºå½“å‰é€‰æ‹©...")
                        clear_icons = driver.find_elements(By.XPATH, "//i[contains(@class, 'el-tag__close')]")
                        for icon in reversed(clear_icons):
                            icon.click()
                        time.sleep(1)

                    print("\n  -> é˜¶æ®µäºŒ: ä¸‹è½½æœªåˆ†ç»„çš„å•ä¸ªæ¸ é“")
                    for channel in all_channels:
                        if channel in processed_channels or channel in EXCLUDED_CHANNELS or channel == "å…¨å¹³å°":
                            print(f"    - è·³è¿‡å·²å¤„ç†æˆ–è¢«æ’é™¤çš„æ¸ é“: {channel}")
                            continue

                        print(f"    -> æ­£åœ¨å¤„ç†å•ä¸ªæ¸ é“: {channel}")
                        wait.until(EC.element_to_be_clickable((By.XPATH, "(//input[@class='el-select__input'])[1]"))).click()
                        channel_option = wait.until(EC.element_to_be_clickable((By.XPATH, f"//body/div[contains(@class, 'el-select-dropdown')]//li[normalize-space()=\"{channel}\"]")))
                        channel_option.click()
                        time.sleep(1)

                        safe_channel_name = "".join(c for c in channel if c.isalnum() or c in (' ', '_')).rstrip()
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_channel_name}", "æœ¬æœˆ")
                        perform_export_flow(driver, wait, DOWNLOADS_PATH, f"download_{report['name']}_{safe_channel_name}", "ä¸Šæœˆ")

            except Exception as e:
                print(f"  [ä¸¥é‡é”™è¯¯] å¤„ç†æŠ¥è¡¨ '{report['name']}' æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
                print("  > å°è¯•åˆ·æ–°é¡µé¢å¹¶ç»§ç»­ä¸‹ä¸€ä¸ªä»»åŠ¡...")
                driver.refresh()
                time.sleep(5)
                continue

        print("\n" + "="*50)
        print("ğŸ‰ å…¨éƒ¨ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼")
        print("="*50)

    except Exception as e:
        print(f"\nè„šæœ¬åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}")
    finally:
        if 'driver' in locals() and driver:
            driver.quit()
        print("--- è„šæœ¬è¿è¡Œç»“æŸ ---")

if __name__ == "__main__":
    main()
